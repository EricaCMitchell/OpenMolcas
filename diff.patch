diff --git a/src/Include/commgo.fh b/src/Include/commgo.fh
new file mode 100644
index 0000000..2a24f0a
--- /dev/null
+++ b/src/Include/commgo.fh
@@ -0,0 +1,57 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+************************************************************************
+*                                                                      *
+* Common data for guessorb.                                            *
+*                                                                      *
+************************************************************************
+*----------------------------------------------------------------------*
+* Parameters                                                           *
+*----------------------------------------------------------------------*
+c      Integer MxSym
+c      Integer MxAtom
+      Integer MxBasis
+c      Parameter ( MxSym   =    8 )
+c      Parameter ( MxAtom  = 2000 )
+      Parameter ( MxBasis = 5000 )
+*----------------------------------------------------------------------*
+* Real*8 data.                                                         *
+*----------------------------------------------------------------------*
+      Real*8 xCharge(MxAtom)
+      Real*8 PrThr
+      Real*8 SThr
+      Real*8 TThr
+      Real*8 GapThr
+      Common /dblgo/ xCharge,PrThr,SThr,TThr,GapThr
+*----------------------------------------------------------------------*
+* Integer data.                                                        *
+*----------------------------------------------------------------------*
+      Integer nSym
+      Integer nBas(MxSym)
+      Integer nOcc(MxSym)
+      Integer nVir(MxSym)
+      Integer nDel(MxSym)
+      Integer nNuc
+      Integer iPrFmt
+      Common /intgo/ nSym,nOcc,nVir,nDel,nNuc,iPrFmt
+*----------------------------------------------------------------------*
+* Character data.                                                      *
+*----------------------------------------------------------------------*
+      Character*(LENIN) Name(MxAtom)
+      Character*(LENIN4) Label(MxBasis)
+      Common /chrgo/ Name,Label
+*----------------------------------------------------------------------*
+* Logical data.                                                        *
+*----------------------------------------------------------------------*
+      Logical PrintMOs
+      Logical PrintEor
+      Logical PrintPop
+      Common /loggo/ PrintMOs,PrintEor,PrintPop
diff --git a/src/Include/gsswfn.fh b/src/Include/gsswfn.fh
new file mode 100644
index 0000000..96fafc0
--- /dev/null
+++ b/src/Include/gsswfn.fh
@@ -0,0 +1,19 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+#ifdef _HDF5_
+#  include "mh5.fh"
+#endif
+
+      integer                 wfn_fileid,
+     $        wfn_energy, wfn_mocoef, wfn_occnum, wfn_orbene
+
+      common /gsswfn_handles/ wfn_fileid,
+     $        wfn_energy, wfn_mocoef, wfn_occnum, wfn_orbene
diff --git a/src/dmet/main.f b/src/dmet/main.f
new file mode 100644
index 0000000..d1de57a
--- /dev/null
+++ b/src/dmet/main.f
@@ -0,0 +1,19 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+      program main
+      implicit real*8 (a-h,o-z)
+      Character*20 Module_Name
+      Parameter (Module_Name = 'seward')
+
+      Call Start(Module_Name)
+*     Call seward(ireturn)
+      Call Finish(ireturn)
+      end
diff --git a/src/dmet_util/drv1el_dmet.f b/src/dmet_util/drv1el_dmet.f
new file mode 100644
index 0000000..05e076c
--- /dev/null
+++ b/src/dmet_util/drv1el_dmet.f
@@ -0,0 +1,168 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1991, Roland Lindh                                     *
+*               1996, Per Ake Malmqvist                                *
+************************************************************************
+      SubRoutine Drv1El_DMET(DMET_h,nBfn)
+************************************************************************
+*                                                                      *
+* Object: driver for computation of one-electron matrices.             *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              OneEl                                                   *
+*              GetDens                                                 *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, Dept. of Theoretical Chemistry,            *
+*             University of Lund, SWEDEN                               *
+*             January 1991                                             *
+************************************************************************
+      Use GeoList
+      Use MpmC
+      Use PrpPnt
+      Implicit Real*8 (A-H,O-Z)
+      External KnEInt
+      External KnEMem
+*     ipList: list of pointers to the integrals of each component
+*             of the operator
+*     OperI: list which irreps a particular component of the operator
+*            belongs to
+*     OperC: list the character of each component of the operator
+*     CoorO: list of origins of the operator, one for each component
+      Integer, Dimension(:), Allocatable :: ipList, OperI, OperC
+      Real*8, Dimension(:), Allocatable :: CoorO, Nuc
+      logical lECPnp,lPAM2np
+      Real*8 DMET_h(nBfn,nBfn)
+#include "itmax.fh"
+#include "info.fh"
+#include "print.fh"
+#include "nq_info.fh"
+#include "real.fh"
+#include "WrkSpc.fh"
+#include "stdalloc.fh"
+#include "wldata.fh"
+#include "property_label.fh"
+#include "oneswi.fh"
+#include "warnings.fh"
+      Character*8 Label
+      Character*512 FName
+      Integer nComp
+*
+      iRout = 131
+      iPrint = nPrint(iRout)
+*     Call qEnter('Drv1El')
+*
+      Call StatusLine(' Seward:',' Computing 1-electron integrals')
+*
+      Call Set_Basis_Mode('Valence')
+      Call Setup_iSD()
+#ifdef _FDE_
+      if (embPot) call EmbPotRdRun
+#endif
+
+*
+*     set center selector in OneSwi to all centers (default)
+*
+      NDDO = .FALSE.
+      If (Prprt.and.DKroll) Then
+         Call WarningMessage(2,
+     &               'Prprt and DKroll options can not be combined!')
+         Call Quit_OnUserError()
+      End If
+*
+*     We will always compute the following one-electron integrals per
+*     default.
+*     1) Multipole moments up to quadrupole moments
+*     2) Kinetic energy
+*     3) Nuclear Attraction
+*     4) ECP contributions
+*     5) One-Electron Hamiltonian
+*     6) Mass-Velocity
+*     7) Darwin 1-electron contact term
+*
+      lECPnp = lECP
+      lPAM2np = lPAM2
+      if (DKroll.and.Primitive_Pass) then
+         lECPnp = .False.
+      endif
+      If (Prprt) Then
+         FName=SW_FileOrb
+         IF (mylen(FName).eq.0) FName='INPORB'
+         Call GetDens(FName(:mylen(FName)),short,iPrint)
+         Call CollapseOutput(1,'   Molecular properties:')
+         Write (6,'(3X,A)')    '   ---------------------'
+         Write (6,*)
+      End If
+************************************************************************
+************************************************************************
+*2)                                                                    *
+*                                                                      *
+*     Kinetic energy, nuclear attraction and ECP/PP integrals          *
+*                                                                      *
+*     Mass-velocity and One-electron Darwin contact term integrals.    *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+      nComp=1
+*
+      If (.Not.Prprt) Then
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Zero,0,CoorO,1)
+         OperI(1) = 1
+         OperC(1) = iChBas(1)
+*
+         Label='Kinetic '
+         nOrdOp = 2
+         Call OneEl_DMET(KnEInt,KnEMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &              DMET_h,nBfn)
+*
+         Call Deallocate_Auxiliary()
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Free_iSD()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Call qExit('Drv1El')
+      Return
+*
+      Contains
+      Subroutine Allocate_Auxiliary()
+      Implicit None
+*
+      Call mma_Allocate(ipList,nComp,label='ipList')
+      Call mma_Allocate(OperI,nComp,label='OperI')
+      Call mma_Allocate(OperC,nComp,label='OperC')
+      Call mma_Allocate(CoorO,3*nComp,label='CoorO')
+      Call mma_Allocate(Nuc,nComp,label='Nuc')
+*
+      Return
+      End Subroutine Allocate_Auxiliary
+      Subroutine Deallocate_Auxiliary()
+      Implicit None
+*
+      Call mma_Deallocate(OperC)
+      Call mma_Deallocate(OperI)
+      Call mma_Deallocate(ipList)
+      Call mma_Deallocate(CoorO)
+      Call mma_Deallocate(Nuc)
+*
+      Return
+      End Subroutine Deallocate_Auxiliary
+*
+      End Subroutine Drv1el_DMET
diff --git a/src/dmet_util/drv2el_dmet.f b/src/dmet_util/drv2el_dmet.f
new file mode 100644
index 0000000..8cac4dc
--- /dev/null
+++ b/src/dmet_util/drv2el_dmet.f
@@ -0,0 +1,253 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1990,1991,1993,1998, Roland Lindh                      *
+*               1990, IBM                                              *
+************************************************************************
+      SubRoutine Drv2El_DMET(Integral_WrOut,ThrAO,DMET_g,nBfn)
+************************************************************************
+*                                                                      *
+*  Object: driver for two-electron integrals.                          *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              Timing                                                  *
+*              Setup_Ints                                              *
+*              Eval_Ints                                               *
+*              Term_Ints                                               *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, IBM Almaden Research Center, San Jose, CA  *
+*             March '90                                                *
+*                                                                      *
+*             Modified for k2 loop. August '91                         *
+*             Modified to minimize overhead for calculations with      *
+*             small basis sets and large molecules. Sept. '93          *
+*             Modified driver. Jan. '98                                *
+************************************************************************
+      use iSD_data
+      Implicit Real*8 (A-H,O-Z)
+      External Integral_WrOut, Rsv_GTList
+#include "itmax.fh"
+#include "info.fh"
+#include "lundio.fh"
+#include "print.fh"
+#include "real.fh"
+#include "stdalloc.fh"
+      Parameter(nTInt=1,mDens=1)
+      Real*8 DMET_g(nBfn**4)
+      Real*8 Dens(mDens), Fock(mDens), TInt(nTInt)
+      Integer iTOffs(8,8,8),
+     &        nShi(8), nShj(8), nShk(8), nShl(8)
+      Logical Verbose, Indexation, FreeK2,
+     &        W2Disc, PreSch, DoIntegrals, DoFock, DoGrad,
+     &        FckNoClmb, FckNoExch, Rsv_GTList, Triangular
+      Character*72 SLine
+      Real*8, Dimension(:,:), Allocatable :: TMax
+      Integer, Dimension(:,:), Allocatable :: Pair_Index
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout = 9
+      iPrint = nPrint(iRout)
+      Call QEnter('Drv2El')
+      SLine='Computing 2-electron integrals'
+      Call StatusLine(' Seward:',SLine)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      nInd=1
+      ExFac=One
+      Nr_Dens=1
+      DoIntegrals=.True.
+      DoFock=.False.
+      DoGrad=.False.
+      FckNoClmb=.False.
+      FckNoExch=.False.
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Set_Basis_Mode('Valence')
+      Call Setup_iSD()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Initialize for 2-electron integral evaluation. Do not generate
+*     tables for indexation.
+*
+      Indexation = .False.
+      Call Setup_Ints(nSkal,Indexation,ThrAO,DoFock,DoGrad)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Thize=Zero               ! Not used for conventional integrals
+      PreSch=.True.            ! Not used for conventional integrals
+      Disc_Mx=Zero             ! Not used for conventional integrals
+*
+      Disc=Zero
+      Dix_Mx=Zero
+      TskHi=Zero
+      TskLw=Zero
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---  Compute entities for prescreening at shell level
+*
+      Call mma_allocate(TMax,nSkal,nSkal)
+*     Call Shell_MxSchwz(nSkal,TMax)
+      Call DCopy_(nSkal**2,One,0,TMax,1)
+      TMax_all=Zero
+      Do iS = 1, nSkal
+         Do jS = 1, iS
+            TMax_all=Max(TMax_all,TMax(iS,jS))
+         End Do
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Create list of non-vanishing pairs
+*
+      Call mma_allocate(Pair_Index,2,nSkal*(nSkal+1)/2)
+      nij=0
+      Do iS = 1, nSkal
+         Do jS = 1, iS
+            If (TMax_All*TMax(iS,jS).ge.CutInt) Then
+               nij = nij + 1
+               Pair_Index(1,nij)=iS
+               Pair_Index(2,nij)=jS
+            End If
+         End Do
+      End Do
+      P_Eff=DBLE(nij)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Triangular=.True.
+      Call Alloc_TList(Triangular,P_Eff)
+      Call Init_TList(Triangular,P_Eff)
+      Call Init_PPList
+      Call Init_GTList
+      iOpt=0
+*
+      PP_Eff=P_Eff**2
+      PP_Eff_delta=0.10D0*PP_Eff
+      PP_Count=Zero
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call CWTime(TCpu1,TWall1)
+*
+*     big loop over individual tasks distributed over individual nodes
+*
+ 10   Continue
+*     make reservations of a tesk in global task list and get task range
+*     in return. Function will be false if no more tasks to execute.
+      If (.Not.Rsv_GTlist(TskLw,TskHi,iOpt,W2Disc)) Go To 11
+      W2Disc=.False.
+*
+*     Now do a quadruple loop over shells
+*
+      ijS = Int((One+sqrt(Eight*TskLw-Three))/Two)
+      iS = Pair_Index(1,ijS)
+      jS = Pair_Index(2,ijS)
+      klS = Int(TskLw-DBLE(ijS)*(DBLE(ijS)-One)/Two)
+      kS = Pair_Index(1,klS)
+      lS = Pair_Index(2,klS)
+      Count=TskLw
+*
+      If (Count-TskHi.gt.1.0D-10) Go To 12
+ 13   Continue
+*
+*     Logic to avoid computing integrals in a mixed muonic and
+*     electronic basis.
+*
+      iCnttp=iSD(13,iS)
+      jCnttp=iSD(13,jS)
+      If (fmass(iCnttp).ne.fmass(jCnttp)) Go To 14
+      kCnttp=iSD(13,kS)
+      lCnttp=iSD(13,lS)
+      If (fmass(kCnttp).ne.fmass(lCnttp)) Go To 14
+*
+      S_Eff=DBLE(ijS)
+      T_Eff=DBLE(klS)
+      ST_Eff=S_Eff*(S_Eff-One)/2D0 + T_Eff
+      If (ST_Eff.ge.PP_Count) Then
+         Write (SLine,'(A,F5.2,A)') 'Computing 2-electron integrals,',
+     &        ST_Eff/PP_Eff*100d0,'% done so far.'
+         Call StatusLine(' Seward:',SLine)
+         PP_Count = PP_Count + PP_Eff_delta
+      End If
+*
+*
+         Aint=TMax(iS,jS)*TMax(kS,lS)
+         If (AInt.lt.CutInt) Go To 14
+         Call Eval_Ints_New_DMET
+     &                  (iS,jS,kS,lS,TInt,nTInt,
+     &                   iTOffs,nShi,nShj,nShk,nShl,
+     &                   nShOffi,nShOffj,nShOffk,nShOffl,
+     &                   Integral_WrOut,
+* the following are dummy arguments
+     &                   Dens,Fock,mDens,ExFac,Nr_Dens,
+     &                   Ind,nInd,FckNoClmb,FckNoExch,
+     &                   Thize,W2Disc,PreSch,Dix_Mx,Disc,
+     &                   Count,DoIntegrals,DoFock,
+     &                   DMET_g,nBfn)
+ 14      Continue
+         Count=Count+One
+         If (Count-TskHi.gt.1.0D-10) Go To 12
+         klS = klS + 1
+         If (klS.gt.ijS) Then
+            ijS = ijS + 1
+            klS = 1
+         End If
+         iS = Pair_Index(1,ijS)
+         jS = Pair_Index(2,ijS)
+         kS = Pair_Index(1,klS)
+         lS = Pair_Index(2,klS)
+         Go To 13
+*
+*     Task endpoint
+ 12   Continue
+*
+*     Use a time slot to save the number of tasks and shell
+*     quadrupltes process by an individual node
+      Call SavStat(1,One,'+')
+      Call SavStat(2,TskHi-TskLw+One,'+')
+      Go To 10
+ 11   Continue
+*     End of big task loop
+      Call CWTime(TCpu2,TWall2)
+      Call SavTim(1,TCpu2-TCpu1,TWall2-TWall1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*                         E P I L O G U E                              *
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Free_GTList
+      Call Free_PPList
+      Call Free_TList
+*
+      Call mma_deallocate(Pair_Index)
+      Call mma_deallocate(TMax)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Terminate integral environment.
+*
+      Verbose = .False.
+      FreeK2=.True.
+      Call Term_Ints(Verbose,FreeK2)
+      Call Free_iSD()
+      Call QExit('Drv2El')
+      Return
+      End
diff --git a/src/dmet_util/eval_ints_new_dmet.f b/src/dmet_util/eval_ints_new_dmet.f
new file mode 100644
index 0000000..9f7b938
--- /dev/null
+++ b/src/dmet_util/eval_ints_new_dmet.f
@@ -0,0 +1,593 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1991,1993,1999, Roland Lindh                           *
+*               1995, Martin Schuetz                                   *
+************************************************************************
+      SubRoutine Eval_Ints_New_DMET(iiS,jjS,kkS,llS,TInt,nTInt,
+     &                          iTOffs,nShi,nShj,nShk,nShl,
+     &                          nShOffi,nShOffj,nShOffk,nShOffl,
+     &                          Integ_Proc,
+     &                          Dens,Fock,lDens,ExFac,nDens,
+     &                          Ind,nInd,FckNoClmb,FckNoExch,
+     &                          Thize,W2Disc,PreSch,Disc_Mx,Disc,
+     &                          Quad_ijkl,DoIntegrals,DoFock,
+     &                          DMET_g,nBfn)
+************************************************************************
+*                                                                      *
+*  Object: driver for two-electron integrals, parallel region          *
+*          contains memory partitioning and loops over uncontracted    *
+*          functions...                                                *
+*                                                                      *
+*  Input:                                                              *
+*          iiS,jjS,kkS,llS     : shell indices                         *
+*          TInt                : Computed Integrals                    *
+*          nTInt               : dimension of TInt                     *
+*          iTOffs              : iTOffs holds symmetry block offsets   *
+*                                                                      *
+*     nShi,nShj,          Dimensions used for blocks in Tint (input)   *
+*     nshk,nshl:          Symmetry block isym,jsym,ksym,lsym for       *
+*                         shells iS,jS,kS,lS starts at                 *
+*                         iTOffs(ksym,jsym,isym)+1 and is dimensioned  *
+*                         [nshl(lsym),nshk(ksym),nshj(jsym,nshi(isym)] *
+*                         Note that l runs fastest! The dimensions     *
+*                         must be larger or equal to the number of     *
+*                         SAOs in the specified shells and symmetries, *
+*                         otherwise chaos!!                            *
+*                                                                      *
+*     nShOffi,nShOffj,    Offsets of Integral symmetry blocks (input)  *
+*     nShOffk,nShOffl:    An Integral (lso,kso|jso,iso) is placed at   *
+*                         [lb,kb,jb,ib] where lb=lso-nShOffl(lsym),    *
+*                         kb=kso-nShOffk(ksym) etc. Here lso,kso etc   *
+*                         are the SAO labels within their symmetry.    *
+*                         More explicitly, the Integral is stored in   *
+*                         in Tint(ijkl), where                         *
+*                                                                      *
+*                         ijkl = iTOffs(ksym,jsym,isym)                *
+*                           + (ib-1)*nshj(jsym)*nshk(ksym)*nshl(lsym)  *
+*                           + (jb-1)*nshk(ksym)*nshl(lsym)             *
+*                           + (kb-1)*nshl(lsym)                        *
+*                           +  lb                                      *
+*                                                                      *
+*          Dens                : 1-particle density matrix             *
+*          lDens               : length of density/Fock matrices       *
+*          nDens               : # of density/Fock matrices            *
+*          ExFac               : another scaling factor passed to      *
+*                                Integ_Proc                            *
+*          Ind,nInd            : auxiliary index list for Fock matrix  *
+*                                construction (cf. d1ind_CpFck)        *
+*          FckNoClmb           : no Coulomb contributions to Fock mat. *
+*          FckNoExch           : no exchange contributions to Fock mat.*
+*          Thize               : int threshold for disk write (SD)     *
+*          W2Disc,PreSch       : booleans 1st iter / prescreening      *
+*          Disc_Mx             : # ints to write on disk (semidirect)  *
+*          iDisk               : act. position in file TMPINT          *
+*                                                                      *
+*  Auxiliary:                                                          *
+*          ipMem1              : base pointer to Scratch space for     *
+*                                Integral batch, which is further      *
+*                                partitioned within this subroutine    *
+*          MemMax              : amount of wrkspace for processing of  *
+*                                integral batch                        *
+*                                                                      *
+*  Output: Fock                : 2el Hamiltonian                       *
+*          Disc                : # ints written to disk (semidirect)   *
+*                                                                      *
+*                                                                      *
+*  Local:                                                              *
+*          Coor                : coordinates of four centers           *
+*          iAngV               : angular momenta                       *
+*          iCmpV               : # spherical components                *
+*          iShelV,iShllV       : shell indices                         *
+*          iAOV                : pointers to ??                        *
+*          iStabs              : IDs of 4 unique centers, i.e. ptrs to *
+*          Shijij,                           : swap booleans           *
+*                                                                      *
+* Called from:                                                         *
+*                                                                      *
+* Calling    : QEnter,QExit                                            *
+*              GetMem                                                  *
+*              Int_Setup                                               *
+*              Dens_Info                                               *
+*              MemRys                                                  *
+*              PSOAO0                                                  *
+*              Picky_                                                  *
+*              TwoEl_NoSym                                             *
+*              TwoEl_Sym                                               *
+*              Integ_Proc                                              *
+*                                                                      *
+*             Roland Lindh / Martin Schuetz,                           *
+*             Dept. of Theoretical Chemistry, University of Lund,      *
+*             SWEDEN.                                                  *
+*             Modified for k2 loop. August '91                         *
+*             Modified for direct SCF. January '93                     *
+*             Modified to minimize overhead for calculations with      *
+*             small basis sets and large molecules. Sept. '93          *
+*             parallel region split off in drvtwo.f, April '95         *
+*             Total rehack May '99                                     *
+************************************************************************
+      use k2_setup
+      use iSD_data
+      Implicit Real*8 (A-H,O-Z)
+      External Integ_Proc
+*     subroutine parameters
+      Integer lDens
+      Real*8 DMET_g(nBfn**4)
+      Real*8  Coor(3,4),Thize,Fock(lDens,nDens),Dens(lDens,nDens),
+     &        ExFac(nDens), Disc_Mx,Disc, TInt(nTInt), Tmax
+      Integer iAngV(4),iCmpV(4),
+     &        iShelV(4),iShllV(4),iAOV(4),iStabs(4),
+     &        ipMem1,MemMax,
+     &        iTOffs(8,8,8),Map4(4),
+     &        nShi(0:7), nShj(0:7), nShk(0:7), nShl(0:7),
+     &        nShOffi(0:7), nShOffj(0:7), nShOffk(0:7), nShOffl(0:7),
+     &        Ind(nInd,nInd,2),kOp(4)
+      Logical Shijij, W2Disc,PreSch,NoInts,FckNoClmb(nDens),
+     &        FckNoExch(nDens), DoIntegrals,DoFock
+*
+#include "ndarray.fh"
+#include "real.fh"
+#include "itmax.fh"
+#include "info.fh"
+#include "WrkSpc.fh"
+#include "print.fh"
+#include "k2.fh"
+#include "setup.fh"
+#include "status.fh"
+*
+      Common /ibas_ricd/ jbas_, lbas_
+*     local variables to save
+      Integer ipDDij,ipDDkl,ipDDik,ipDDil,ipDDjk,ipDDjl,
+     &        iBsInc,jBsInc,kBsInc,lBsInc,iPrInc,jPrInc,kPrInc,lPrInc,
+     &        ipMem2,
+     &        Mem1,Mem2
+      Save    ipDDij,ipDDkl,ipDDik,ipDDil,ipDDjk,ipDDjl,
+     &        iBsInc,jBsInc,kBsInc,lBsInc,iPrInc,jPrInc,kPrInc,lPrInc,
+     &        ipMem2,
+     &        Mem1,Mem2
+*     other local variables
+      Integer iAOst(4), iPrimi,jPrimj,kPrimk,lPriml,
+     &        iBasi,jBasj,kBask,lBasl,
+     &  ipCffi,jpCffj,kpCffk,lpCffl,
+     &  iBasn,jBasn,kBasn,lBasn,
+     &  k2ij,nDCRR,k2kl,nDCRS, ipTmp,
+     &  mDij,mDik,mDjk,mDkl,mDil,mDjl,
+     &  mDCRij,mDCRik,mDCRjk,mDCRkl,mDCRil,mDCRjl,
+     &  ipDij,ipDik,ipDjk,ipDkl,ipDil,ipDjl,
+     &  ipZI,ipKab,ipP,nZeta,
+     &  ipEta,ipEI,ipiEta,ipKcd,ipQ,nEta
+      Integer   nSO,iBasAO,jBasAO,kBasAO,lBasAO,
+     &  iS,jS,kS,lS,ijS,klS,ikS,ilS,jkS,jlS
+      Logical IJeqKL
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Statement functions
+*
+      nElem(i)=(i+1)*(i+2)/2
+      iTri(i,j) = Max(i,j)*(Max(i,j)-1)/2 + Min(i,j)
+      nabSz(ixyz) = (ixyz+1)*(ixyz+2)*(ixyz+3)/6  - 1
+*
+      ipDDij=ip_Dummy
+      mDCRij=1
+      ipDDkl=ip_Dummy
+      mDCRkl=1
+      ipDDik=ip_Dummy
+      ipDDil=ip_Dummy
+      ipDDjk=ip_Dummy
+      ipDDjl=ip_Dummy
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (ERI_Status.ne.Active) Then
+         Call WarningMessage(2,
+     &               'Eval_Ints_: Integral environment is not set up!')
+         Call Abend()
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout=9
+      iPrint=nPrint(iRout)
+*
+      NoInts=.True.
+      Tmax=Zero
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     If memory not allocated already at this point allocate!          *
+*                                                                      *
+      If (MemMax_int.eq.0) Then
+        Call GetMem('MaxMem','Max','Real',iDum,MemMax)
+        Call GetMem('MaxMem','Allo','Real',ipMem1,MemMax)
+        MemMax_int=MemMax
+        ipMem_int =ipMem1
+      Else
+        MemMax=MemMax_int
+        ipMem1=ipMem_int
+      End If
+*
+      Map4(1)=1
+      Map4(2)=2
+      Map4(3)=3
+      Map4(4)=4
+      iS_=Max(iiS,jjS)
+      jS_=Min(iiS,jjS)
+      kS_=Max(kkS,llS)
+      lS_=Min(kkS,llS)
+      If (iiS.ne.iS_) Then
+          iTmp=Map4(1)
+          Map4(1)=Map4(2)
+          Map4(2)=iTmp
+      End If
+      If (kkS.ne.kS_) Then
+          iTmp=Map4(3)
+          Map4(3)=Map4(4)
+          Map4(4)=iTmp
+      End If
+*     Write (*,*) ' -->',iS_,jS_,kS_,lS_,'<--'
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Int_Setup(iSD,mSkal,iS_,jS_,kS_,lS_,
+     &               Coor,Shijij,
+     &               iAngV,iCmpV,iShelV,iShllV,iAOV,iStabs)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iPrimi   = nExp(iShllV(1))
+      jPrimj   = nExp(iShllV(2))
+      kPrimk   = nExp(iShllV(3))
+      lPriml   = nExp(iShllV(4))
+      iBasi    = nBasis(iShllV(1))
+      jBasj    = nBasis(iShllV(2))
+      kBask    = nBasis(iShllV(3))
+      lBasl    = nBasis(iShllV(4))
+      ipCffi   = ipCff(iShllV(1))
+      jpCffj   = ipCff(iShllV(2))
+      kpCffk   = ipCff(iShllV(3))
+      lpCffl   = ipCff(iShllV(4))
+      nZeta = iPrimi * jPrimj
+      nEta = kPrimk * lPriml
+      mDij=nZeta+1 ! Dummy initialize
+      mDkl=nEta+1  ! Dummy initialize
+*
+      nHRRAB=iCmpV(1)*iCmpV(2)*
+     &      (nabSz(iAngV(1)+iAngV(2)) -
+     &       nabSz(Max(iAngV(1),iAngV(2))-1))
+      nHRRCD=iCmpV(3)*iCmpV(4)*
+     &      (nabSz(iAngV(3)+iAngV(4)) -
+     &       nabSz(Max(iAngV(3),iAngV(4))-1))
+      nHRRAB=nHRRAB*nIrrep
+      nHRRCD=nHRRCD*nIrrep
+      If (DoGrad_) Then
+         ijCmp=nElem(iAngV(1))*nElem(iAngV(2))
+         klCmp=nElem(iAngV(3))*nElem(iAngV(4))
+      Else
+         ijCmp=0
+         klCmp=0
+      End If
+      mData1=nZeta*(nDArray+2*ijCmp)+nDScalar+nHRRAB
+      mData2=nEta*(nDArray+2*klCmp)+nDScalar+nHRRCD
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     partition memory for K2(ij)/K2(kl) temp spaces zeta,eta,kappa,P,Q
+      ipZI  = ipZeta + nZeta
+      ipKab = ipZI   + nZeta
+      ipP   = ipKab  + nZeta
+      ipEta = ipP    + nZeta*3
+      ipEI  = ipEta  + nEta
+      ipKcd = ipEI   + nEta
+      ipQ   = ipKcd  + nEta
+      ipiEta = ipiZet + nZeta
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+*     No SO block in direct construction of the Fock matrix.
+      nSO = MemSO2(iAngV(1),iAngV(2),iAngV(3),iAngV(4),
+     &             iCmpV(1),iCmpV(2),iCmpV(3),iCmpV(4),
+     &             iShelV(1),iShelV(2),iShelV(3),iShelV(4))
+      If (nSO.eq.0) Then
+        Return
+*       Call GetMem('0Exit_DrvTwo0','Check','Real',iDum,iDum)
+      End If
+      If (.Not.DoIntegrals) nSO = 0
+*
+      iS = iShelV(1)
+      jS = iShelV(2)
+      kS = iShelV(3)
+      lS = iShelV(4)
+      ijS = iTri(iS,jS)
+      klS = iTri(kS,lS)
+      ikS = iTri(iS,kS)
+      ilS = iTri(iS,lS)
+      jkS = iTri(jS,kS)
+      jlS = iTri(jS,lS)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Pick up pointers to k2 entities.
+*
+      k2ij  = IndK2(1,ijS)
+      nDCRR = IndK2(2,ijS)
+      k2kl  = IndK2(1,klS)
+      nDCRS = IndK2(2,klS)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Pick up pointers to desymmetrized 1st order density
+*     matrices. Observe that the desymmetrized 1st order
+*     density matrices follows the contraction index.
+*
+      If (DoFock) Then
+         ipTmp = ipDijs
+         Nr_of_D=1
+         Call Dens_Info(ijS,ipDij,ipDum,mDCRij,ipDDij,ipTmp,Nr_of_D)
+         Call Dens_Info(klS,ipDkl,ipDum,mDCRkl,ipDDkl,ipTmp,Nr_of_D)
+         Call Dens_Info(ikS,ipDik,ipDum,mDCRik,ipDDik,ipTmp,Nr_of_D)
+         Call Dens_Info(ilS,ipDil,ipDum,mDCRil,ipDDil,ipTmp,Nr_of_D)
+         Call Dens_Info(jkS,ipDjk,ipDum,mDCRjk,ipDDjk,ipTmp,Nr_of_D)
+         Call Dens_Info(jlS,ipDjl,ipDum,mDCRjl,ipDDjl,ipTmp,Nr_of_D)
+*
+c        Write (*,*) ' Pointers to D=',
+c    &                ipDij,ipDkl,ipDik,ipDil,ipDjk,ipDjl
+*
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (iPrint.ge.99) Then
+         Write (6,*) ' *** Centers ***'
+         Write (6,'(3F7.3,6X,3F7.3)')
+     &         ((Coor(i,j),i=1,3),j=1,2)
+         Write (6,'(3F7.3,6X,3F7.3)')
+     &         ((Coor(i,j),i=1,3),j=3,4)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Compute memory request for the primitives, i.e.
+*     how much memory is needed up to the transfer
+*     equation.
+      Call MemRys(iAngV,MemPrm)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Decide on the partioning of the shells based on the
+*     available memory and the requested memory.
+      Call PSOAO0(nSO,MemPrm,MemMax,
+     &            iAngV,iCmpV,
+     &            iBasi,iBsInc,jBasj,jBsInc,
+     &            kBask,kBsInc,lBasl,lBsInc,
+     &            iPrimi,iPrInc,jPrimj,jPrInc,
+     &            kPrimk,kPrInc,lPriml,lPrInc,
+     &            ipMem1,ipMem2,
+     &            Mem1,Mem2,DoFock)
+      If (iPrint.ge.59) Then
+         Write (6,*) ' ************** Memory partioning **************'
+         Write (6,*) ' ipMem1=',ipMem1
+         Write (6,*) ' ipMem2=',ipMem2
+         Write (6,*) ' Mem1=',Mem1
+         Write (6,*) ' Mem2=',Mem2
+         Write (6,*) ' iBasi,iBsInc=',iBasi,iBsInc
+         Write (6,*) ' jBasj,jBsInc=',jBasj,jBsInc
+         Write (6,*) ' kBasi,kBsInc=',kBask,kBsInc
+         Write (6,*) ' lBasl,lBsInc=',lBasl,lBsInc
+         Write (6,*) ' iPrimi,iPrInc=',iPrimi,iPrInc
+         Write (6,*) ' jPrimj,jPrInc=',jPrimj,jPrInc
+         Write (6,*) ' kPrimk,kPrInc=',kPrimk,kPrInc
+         Write (6,*) ' lPriml,lPrInc=',lPriml,lPrInc
+         Write (6,*) ' ***********************************************'
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      jbas_=jBasj
+      lbas_=lBasl
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     FacInt : scaling factor for the integrals passed down to         *
+*              Integ_Proc                                              *
+*
+      FacInt=1.0D0
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     These loops will partition the contraction loops if there is not
+*     enough memory to store the whole SO/AO-block simultaneously. The
+*     memory partitioning is determined by PSOAO0.
+*
+      Do iBasAO = 1, iBasi, iBsInc
+         iBasn=Min(iBsInc,iBasi-iBasAO+1)
+         iAOst(1) = iBasAO-1
+*
+         Do jBasAO = 1, jBasj, jBsInc
+            jBasn=Min(jBsInc,jBasj-jBasAO+1)
+            iAOst(2) = jBasAO-1
+*
+*---------- Move appropiate portions of the desymmetrized 1st
+*           order density matrix.
+*
+            If (DoFock) Then
+               Call Picky_(iBasi,iBsInc,iPrimi,iBasAO,iBasn,
+     &                     jBasj,jBsInc,jPrimj,jBasAO,jBasn,
+     &                     iCmpV(1),iCmpV(2),iShelV(1),iShelV(2),
+     &                     mDCRij,ipDij,ipDDij,mDij,nIrrep)
+            End If
+*
+            Do kBasAO = 1, kBask, kBsInc
+               kBasn=Min(kBsInc,kBask-kBasAO+1)
+               iAOst(3) = kBasAO-1
+*
+               If (DoFock) Then
+                  Call Picky_(iBasi,iBsInc,iPrimi,iBasAO,iBasn,
+     &                        kBask,kBsInc,kPrimk,kBasAO,kBasn,
+     &                        iCmpV(1),iCmpV(3),iShelV(1),iShelV(3),
+     &                        mDCRik,ipDik,ipDDik,mDik,nIrrep)
+               End If
+*
+               If (DoFock) Then
+                  Call Picky_(jBasj,jBsInc,jPrimj,jBasAO,jBasn,
+     &                        kBask,kBsInc,kPrimk,kBasAO,kBasn,
+     &                        iCmpV(2),iCmpV(3),iShelV(2),iShelV(3),
+     &                        mDCRjk,ipDjk,ipDDjk,mDjk,nIrrep)
+               End If
+*
+                Do lBasAO = 1, lBasl, lBsInc
+                   lBasn=Min(lBsInc,lBasl-lBasAO+1)
+                   iAOst(4) = lBasAO-1
+*
+                   If (DoFock) Then
+                      Call Picky_(kBask,kBsInc,kPrimk,kBasAO,kBasn,
+     &                            lBasl,lBsInc,lPriml,lBasAO,lBasn,
+     &                            iCmpV(3),iCmpV(4),iShelV(3),iShelV(4),
+     &                            mDCRkl,ipDkl,ipDDkl,mDkl,nIrrep)
+                   End If
+*
+                   If (DoFock) Then
+                      Call Picky_(iBasi,iBsInc,iPrimi,iBasAO,iBasn,
+     &                            lBasl,lBsInc,lPriml,lBasAO,lBasn,
+     &                            iCmpV(1),iCmpV(4),iShelV(1),iShelV(4),
+     &                            mDCRil,ipDil,ipDDil,mDil,nIrrep)
+                   End If
+*
+                   If (DoFock) Then
+                      Call Picky_(jBasj,jBsInc,jPrimj,jBasAO,jBasn,
+     &                            lBasl,lBsInc,lPriml,lBasAO,lBasn,
+     &                            iCmpV(2),iCmpV(4),iShelV(2),iShelV(4),
+     &                            mDCRjl,ipDjl,ipDDjl,mDjl,nIrrep)
+                   End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*                 Compute SO/AO-integrals
+*
+                  If (.FALSE.) Then
+                  If (nIrrep.eq.1) Then
+*
+                  Call TwoEl_NoSym_New(iS_,jS_,kS_,lS_,
+     &                            Coor,
+     &                            iAngV,iCmpV,iShelV,iShllV,
+     &                            iAOV,iAOst,NoInts,
+     &                            iStabs(1),iStabs(2),
+     &                            iStabs(3),iStabs(4),
+     &                            iPrimi,iPrInc,jPrimj,jPrInc,
+     &                            kPrimk,kPrInc,lPriml,lPrInc,
+     &                            Data_k2(k2ij),mData1,nDCRR,
+     *                            Data_k2(k2kl),mData2,nDCRS,
+     &                            IJeqKL,kOp,Disc_Mx,Disc,Thize,
+     &                            Work(ipDDij),mDij,mDCRij,
+     &                            Work(ipDDkl),mDkl,mDCRkl,
+     & Work(ipDDik),mDik,mDCRik,Work(ipDDil),mDil,mDCRil,Work(ipDDjk),
+     & mDjk,mDCRjk, Work(ipDDjl),mDjl,mDCRjl,Fock,Dens,lDens,
+     &                            Work(ipCffi+(iBasAO-1)*iPrimi),iBasn,
+     &                            Work(jpCffj+(jBasAO-1)*jPrimj),jBasn,
+     &                            Work(kpCffk+(kBasAO-1)*kPrimk),kBasn,
+     & Work(lpCffl+(lBasAO-1)*lPriml),lBasn, Work(ipFT),nFT,
+     &Work(ipZeta),Work(ipZI),iWork(ipiZet),Work(ipKab),Work(ipP),nZeta,
+     &Work(ipEta), Work(ipEI),iWork(ipiEta),Work(ipKcd),Work(ipQ),nEta,
+     & Work(ipMem1),nSO,Work(ipMem2),Mem2,
+     & Shijij,W2Disc,PreSch,Quad_ijkl,nHRRAB,nHRRCD,
+     & DoIntegrals,DoFock,FckNoClmb(1),FckNoExch(1),Work(ipAux),nAux,
+     & ExFac(1))
+*
+                  Else
+*
+
+                  Call TwoEl_Sym_New(iS_,jS_,kS_,lS_,
+     &                            Coor,
+     &                            iAngV,iCmpV,iShelV,iShllV,
+     &                            iAOV,iAOst,NoInts,
+     &                            iStabs(1),iStabs(2),
+     &                            iStabs(3),iStabs(4),
+     &                            iPrimi,iPrInc,jPrimj,jPrInc,
+     &                            kPrimk,kPrInc,lPriml,lPrInc,
+     &                            Data_k2(k2ij),mData1,nDCRR,
+     &                            Data_k2(k2kl),mData2,nDCRS,
+     &                            IJeqKL,kOp,Disc_Mx,Disc,Thize,
+     &                            Work(ipDDij),mDij,mDCRij,
+     &                            Work(ipDDkl),mDkl,mDCRkl,
+     & Work(ipDDik),mDik,mDCRik,Work(ipDDil),mDil,mDCRil,Work(ipDDjk),
+     & mDjk,mDCRjk, Work(ipDDjl),mDjl,mDCRjl,Fock,Dens,lDens,
+     &                            Work(ipCffi+(iBasAO-1)*iPrimi),iBasn,
+     &                            Work(jpCffj+(jBasAO-1)*jPrimj),jBasn,
+     &                            Work(kpCffk+(kBasAO-1)*kPrimk),kBasn,
+     & Work(lpCffl+(lBasAO-1)*lPriml),lBasn, Work(ipFT),nFT,
+     &Work(ipZeta),Work(ipZI),iWork(ipiZet),Work(ipKab),Work(ipP),nZeta,
+     &Work(ipEta), Work(ipEI),iWork(ipiEta),Work(ipKcd),Work(ipQ),nEta,
+     & Work(ipMem1),nSO,Work(ipMem2),Mem2,
+     & Shijij,W2Disc,PreSch,Quad_ijkl,nHRRAB,nHRRCD,
+     & DoIntegrals,DoFock,FckNoClmb(1),FckNoExch(1),Work(ipAux),nAux,
+     & ExFac(1))
+*
+                  End If
+                  Else
+                     NoInts=.False.
+                  End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*              Process SO/AO-integrals
+*
+                  nijkl=iBasn*jBasn*kBasn*lBasn
+                  If (DoIntegrals.and..Not.NoInts) Then
+*                    Get max AO/SO integrals
+                     If (Petite) Then
+                        n=nijkl*iCmpV(1)*iCmpV(2)*iCmpV(3)*iCmpV(4)
+                        If (n.ne.nBfn**4) Then
+                           Write (6,*) 'Size mismatch'
+                           Call Abend()
+                        End If
+*                       ip=ipMem2
+                        ip=1
+                     Else
+                        n=nijkl*nSO
+                        ip=ipMem1
+                        Write (6,*) 'Symmetry not allowed'
+                        Call Abend()
+                     End If
+*                    Tmax=max(Tmax,
+*    &                        abs(Work(ip+iDAMax_(n,Work(ip),1)-1)))
+                     Tmax=max(Tmax,
+     &                        abs(DMET_g(ip+iDAMax_(n,DMET_g(ip),1)-1)))
+                     If (Tmax.gt.CutInt) Then
+                        kOp(1)=0
+                        kOp(2)=0
+                        kOp(3)=0
+                        kOp(4)=0
+                        Call Integ_Proc(iCmpV,iShelV,Map4,
+     &                                  iBasn,jBasn,kBasn,lBasn,kOp,
+     &                                  Shijij,IJeqKL,iAOV,iAOst,nijkl,
+     &                                  DMET_g,Work,Work(ipMem1),nSO,
+     &                                  iWork(ipiSOSym),mSkal,nSOs,
+     &                                  TInt,nTInt,FacInt,
+     &                                  iTOffs,nIrrep,
+     &                                  nShi,nShj,nShk,nShl,
+     &                                  nShOffi,nShOffj,nShOffk,nShOffl,
+     &                                  Dens,Fock,lDens,ExFac,nDens,
+     &                                  Ind,nInd,FckNoClmb,FckNoExch)
+                     Else
+                        Tmax=Zero
+                     End If
+                  End If
+*
+               End Do
+            End Do
+         End Do
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+      Return
+      End
diff --git a/src/dmet_util/fckbyint_dmet.f b/src/dmet_util/fckbyint_dmet.f
new file mode 100644
index 0000000..69fea7c
--- /dev/null
+++ b/src/dmet_util/fckbyint_dmet.f
@@ -0,0 +1,507 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 2004, Per-Olof Widmark                                 *
+************************************************************************
+************************************************************************
+*                                                                      *
+* This routine creates start orbitals from model fock matrix elements  *
+* generated by SEWARD.                                                 *
+*                                                                      *
+*----------------------------------------------------------------------*
+*                                                                      *
+* Author:  Per-Olof Widmark                                            *
+*          Lund University                                             *
+*          Sweden                                                      *
+* Written: Oct 2004                                                    *
+*                                                                      *
+************************************************************************
+      Subroutine FckByInt_DMET(iReturn,DMET_f,nbas)
+      Implicit Real*8 (a-h,o-z)
+#include "stdalloc.fh"
+#include "Molcas.fh"
+#include "commgo.fh"
+#include "gsswfn.fh"
+      Real*8, Dimension(:), Allocatable :: DMET_f, CMO_DMET, Ovl_DMET,
+     &                                     T1, T2, T3, Eps_DMET
+*----------------------------------------------------------------------*
+* Dummy arguments                                                      *
+*----------------------------------------------------------------------*
+      Integer iReturn, nOrb(8)
+*----------------------------------------------------------------------*
+* Local variables                                                      *
+*----------------------------------------------------------------------*
+      Character*180 Line
+      Logical Debug
+      Logical Trace
+      Character*80 Title
+      Logical Verify
+*----------------------------------------------------------------------*
+      Integer IndType(7,8)
+      Integer nTmp(8)
+      Integer nBasTot
+      Integer nBasMax
+      Integer nTriTot
+      Integer nSqrTot
+      Integer iSym
+      Integer iBas
+      Integer jBas
+      Integer kBas
+*----------------------------------------------------------------------*
+      Integer inDMET_f
+      Integer inCMO_DMET
+      Integer inOvl_DMET
+      Integer inEps_DMET
+      Integer inT1
+      Integer inT2
+      Integer inT3
+*----------------------------------------------------------------------*
+      Integer Lu
+      Integer irc
+      Integer iSymlb
+      Integer ij,ijS,ijT,ijL
+      Integer nB
+      Integer nC
+      Integer nS
+      Integer nD
+      Integer nActEl
+      Real*8  dActEl
+      Integer nIsh(8)
+      Integer nAsh(8)
+*      Integer nDel(MxSym)
+*      Logical PrintPop, PrintMOs
+*----------------------------------------------------------------------*
+* Do some counting                                                     *
+*----------------------------------------------------------------------*
+      nBasTot=0
+      nBasMax=0
+      nTriTot=0
+      nSqrTot=0
+      Do iSym=1,nSym
+         nBasTot=nBasTot+nbas(iSym)
+         nBasMax=Max(nbasmax,nBas(iSym))
+         nTriTot=nTriTot+nBas(iSym)*(nBas(iSym)+1)/2
+         nSqrTot=nSqrTot+nBas(iSym)*nBas(iSym)
+      End Do
+*----------------------------------------------------------------------*
+* Get model Fock matrix.                                               *
+*----------------------------------------------------------------------*
+      inFck=nTriTot+6
+      Write(6,*) 'allocate'
+      Call mma_allocate(DMET_f,inDMET_f)
+      iRc=-1
+      iSymlb=1
+      Write(6,*) 'wrone'
+      Call WrOne(iRC,6,'FckInt  ',1,DMET_f,iSmLbl)
+      Write(6,*) 'rdone'
+      Call RdOne(irc,6,'FckInt  ',1,DMET_f,iSymlb)
+      If (iRc.ne.0) Then
+         iReturn=1
+         Call mma_deallocate(DMET_f)
+         Write(6,*) '***'
+         Write(6,*) '*** WARNING:'
+         Write(6,*) '*** Guessorb did not produce start orbitals!!!'
+         Write(6,*) '***'
+         Return
+      End If
+      If(Debug) Then
+         ij=1
+         Do iSym=1,nSym
+           Call TriPrt('FckInt','(12f12.6)',DMET_f(ij),nBas(iSym))
+           Call NrmClc(DMET_f(ij),nBas(iSym)*(nBas(iSym)+1)/2,
+     &                  'FckbyInt',
+     &                  'Fck(ij)')
+            ij=ij+nBas(iSym)*(nBas(iSym)+1)/2
+         End Do
+      End If
+*----------------------------------------------------------------------*
+* Make symmetric orthonormal orbital basis.                            *
+*----------------------------------------------------------------------*
+      inCMO_DMET=nSqrTot
+      Write(6,*) 'CMO'
+      Call mma_allocate(CMO_DMET,inCMO_DMET)
+      Call goLowdin(CMO_DMET)
+      If (Debug) Then
+         ij=1
+         Do iSym=1,nSym
+            nB=nBas(iSym)
+*           Call RecPrt('CMO_DMET','(12f12.6)',CMO_DMET(ij),nB,nB)
+            Call NrmClC(CMO_DMET(ij),nB**2,'FckbyInt_DMET',
+     &                  'CMO_DMET(ij)')
+            ij=ij+nB*nB
+         End Do
+      End If
+*----------------------------------------------------------------------*
+* Get overlap matrix                                                   *
+*----------------------------------------------------------------------*
+      inOvl_DMET=nTriTot+6
+      Call mma_allocate(Ovl_DMET,inOvl_DMET)
+      iSymlb=1
+      Call RdOne(irc,6,'Mltpl  0',1,Ovl_DMET,iSymlb)
+      If(Debug) Then
+         ipT1=1
+         Do iSym=1,nSym
+*           Call TriPrt('Ovl_DMETp','(12f12.6)',Ovl_DMET(ipT1),nBas(iSym))
+            Call NrmClc(Ovl_DMET(ipT1),nBas(iSym)*(nBas(iSym)+1)/2,
+     &                  'FckbyInt','Ovl_DMET(ipT1)')
+            ipT1=ipT1+nBas(iSym)*(nBas(iSym)+1)/2
+         End Do
+      End If
+*----------------------------------------------------------------------*
+* Transform: F = S Eps_DMET S                                               *
+*----------------------------------------------------------------------*
+      inT1=nBasMax*nBasMax
+      inT2=nBasMax*nBasMax
+      inT3=nBasMax*nBasMax
+      Call mma_allocate(T1,inT1)
+      Call mma_allocate(T2,inT2)
+      Call mma_allocate(T3,inT3)
+      ijT=1
+      ijS=1
+      ijL=1
+      Do iSym=1,nSym
+         nB=nBas(iSym)
+         If(nB.gt.0) Then
+            Call Square(DMET_f(ijT),T1,1,nB,nB)
+            Call Square(Ovl_DMET(ijT),T2,1,nB,nB)
+            Call DGEMM_('N','N',
+     &                  nB,nB,nB,
+     &                  1.0d0,T1,nB,
+     &                        T2,nB,
+     &                  0.0d0,T3,nB)
+            Call MxMt(T2,nB,1,
+     &                T3,1,nB,
+     &                DMET_f(ijT), nB,nB)
+            If(Debug) Then
+*              Call TriPrt('Fock matrix with metric','(12f12.6)',
+*    &                     DMET_f(ijT),nB)
+               Call NrmClc(DMET_f(ijT),nB*(nB+1)/2,'FckbyInt_DMET',
+     &                  'DMET_f(ijT)')
+            End If
+         End If
+         ijT=ijT+nB*(nB+1)/2
+         ijS=ijS+nB*nB
+         ijL=ijL+nB
+      End Do
+      Call mma_deallocate(T3)
+      Call mma_deallocate(T2)
+      Call mma_deallocate(T1)
+*----------------------------------------------------------------------*
+* Diagonalize the model Fock matrix                                    *
+*----------------------------------------------------------------------*
+      inEps_DMET=nBasTot
+      Call mma_allocate(Eps_DMET,inEps_DMET)
+      inT1=nBasMax*nBasMax
+      inT2=nBasMax*nBasMax
+      inT3=nBasMax*nBasMax
+      Call mma_allocate(T1,inT1)
+      Call mma_allocate(T2,inT2)
+      Call mma_allocate(T3,inT3)
+      ijT=1
+      ijS=1
+      ijL=1
+      Do iSym=1,nSym
+         nB=nBas(iSym)
+         nS=nBas(iSym)-nDel(iSym)
+         If(nB.gt.0) Then
+            Call Square(DMET_f(ijT),T1,1,nB,nB)
+            Call DGEMM_('N','N',
+     &                  nB,nS,nB,
+     &                  1.0d0,T1,nB,
+     &                        CMO_DMET(ijS),nB,
+     &             0.0d0,T2,nB)
+            Call MxMt(CMO_DMET(ijS),nB,1,
+     &                T2,1,nB,
+     &                T3, nS,nB)
+            If(Debug) Then
+*              Call TriPrt('Transformed Fock matrix','(12f12.6)',T3,nB)
+               Call NrmClc(T3,nB*(nB+1)/2,'FckbyInt_DMET',
+     &                'Transformed Fck')
+            End If
+            Call NIdiag(T3,CMO_DMET(ijS),nS,nB,0)
+            Call goPickup(T3,Eps_DMET(ijL),nS)
+            Call goSort(Eps_DMET(ijL),CMO_DMET(ijS),nS,nB)
+*
+            Do i = 1, nS
+               tmp = OrbPhase(CMO_DMET(ijS+(i-1)*nB),nB)
+            End Do
+         End If
+         ijT=ijT+nB*(nB+1)/2
+         ijS=ijS+nB*nB
+         ijL=ijL+nB
+      End Do
+      If (Debug) Then
+         ij=1
+         Do iSym=1,nSym
+            nB=nBas(iSym)
+*           Call RecPrt('CMO_DMET','(12f12.6)',CMO_DMET(ij),nB,nB)
+            Call NrmClC(CMO_DMET(ij),nB**2,'FckbyInt','CMO_DMET(ij)')
+            ij=ij+nB*nB
+         End Do
+      End If
+      Call mma_deallocate(T3)
+      Call mma_deallocate(T2)
+      Call mma_deallocate(T1)
+*----------------------------------------------------------------------*
+* Diagonalize T in virtual space.                                      *
+*----------------------------------------------------------------------*
+      If(.false.) Goto 900
+      iRc=-1
+      iSymlb=1
+      Call RdOne(irc,6,'Kinetic ',1,DMET_f,iSymlb)
+      If (iRc.ne.0) Goto 900
+      inT1=nBasMax*nBasMax
+      inT2=nBasMax*nBasMax
+      inT3=nBasMax*nBasMax
+      Call mma_allocate(T1,inT1)
+      Call mma_allocate(T2,inT2)
+      Call mma_allocate(T3,inT3)
+      ijT=1
+      ijS=1
+      ijL=1
+      Do iSym=1,nSym
+         nB=nBas(iSym)
+         nD=nDel(iSym)
+         nC=0
+         Do iBas=1,nB-nD
+            If(Eps_DMET(ijL+iBas-1).lt.-1.0d-3) nC=nC+1
+         End Do
+         nS=nB-nC-nD
+         If(nS.gt.0) Then
+*
+*           Generate standardized virtual orbitals before we proceed.
+*           The virtual orbitals generated previously are not well
+*           defined and might differ substantially with different
+*           hardware/software and compiler options. To be able to
+*           compare we will need these standardized virtual orbitals.
+*           In real production calculations this step could for all
+*           practical purposes be skipped.
+*
+            If (Verify)
+     &      Call Virt_Space(CMO_DMET(ijS),CMO_DMET(ijS+nB*nC),
+     &                      Ovl_DMET(ijT),nB,nC,nS)
+*
+            Call Square(DMET_f(ijT),T1,1,nB,nB)
+            Call DGEMM_('N','N',
+     &                  nB,nS,nB,
+     &                  1.0d0,T1,nB,
+     &                        CMO_DMET(ijS+nB*nC),nB,
+     &                  0.0d0,T2,nB)
+
+            Call MxMt(CMO_DMET(ijS+nB*nC),nB,1,
+     &                T2,1,nB,
+     &                T3, nS,nB)
+            If(Debug) Then
+               Call TriPrt('Virtual space','(12f12.6)',T3,nS)
+            End If
+            Call NIdiag(T3,CMO_DMET(ijS+nB*nC),nS,nB,0)
+            Call goPickup(T3,Eps_DMET(ijL+nC),nS)
+            Call goSort(Eps_DMET(ijL+nC),CMO_DMET(ijS+nB*nC),nS,nB)
+            If(Debug) Then
+               Call RecPrt('Eps_DMET',' ',Eps_DMET(ijL+nC),nS,1)
+               Call RecPrt('Virtual Orbitals',' ',
+     &                     CMO_DMET(ijS+nB*nC),nB,nS)
+            End If
+*
+*           Now order degenerate orbitals. This is only important for
+*           verification runs.
+*
+            Do iBas = nC+1, nB-nD-1
+               ei = Eps_DMET(ijL+iBas-1)
+               tmp1 = 0.0d0
+               Do kBas = 1, nB
+                  ik = ijS+ (iBas-1)*nB + kBas -1
+                  tmp1 = tmp1 + Abs(CMO_DMET(ik)*DBLE(kBas))
+               End Do
+               Do jBas = iBas+1, nB-nD
+                  ej = Eps_DMET(ijL+jBas-1)
+                  If (Abs(ei-ej).lt.1.0D-12) Then
+                     tmp2 = 0.0d0
+                     Do kBas = 1, nB
+                        jk = ijS+ (jBas-1)*nB + kBas -1
+                        tmp2 = tmp2 + Abs(CMO_DMET(jk)*DBLE(kBas))
+                     End Do
+                     If (tmp2.gt.tmp1) Then
+                        tmp=tmp2
+                        tmp2=tmp1
+                        tmp1=tmp
+                        Eps_DMET(ijL+iBas-1) = ej
+                        Eps_DMET(ijL+jBas-1) = ei
+                        ei = ej
+                        i1 = ijS+ (iBas-1)*nB
+                        j1 = ijS+ (jBas-1)*nB
+                        Call DSwap_(nB,CMO_DMET(i1),1,CMO_DMET(j1),1)
+                     End If
+                  End If
+
+               End Do
+            End Do
+*
+*           Introduce "standard" phase.
+*
+            Do iBas = 1, nB
+               tmp = OrbPhase(CMO_DMET(ijS+(iBas-1)*nB),nB)
+            End Do
+*
+            If(Debug) Then
+               Call RecPrt('Eps_DMET',' ',Eps_DMET(ijL+nC),nS,1)
+               Call RecPrt('Virtual Orbitals',' ',
+     &                     CMO_DMET(ijS+nB*nC),nB,nS)
+            End If
+            Do iBas=nC+1,nB-nD
+               Eps_DMET(ijL+iBas-1)=Eps_DMET(ijL+iBas-1)+3.0d0
+            End Do
+            Do iBas=nB-nD+1,nB
+               Eps_DMET(ijL+iBas-1)=999.0d0
+            End Do
+            Do iBas=1,nB-nD
+               If(Eps_DMET(ijL+iBas-1).gt.TThr)
+     &           nDel(iSym) = nDel(iSym)+1
+            End Do
+         End If
+         ijT=ijT+nB*(nB+1)/2
+         ijS=ijS+nB*nB
+         ijL=ijL+nB
+      End Do
+      Call mma_deallocate(T3)
+      Call mma_deallocate(T2)
+      Call mma_deallocate(T1)
+*----------------------------------------------------------------------*
+* Present data.                                                        *
+*----------------------------------------------------------------------*
+900   Continue
+      inT1=nBasTot
+      inT2=nBasTot
+      Call mma_allocate(T1,inT1)
+      Call mma_allocate(T2,inT2)
+      Do iBas=1,nBasTot
+         T1(iBas)=0.0d0
+      End Do
+      Call GoPop(Eps_DMET,T1,T2,nBasTot,PrintEor,PrThr,GapThr)
+      iBas=0
+      dActEl=0.0d0
+      Do iSym=1,nSym
+         IndType(1,iSym)=0
+         IndType(2,iSym)=0
+         IndType(3,iSym)=0
+         IndType(4,iSym)=0
+         IndType(5,iSym)=0
+         IndType(6,iSym)=nBas(iSym)-nDel(iSym)
+         IndType(7,iSym)=nDel(iSym)
+         Do kBas=1,nBas(iSym)-nDel(iSym)
+            iBas=iBas+1
+            If(T1(iBas).gt.1.99d0) Then
+               IndType(2,iSym)=IndType(2,iSym)+1
+               IndType(6,iSym)=IndType(6,iSym)-1
+            Else If(T1(iBas).gt.0.01d0) Then
+               IndType(4,iSym)=IndType(4,iSym)+1
+               IndType(6,iSym)=IndType(6,iSym)-1
+               dActEl=dActEl+T1(iBas)
+            End If
+         End Do
+      End Do
+      nActEl=Int(dActEl+0.5d0)
+      If(PrintMOs) then
+         Call PriMO('Start orbitals (virtuals shifted)',
+     &              .true.,.true.,0.0d0,PrThr,
+     &              nSym,nBas,nBas,Label,Eps_DMET,T1,
+     &              CMO_DMET,iPrFmt)
+         Call xflush(6)
+      End If
+      If(PrintPop) Then
+         Call Charge(nSym,nBas,Label,CMO_DMET,T1,
+     &               Ovl_DMET,2,.true.,.true.)
+      End If
+      Call put_darray('Guessorb',CMO_DMET,nSqrTot)
+      Call put_darray('Guessorb energies',Eps_DMET,nBasTot)
+      Do iSym=1,nSym
+         nOrb(iSym)=nBas(iSym)-nDel(iSym)
+      End Do
+      Call Put_iArray('nOrb',nOrb,nSym)
+      Call Put_iArray('nDel_go',nDel,nSym)
+      Call Put_iArray('nDel',nDel,nSym)
+      Do iSym=1,nSym
+         nTmp(iSym)=IndType(2,iSym)
+         nIsh(iSym)=nTmp(iSym)
+      End Do
+      Call Put_iArray('nIsh',nTmp,nSym)
+      Do iSym=1,nSym
+         nTmp(iSym)=IndType(4,iSym)
+         nAsh(iSym)=nTmp(iSym)
+      End Do
+      Call Put_iArray('nAsh',nTmp,nSym)
+      Call Put_iScalar('nActel',nActEl)
+      kSpin=1 ! always same alpha and beta orbs
+      Call Put_iScalar('Multiplicity',kSpin)
+      Enr_go=0.0d0
+      ipEE0=1
+      ipOk0=1
+      Do iSym=1,nSym
+         Do i=0,nIsh(iSym)+nAsh(iSym)-1
+            ipEE=ipEE0+i
+            ipOk=ipOk0+i
+            Enr_go=Enr_go+T1(ipOk)*Eps_DMET(ipEE)
+         End Do
+         ipEE0=ipEE0+nBas(iSym)
+         ipOk0=ipOk0+nBas(iSym)
+      End Do
+      Call Put_dScalar('Last energy',Enr_go)
+#ifdef _HDF5_
+      call mh5_put_dset(wfn_energy,Enr_go)
+#endif
+      Lu=20
+      Title='Guess orbitals'
+      Call WrVec('GSSORB',Lu,'COEI',nSym,nBas,nBas,CMO_DMET,
+     &           T1,Eps_DMET,IndType,Title)
+#ifdef _HDF5_
+      call mh5_put_dset(wfn_mocoef,CMO_DMET)
+      call mh5_put_dset(wfn_occnum,T1)
+      call mh5_put_dset(wfn_orbene,Eps_DMET)
+#endif
+*
+* Compute density matrix (re-use memory allocated in Ovl_DMET)
+      iOff=1
+      jOff=1
+      kOff=1
+      Do iSym=1,nSym
+         ipOkk=iOff
+         nOkk=nIsh(iSym)+nAsh(iSym)
+         ipCOk=jOff
+         Do k=0,nOkk-1
+            xocc=sqrt(T1(k+ipOkk))
+            call dscal_(nBas(iSym),xocc,CMO_DMET(ipCOk),1)
+            ipCOk=ipCOk+nBas(iSym)
+         End Do
+         Call DGEMM_Tri('N','T',nBas(iSym),nBas(iSym),nOkk,
+     &                    1.0d0,CMO_DMET(jOff),Max(1,nBas(iSym)),
+     &                          CMO_DMET(jOff),Max(1,nBas(iSym)),
+     &                    0.0d0,Ovl_DMET(kOff),Max(1,nBas(iSym)))
+         iOff=iOff+nBas(iSym)
+         jOff=jOff+nBas(iSym)**2
+         kOff=kOff+nBas(iSym)*(nBas(iSym)+1)/2
+      End Do
+      Call Fold_tMat(nSym,nBas,Ovl_DMET,Ovl_DMET)
+      Call Put_D1ao(Ovl_DMET,nTriTot)
+*
+      Call mma_deallocate(T2)
+      Call mma_deallocate(T1)
+*----------------------------------------------------------------------*
+* Done, deallocate the rest.                                           *
+*----------------------------------------------------------------------*
+      Call mma_deallocate(Eps_DMET)
+      Call mma_deallocate(Ovl_DMET)
+      Call mma_deallocate(CMO_DMET)
+      Call mma_deallocate(DMET_f)
+      If(Trace) Then
+         Write(6,*) '<<< Exiting fckbyint_DMET'
+         Call xflush(6)
+      End If
+      Return
+      End
diff --git a/src/dmet_util/mk_dmet_shell.f b/src/dmet_util/mk_dmet_shell.f
new file mode 100644
index 0000000..f7b7304
--- /dev/null
+++ b/src/dmet_util/mk_dmet_shell.f
@@ -0,0 +1,122 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 2008, Roland Lindh                                     *
+*               2017, Varinia Bernales, Roland Lindh                   *
+************************************************************************
+      Subroutine Mk_DMET_Shell(Info,nInfo,nBfn)
+      Implicit Real*8 (A-H,O-Z)
+      External Integral_RICD, Integral_RI_2
+#include "itmax.fh"
+#include "info.fh"
+#include "SysDef.fh"
+#include "real.fh"
+#include "WrkSpc.fh"
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iShll = Mx_Shll - 1
+      If (nCnttp.eq.0) Then
+         mdc = 0
+      Else
+         mdc = mdciCnttp(nCnttp) + nCntr(nCnttp)
+      End If
+      nCnttp = nCnttp + 1
+      If (nCnttp.gt.Mxdbsc) Then
+         Call WarningMessage(2,'Mk_DMET_Shell: Increase Mxdbsc')
+         Call Abend()
+      End If
+      ipVal(nCnttp) = iShll + 1
+      ipPrj(nCnttp) = -1
+      ipSRO(nCnttp) = -1
+      ipSOC(nCnttp) = -1
+*
+      Bsl(nCnttp)='.....DMET'
+      Charge(nCnttp)=Zero
+      iAtmNr(nCnttp)=1
+      AuxCnttp(nCnttp)=.False.
+      aCD_Thr(nCnttp)=One
+      NoPairL(nCnttp)=.False.
+      CrRep(nCnttp)=Zero
+      pChrg(nCnttp)=.False.
+      Fixed(nCnttp)=.False.
+      nOpt(nCnttp) = 0
+      nPrj_Shells(nCnttp) = 0
+      nSRO_Shells(nCnttp) = 0
+      nSOC_Shells(nCnttp) = 0
+*
+      nPrim=1
+      nCntrc=nBfn
+      nTot_Shells(nCnttp) = 1
+      nVal_Shells(nCnttp) = 1
+*
+      iShll = iShll + 1
+      AuxShell(iShll) = .False.
+      iStrt = ipExp(iShll)
+      nExp(iShll) = nPrim
+      nBasis(iShll) = nCntrc
+      nBasis_Cntrct(iShll) = nCntrc
+      ipBk(iShll) = ip_Dummy
+      ip_Occ(iShll) = ip_Dummy
+      ipAkl(iShll) = ip_Dummy
+      iEnd = iStrt + nPrim - 1
+*     Exponent
+      Work(iStrt)=Zero
+*     Coefficients
+      iStrt = iEnd + 1
+      ipCff(iShll) = iStrt
+      ipCff_Cntrct(iShll) = iStrt
+      ipCff_Prim(iShll) = iStrt
+      iEnd = iStrt + nPrim*nCntrc -1
+      Call DCopy_(nPrim,One,0,Work(iStrt),1)
+      call dcopy_(nPrim*nCntrc,Work(iStrt),1,Work(iEnd+1),1)
+      iEnd = iEnd + nPrim*nCntrc
+      If (iShll.lt.MxShll) ipExp(iShll+1) = iEnd + 1
+*
+      Transf(iShll)=.False.
+      Prjct(iShll)=.False.
+      iAngMx=Max(iAngMx,0)
+*
+*-----The coordinates
+*
+      ipCntr(nCnttp) = ipExp(iShll+1)
+      nCnt = 1
+      If (mdc+nCnt.gt.Mxdc) Then
+         Call WarningMessage(2,'Mk_DMET_Shell: Increase Mxdb')
+         Write (6,*) mdc,nCnt,Mxdc
+         Call Abend()
+      End If
+      mdciCnttp(nCnttp)=mdc
+      LblCnt(mdc+nCnt) = 'Origin'
+      If (mdc+nCnt.gt.1) Call ChkLbl(LblCnt(mdc+nCnt),LblCnt,mdc+nCnt-1)
+      iOff=ipCntr(nCnttp)+(nCnt-1)*3
+      Work(iOff  )=Zero
+      Work(iOff+1)=Zero
+      Work(iOff+2)=Zero
+      nCntr(nCnttp) = nCnt
+      mdc = mdc + nCnt
+      If (iShll.lt.MxShll) ipExp(iShll+1) = ipExp(iShll+1) + nCnt*3
+*
+*     Compute the number of elements stored in the dynamic memory so
+*     far.
+*
+      nInfo = ipExp(iShll+1) - Info
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Mx_Shll=iShll+1
+      Mx_mdc=mdc
+*
+      iCnttp_Dummy=nCnttp
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Return
+      End
diff --git a/src/dmet_util/oneel_dmet.f b/src/dmet_util/oneel_dmet.f
new file mode 100644
index 0000000..e22864d
--- /dev/null
+++ b/src/dmet_util/oneel_dmet.f
@@ -0,0 +1,160 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1990,1991,1993,1999, Roland Lindh                      *
+*               1990, IBM                                              *
+************************************************************************
+      SubRoutine OneEl_DMET(Kernel,KrnlMm,Label,ip,lOper,nComp,CCoor,
+     &                      nOrdOp,rNuc,rHrmt,iChO,DMET_h,nBfn)
+      use PrpPnt
+      Implicit Real*8 (A-H,O-Z)
+      External Kernel, KrnlMm
+#include "itmax.fh"
+#include "info.fh"
+#include "stdalloc.fh"
+#include "print.fh"
+#include "real.fh"
+      Real*8 DMET_h(nBfn,nBfn)
+      Real*8, Dimension(:), Allocatable :: Array
+      Character Label*8
+      Character L_Temp*8
+      Real*8 CCoor(3,nComp), rNuc(nComp)
+      Integer ip(nComp), lOper(nComp), iChO(nComp), iStabO(0:7)
+      Integer iTwoj(0:7)
+      Data iTwoj/1,2,4,8,16,32,64,128/
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Dum=rHrmt
+      iDum=nOrdOp
+      iDum=iCho(1)
+      iRout = 112
+      iPrint = nPrint(iRout)
+      Call qEnter('OneEl')
+      If (iPrint.ge.19) Then
+         Write (6,*) ' In OneEl: Label', Label
+         Write (6,*) ' In OneEl: nComp'
+         Write (6,'(1X,8I5)') nComp
+         Write (6,*) ' In OneEl: lOper'
+         Write (6,'(1X,8I5)') lOper
+         Write (6,*) ' In OneEl: n2Tri'
+         Do iComp = 1, nComp
+            ip(iComp) = n2Tri(lOper(iComp))
+         End Do
+         Write (6,'(1X,8I5)') (ip(iComp),iComp=1,nComp)
+         Call RecPrt(' CCoor',' ',CCoor,3,nComp)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Compute the number of blocks from each component of the operator
+*     and the irreps it will span.
+*
+      nIC = 0
+      llOper = 0
+      Do iComp = 1, nComp
+         llOper = iOr(llOper,lOper(iComp))
+         Do iIrrep = 0, nIrrep-1
+            If (iAnd(lOper(iComp),iTwoj(iIrrep)).ne.0) nIC = nIC + 1
+         End Do
+      End Do
+      If (iPrint.ge.20) Write (6,*) ' nIC =',nIC
+      If (nIC.eq.0) Go To 999
+      Call SOS(iStabO,nStabO,llOper)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Allocate memory for symmetry adapted one electron integrals.
+*     Will just store the unique elements, i.e. low triangular blocks
+*     and lower triangular elements in the diagonal blocks.
+*
+      Call ICopy(nComp,-1,0,ip,1)
+      LenTot=0
+      Do iComp = 1, nComp
+         LenInt=n2Tri(lOper(iComp))
+         LenTot=LenTot+LenInt+4
+      End Do
+      Call mma_allocate(Array,LenTot,label='Array')
+      ip(1)=1
+      call dcopy_(LenTot,Zero,0,Array(ip(1)),1)
+      iadr=ip(1)
+      do iComp = 1, nComp
+         LenInt=n2Tri(lOper(iComp))
+         ip(icomp)=iadr
+         iadr=iadr+LenInt+4
+*        Copy center of operator to work area.
+         call dcopy_(3,Ccoor(1,iComp),1,Array(ip(iComp)+LenInt),1)
+*        Copy nuclear contribution to work area.
+         Array(ip(iComp)+LenInt+3) = rNuc(iComp)
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Compute all SO integrals for all components of the operator.
+*
+      Do iBfn = 1, nBfn
+         Do jBfn = 1, iBfn
+            ijBfn = iBfn*(iBfn-1)/2 + jBfn - 1 + ip(1)
+            Array(ijBfn)=DMET_h(iBfn,jBfn)
+         End Do
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*                    P O S T P R O C E S S I N G                       *
+*                                                                      *
+************************************************************************
+*                                                                      *
+      write(6,*) 'ONEINT'
+      Call PrMtrx(Label,lOper,nComp,ip,Array)
+      If (iPrint.ge.10) Call PrMtrx(Label,lOper,nComp,ip,Array)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Make a square sum on all the integrals for verification
+      Call VrfMtrx(Label,lOper,nComp,ip,Array)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Compute properties or write integrals to disc.
+*
+      Do iComp = 1, nComp
+         iSmLbl = lOper(iComp)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---------- Write integrals to disc
+*
+            iOpt = 0
+            iRC = -1
+            L_Temp='OneHam  '
+            iComp_=iComp
+            Call WrOne(iRC,iOpt,L_Temp,iComp_,Array(ip(iComp)),iSmLbl)
+
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &               ' *** Error in subroutine ONEEL ***,'//
+     &               '     Abend in subroutine WrOne')
+               Call Abend()
+            End If
+      End Do  ! iComp
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Deallocate memory for integral
+*
+      Call mma_deallocate(Array)
+*                                                                      *
+************************************************************************
+*                                                                      *
+ 999  Continue
+      Call qExit('OneEl')
+      Return
+      End
diff --git a/src/dmet_util/rdctl_dmet.f b/src/dmet_util/rdctl_dmet.f
new file mode 100644
index 0000000..228fcba
--- /dev/null
+++ b/src/dmet_util/rdctl_dmet.f
@@ -0,0 +1,4566 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 2017, Varinia Bernales, Roland Lindh                   *
+************************************************************************
+      Subroutine RdCtl_DMET(Info,nInfo,LuRd,lOPTO,Do_OneEl,DInf,nDInf,
+     &                      nBfn)
+      use Her_RW
+      use Period
+      use MpmC
+      use EFP_Module
+      Implicit Real*8 (a-h,o-z)
+      External iMostAbundantIsotope, NucExp
+#include "para_info.fh"
+*
+#include "itmax.fh"
+#include "info.fh"
+#include "constants.fh"
+#include "SysDef.fh"
+#include "notab.fh"
+#include "WrkSpc.fh"
+#include "stdalloc.fh"
+#include "rctfld.fh"
+#include "rmat.fh"
+#include "real.fh"
+#include "print.fh"
+#include "RelLight.fh"
+#include "gateway.fh"
+#include "hyper.fh"
+#ifdef _FDE_
+      ! Thomas Dresselhaus
+#include "embpotdata.fh"
+#endif
+#include "relae.fh"
+#include "periodic_table.fh"
+      Common /AMFn/ iAMFn
+      Common /delete/ kDel(0:MxAng,MxDc)
+*
+      Real*8 DInf(nDInf), Lambda
+      Character Key*180, KWord*180, Oper(3)*3, BSLbl*80, Fname*256,
+     &          DefNm*13, Ref(2)*80, ChSkip*80, AngTyp(0:MxAng)*1,
+     &          dbas*(LENIN),filename*180, KeepBasis*256, KeepGroup*180,
+     &          Previous_Command*12, BSLbl_Dummy*80, CtrLDK(10)*(LENIN),
+     &          Directory*256, BasLib*256,ExtBasDir*256
+      Character*180 Line
+      common/cgetlc/ Line
+      Character*180 Get_Ln
+      External Get_Ln
+      Logical lTtl, lSkip, lMltpl, DoRys, RF_read, Convert, IfTest,
+     &        Exist,CutInt_UsrDef, ThrInt_UsrDef, MolWgh_UsrDef,
+     &        CholeskyWasSet, GWInput, NoAMFI, lOPTO, Do_OneEl
+      Logical do1CCD
+      Logical APThr_UsrDef, Write_BasLib
+      Integer Cho_MolWgh, StayAlone, nDel(MxAng),
+     &        BasisTypes(4), BasisTypes_Save(4),
+     &        iGeoInfo(2), iOpt_XYZ, RC
+      Parameter (Cho_CutInt = 1.0D-40, Cho_ThrInt = 1.0D-40,
+     &           Cho_MolWgh = 2)
+*
+      Real*8 NucExp, WellCff(3),WellExp(3), WellRad(3), CholeskyThr(1)
+      Real*8 spanCD(1)
+      Real*8, Allocatable :: RTmp(:,:), EFt(:,:), OAMt(:), OMQt(:),
+     &                       DMSt(:,:), OrigTrans(:,:), OrigRot(:,:,:)
+      Integer, Allocatable :: ITmp(:)
+      Character*180 STDINP(mxAtom*2)
+      Character Basis_lib*256, INT2CHAR*4, CHAR4*4
+      Character*256 Project, GeoDir, temp1, temp2
+*
+      Integer StrnLn
+      External StrnLn
+
+      Logical SymmSet
+      Logical CoordSet,RPSet
+      Logical BasisSet
+      Logical GroupSet
+      Logical DoneCoord
+      Logical NoZMAT
+      Logical ForceZMAT
+      Logical XYZdirect
+      Logical NoDKroll
+      Logical DoTinker
+      Logical DoGromacs
+      Logical OriginSet
+      Logical FragSet
+      Logical HyperParSet
+      Logical WriteZMat, geoInput, oldZmat,zConstraints
+      Logical EFgiven
+      Logical Invert
+      Real*8 HypParam(3)
+      Integer iSeed
+      Save iSeed
+*
+      Logical DoEMPC
+      Common /EmbPCharg/ DoEMPC
+*
+#ifdef _GROMACS_
+      Integer, Dimension(:), Allocatable :: CastMM
+      Integer, Dimension(:,:), Allocatable :: DefLA
+      Real*8, Dimension(:), Allocatable :: FactLA
+#endif
+      Character*256 Message
+      parameter (MAX_XBAS=20)
+      Character*12 xb_label(MAX_XBAS)
+      Character*128 xb_bas(MAX_XBAS)
+*
+      Data WellCff/.35D0,0.25D0,5.2D0/
+      Data WellExp/4.0D0,3.0D0,2.0D0/
+      Data WellRad/-1.22D0,-3.20D0,-6.20D0/
+      Data StayAlone/0/
+*
+#include "angstr.fh"
+      Data DefNm/'basis_library'/
+      Data IfTest/.False./
+      Data iSeed/24619/
+#include "angtp.fh"
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout=3
+      iPrint = nPrint(iRout)
+      Call qEnter('RdCtl')
+#ifdef _DEBUG_
+      IfTest=.True.
+#endif
+*
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Do i=0,MxAng
+         AngTyp(i)=Angtp(i)
+         Call UpCase(AngTyp(i))
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call WhichMolcas(Basis_lib)
+      If (Basis_lib(1:1).ne.' ') Then
+         StayAlone=1
+         ib=index(Basis_lib,' ')-1
+         if(ib.lt.1)
+     &   Call SysAbendMsg('rdCtl','Too long PATH to MOLCAS',' ')
+         BasLib=Basis_lib(1:ib)//'/basis_library'
+      Else
+         BasLib=DefNm
+      End If
+      Write_BasLib=.False.
+*                                                                      *
+************************************************************************
+*                                                                      *
+      CutInt_UsrDef=.False.
+      ThrInt_UsrDef=.False.
+      MolWgh_UsrDef=.False.
+      APThr_UsrDef=.False.
+      NoAMFI=.False.
+      Fake_ERIs=.False.
+      Cholesky=.False.
+*
+      iChk_RI=0
+      iChk_CH=0
+      iChk_DC=0
+      iOpt_XYZ=-1
+*
+      isXfield=0
+      CholeskyThr(1)=-9.99d9
+*                                                                      *
+************************************************************************
+*                                                                      *
+      LuWr=6
+      LuFS=-1
+      LuRdSave=-1
+*
+      nTemp=0
+      ipRTmp=ip_Dummy
+      ipITmp=ip_iDummy
+      lMltpl=.False.
+*
+      nPAMFI=0
+*
+      CholeskyWasSet=.False.
+      do1CCD=.false.
+      spanCD(1)=-9.9d9
+      lTtl = .False.
+      RF_read=.False.
+      lSkip=.False.
+      Force_Out_of_Core=.False.
+      NoDKroll=.false.
+      SymmSet=.false.
+      BasisSet=.false.
+      GroupSet=.false.
+      RPSet=.false.
+      CoordSet=.false.
+      DoneCoord=.false.
+      KeepGroup='FULL'
+      NoZMAT=.false.
+      ForceZMAT=.false.
+      XYZDirect=.false.
+      DoTinker = .False.
+      DoGromacs = .False.
+      origin_input = .False.
+      geoInput = .False.
+      ZConstraints = .False.
+      OldZmat = .False.
+      WriteZMat = .False.
+      nFragment = 0
+      iFrag = 0
+      FragSet = .False.
+      OriginSet = .False.
+      HyperParSet = .False.
+      stepFac1 = 60.0d0
+      iOptimType = 1
+      gradLim = 0.0d0
+      Do_OneEl=.True.
+#ifdef _FDE_
+      ! Embedding
+      embPot=.false.
+      embPotInBasis=.false.
+      embPotPath='EMBPOT'
+      outGridPathGiven=.false.
+      embWriteDens=.false.
+      embWriteEsp=.false.
+      embWriteGrad=.false.
+      embWriteHess=.false.
+      Call Put_iScalar('embpot',0)
+#endif
+      DoEmPC=.False.
+      EFgiven=.False.
+      Invert=.False.
+      Call Put_iScalar('agrad',0)
+*
+      ScaleFactor=1.0d0
+      lSTDINP=0
+      iCoord=0
+      nCoord=0
+      iBSSE=-1
+      SymThr=0.01D0
+      isHold=-1
+      nTtl=0
+*
+      imix=0
+      ifnr=-1
+      itype=0
+      ExtBasDir=' '
+      isxbas=0
+*
+*     Selective initialization
+*
+      If (Run_Mode.eq.S_Mode) Then
+         iShll = Mx_Shll
+         mdc = Mx_mdc
+      Else
+         iShll = 0
+         Mx_Shll = iShll + 1
+         mdc = 0
+*
+         ChSkip=' '
+         Do i = 1,3
+            Oper(i)=' '
+         End Do
+         nOper=0
+      ipExp(1) = Info
+*     CLight = 137.036d0
+      CLight = CONST_C_IN_AU_
+      End If
+*
+      nDKfull = 0
+      iAMFn = 0   ! usual AMFI
+      BasisTypes(1)=0
+      BasisTypes(2)=0
+      BasisTypes(3)=0
+      BasisTypes(4)=0
+      KeepBasis=' '
+cperiod
+      lthCell = 0
+      Cell_l = .FALSE.
+      Call izero(ispread,3)
+      Call fzero(VCell,9)
+*     Set local DF variables (dummy)
+      Call LDF_SetInc()
+      Call Put_darray('Weights',1.0D0,1)
+      Go To 997   ! Dirty code!!!!
+      Rewind(LuRd)
+*     Count the number of calls to coord to set the number of fragments
+*     for a geo/hyper-calculation
+ 400  Key= Get_Ln(LuRd)
+      KWord = Key
+      Call UpCase(KWord)
+      If(KWord(1:4) .eq. 'COOR') nFragment=nFragment+1
+      If((KWord(1:4) .eq. 'HYPE') .or.
+     &   (KWord(1:4) .eq. 'GEO ')) Then
+         call getenvf("Project",Project)
+         call getenvf("GeoDir",GeoDir)
+         temp1 = Project(1:index(Project,' ')-1)//
+     &           '.Gateway.Input'
+         temp2 = GeoDir(1:index(GeoDir,' ')-1)//'/'//
+     &           Project(1:index(Project,' ')-1)//'.gwcopy.input'
+         Call fCopy(temp1,temp2,ierr)
+         if(ierr.ne.0) then
+           write(6,*) '*** Detect Hyper input, but no GEO loop'
+           call Quit_OnUserError()
+         EndIf
+      End If
+      If (KWord(1:4).eq.'END ') Go To 401
+      GoTo 400
+ 401  Call Put_iScalar('nCoordFiles',nFragment)
+      Rewind(LuRd)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Run_Mode.eq.G_Mode) Then
+         Call RdNLst(LuRd,'GATEWAY')
+         Previous_Command='&Gateway'
+      Else
+         Call RdNLst(LuRd,'SEWARD')
+         Previous_Command='&Seward'
+      End If
+*
+*     Default setting of GWInput
+*
+      GWInput=Run_Mode.eq.G_Mode
+*
+*     GWInput is a logical flag which tells if a keyword is Gateway or
+*     Seward specific. This is done down below for each keyword in the
+*     case that the keyword is not Seward or Gateway specific enter the
+*     line,
+*
+*     GWInput = Run_Mode.eq.G_Mode
+*
+*     in the section of the particular keyword
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+*     KeyWord directed input
+*
+ 998  lTtl = .False.
+ 9988 Continue
+      Key = Get_Ln(LuRd)
+*
+ 9989 If (Run_Mode.eq.G_Mode.and..Not.GWInput) Then
+         Call WarningMessage(2,'Gateway input error!')
+         Write (LuWr,*) 'The keyword : "',Previous_Command,
+     &                  '" is not allowed in the Gateway input!'
+         Write (LuWr,*) 'This keyword most likely belongs in the '
+     &                //'Seward input section!.'
+         Write (LuWr,*)
+         Call Quit_OnUserError()
+      Else If (Run_Mode.eq.S_Mode.and.GWInput) Then
+         Call WarningMessage(2,'Seward input error!')
+         Write (LuWr,*) 'The keyword : "',Previous_Command,
+     &                  '" is not allowed'
+     &               //' in the Seward input when the Gateway is used!'
+         Write (LuWr,*) ' Try putting the keyword in the Gateway '
+     &                //'input section!'
+         Write (LuWr,*)
+         Call Quit_OnUserError()
+      End If
+      GWInput=.False.
+*
+      If (IfTest) Write (LuWr,*) ' RdCtl: Processing:',Key
+      KWord = Key
+      Call UpCase(KWord)
+      Previous_Command=KWord(1:4)
+      If (KWord(1:1).eq.'*')    Go To 998
+      If (KWord.eq.BLine)       Go To 998
+*
+*     KEYWORDs in ALPHABETIC ORDER!
+*
+      If (KWord(1:4).eq.'1C-C') Go To 9022
+      If (KWord(1:4).eq.'1CCD') Go To 9022
+      If (KWord(1:4).eq.'ACCD') Go To 8005
+      If (KWord(1:4).eq.'ACD ') Go To 8004
+      If (KWord(1:4).eq.'ALIG') Go To 8013
+      If (KWord(1:4).eq.'AMFI') Go To 9761
+      If (KWord(1:4).eq.'AMF1') Go To 8761
+      If (KWord(1:4).eq.'AMF2') Go To 8762
+      If (KWord(1:4).eq.'AMF3') Go To 8763
+      If (KWord(1:4).eq.'AMPR') Go To 9951
+      If (KWord(1:4).eq.'ANGM') Go To 995
+      If (KWord(1:4).eq.'APTH') Go To 38
+      If (KWord(1:4).eq.'AUXS') Go To 912
+      If (KWord(1:4).eq.'BASD') Go To 7700
+      If (KWord(1:4).eq.'BASI') Go To 920
+      If (KWord(1:4).eq.'BASL') Go To 8029
+      If (KWord(1:4).eq.'BSSE') Go To 6020
+      If (KWord(1:4).eq.'BSSH') Go To 9121
+      If (KWord(1:4).eq.'BSSM') Go To 9760
+      If (KWord(1:4).eq.'CDTH') Go To 8001
+      If (KWord(1:4).eq.'CELL') Go To 887
+      If (KWord(1:4).eq.'CENT') Go To 973
+      If (KWord(1:4).eq.'CHEC') Go To 39
+      If (KWord(1:4).eq.'CLDF') Go To 42
+      If (KWord(1:4).eq.'CHOL') Go To 9091
+      If (KWord(1:4).eq.'CHOI') Go To 9092
+      If (KWord(1:4).eq.'CLIG') Go To 9000
+      If (KWord(1:4).eq.'CONS') Go To 8010
+      If (KWord(1:4).eq.'COOR') Go To 6000
+      If (KWord(1:4).eq.'CUTO') Go To 942
+      If (KWord(1:4).eq.'DCRN') Go To 958
+      If (KWord(1:4).eq.'DIAG') Go To 9087
+      If (KWord(1:4).eq.'DIRE') Go To 9770
+      If (KWord(1:4).eq.'DIST') Go To 954
+      If (KWord(1:4).eq.'DK1H') Go To 9001
+      If (KWord(1:4).eq.'DK2H') Go To 9002
+      If (KWord(1:4).eq.'DK3F') Go To 9004
+      If (KWord(1:4).eq.'DK3H') Go To 9003
+      If (KWord(1:4).eq.'DOAN') Go To 8019
+      If (KWord(1:4).eq.'DOFM') Go To 8006
+      If (KWord(1:4).eq.'DOUG') Go To 976
+      If (KWord(1:4).eq.'DOWN') Go To 1002
+      If (KWord(1:4).eq.'DSHD') Go To 996
+      If (KWord(1:4).eq.'ECPS') Go To 912
+      If (KWord(1:4).eq.'EFLD') Go To 993
+      If (KWord(1:4).eq.'EFP ') Go To 9088
+#ifdef _FDE_
+      If (KWord(1:4).eq.'EMBE') Go To 666
+#endif
+      If (KWord(1:4).eq.'EMFR') Go To 8035
+      If (KWord(1:4).eq.'EMPC') Go To 974
+      If (KWord(1:4).eq.'EPOT') Go To 9932
+      If (KWord(1:4).eq.'EXPE') Go To 9771
+      If (KWord(1:4).eq.'EXTR') Go To 9960
+      If (KWord(1:4).eq.'FAKE') Go To 9759
+      If (KWord(1:4).eq.'FAT-') Go To 8004
+      If (KWord(1:4).eq.'FCD ') Go To 9091
+      If (KWord(1:4).eq.'FILE') Go To 904
+      If (KWord(1:4).eq.'FINI') Go To 9762
+      If (KWord(1:4).eq.'FLDG') Go To 994
+      If (KWord(1:4).eq.'FNMC') Go To 9086
+      If (KWord(1:4).eq.'FOOC') Go To 8000
+      If (KWord(1:4).eq.'FPCO') Go To 9764
+      If (KWord(1:4).eq.'FPPR') Go To 9765
+      If (KWord(1:4).eq.'FRGM') Go To 8025
+      If (KWord(1:4).eq.'GEO ') Go To 8024
+      If (KWord(1:4).eq.'GEOE') Go To 8020
+      If (KWord(1:4).eq.'GIAO') Go To 9020
+      If (KWord(1:4).eq.'GRID') Go To 9773
+      If (KWord(1:4).eq.'GROM') Go To 8034
+      If (KWord(1:4).eq.'GROU') Go To 6010
+      If (KWord(1:4).eq.'HIGH') Go To 9096
+      If (KWord(1:4).eq.'HYPE') Go To 8016
+      If (KWord(1:4).eq.'JMAX') Go To 971
+      If (KWord(1:4).eq.'KHAC') Go To 8003
+      If (KWord(1:4).eq.'LDF ') Go To 35
+      If (KWord(1:4).eq.'LDF1') Go To 35
+      If (KWord(1:4).eq.'LDF2') Go To 36
+      If (KWord(1:4).eq.'RLOC') Go To 658
+      If (KWord(1:4).eq.'LINK') Go To 8036
+      If (KWord(1:4).eq.'LOCA') Go To 35
+      If (KWord(1:4).eq.'LOW ') Go To 9094
+      If (KWord(1:4).eq.'MEDI') Go To 9095
+      If (KWord(1:4).eq.'MGAU') Go To 8009
+      If (KWord(1:4).eq.'MOLC') Go To 957
+      If (KWord(1:4).eq.'MOLE') Go To 960
+      If (KWord(1:4).eq.'MOLP') Go To 959
+      If (KWord(1:4).eq.'MOVE') Go To 6040
+      If (KWord(1:4).eq.'MULT') Go To 972
+      If (KWord(1:4).eq.'NACC') Go To 8030
+      If (KWord(1:4).eq.'NEMO') Go To 800
+      If (KWord(1:4).eq.'NGEX') Go To 501
+      If (KWord(1:4).eq.'NOAL') Go To 7013
+      If (KWord(1:4).eq.'NOAM') Go To 8007
+      If (KWord(1:4).eq.'NOCD') Go To 9084
+      If (KWord(1:4).eq.'NOCH') Go To 9089
+      If (KWord(1:4).eq.'NODE') Go To 7070
+      If (KWord(1:4).eq.'NODK') Go To 989
+      If (KWord(1:4).eq.'NOGU') Go To 9100
+      If (KWord(1:4).eq.'NOMO') Go To 6050
+      If (KWord(1:4).eq.'NOON') Go To 8023
+      If (KWord(1:4).eq.'NOPA') Go To 9910
+      If (KWord(1:4).eq.'NOTA') Go To 980
+      If (KWord(1:4).eq.'NOUN') Go To 46
+      If (KWord(1:4).eq.'NUME') Go To 8031
+      If (KWord(1:4).eq.'OLDD') Go To 8121
+      If (KWord(1:4).eq.'OLDZ') Go To 8021
+      If (KWord(1:4).eq.'OMQI') Go To 999
+      If (KWord(1:4).eq.'ONEO') Go To 990
+      If (KWord(1:4).eq.'OPTH') Go To 8022
+      If (KWord(1:4).eq.'OPTO') Go To 940
+      If (KWord(1:4).eq.'ORBC') Go To 906
+      If (KWord(1:4).eq.'ORIG') Go To 8015
+      If (KWord(1:4).eq.'OVER') Go To 41
+      If (KWord(1:4).eq.'PAMF') Go To 8060
+      If (KWord(1:4).eq.'PART') Go To 9763
+      If (KWord(1:4).eq.'PETI') Go To 961
+      If (KWord(1:4).eq.'PKTH') Go To 9940
+      If (KWord(1:4).eq.'PSOI') Go To 9023
+      If (KWord(1:4).eq.'PRIN') Go To 930
+      If (KWord(1:1).eq.'R' .and.
+     &    (KWord(2:2).ge.'0' .and.
+     &     KWord(2:2).le.'9') .and.
+     &     (KWord(3:3).ge.'0' .and.
+     &      KWord(3:3).le.'9') .and.
+     &      (KWord(4:4).eq.'O' .or.
+     &       KWord(4:4).eq.'E' .or.
+     &       KWord(4:4).eq.'S' .or.
+     &       KWord(4:4).eq.'M' .or.
+     &       KWord(4:4).eq.'C') ) Go To 657
+      If (KWord(1:4).eq.'RA0F') Go To 9012
+      If (KWord(1:4).eq.'RA0H') Go To 9011
+      If (KWord(1:4).eq.'RADI') Go To 909
+      If (KWord(1:4).eq.'RAIH') Go To 9013
+      If (KWord(1:4).eq.'RBSS') Go To 9015
+      If (KWord(1:4).eq.'RELI') Go To 962
+      If (KWord(1:4).eq.'RESC') Go To 978
+      If (KWord(1:4).eq.'RF-I') Go To 9970
+      If (KWord(1:4).eq.'RLDF') Go To 8012
+      If (KWord(1:4).eq.'RIC ') Go To 9097
+      If (KWord(1:4).eq.'RICD') Go To 9080
+      If (KWord(1:4).eq.'RIJ ') Go To 9098
+      If (KWord(1:4).eq.'RIJK') Go To 9099
+      If (KWord(1:4).eq.'RMAT') Go To 880
+      If (KWord(1:4).eq.'RMBP') Go To 886
+      If (KWord(1:4).eq.'RMDI') Go To 884
+      If (KWord(1:4).eq.'RMEA') Go To 881
+      If (KWord(1:4).eq.'RMER') Go To 882
+      If (KWord(1:4).eq.'RMEQ') Go To 885
+      If (KWord(1:4).eq.'RMQC') Go To 883
+      If (KWord(1:4).eq.'ROT ') Go To 8027
+      If (KWord(1:4).eq.'RP-C') Go To 9093
+      If (KWord(1:4).eq.'RPQM') Go To 8008
+      If (KWord(1:4).eq.'RTRN') Go To 950
+      If (KWord(1:4).eq.'RX2C') Go To 9014
+      If (KWord(1:4).eq.'SADD') Go To 9081
+      If (KWord(1:4).eq.'SCAL') Go To 8018
+      If (KWord(1:4).eq.'SHAK') Go To 8050
+      If (KWord(1:4).eq.'SDEL') Go To 7071
+      If (KWord(1:4).eq.'SDIP') Go To 992
+      If (KWord(1:4).eq.'SHAC') Go To 8002
+      If (KWord(1:4).eq.'SKIP') Go To 9950
+      If (KWord(1:4).eq.'SLIM') Go To 8005
+      If (KWord(1:4).eq.'SPAN') Go To 890
+      If (KWord(1:4).eq.'SPRE') Go To 889
+      If (KWord(1:4).eq.'SQUA') Go To 9920
+      If (KWord(1:4).eq.'STDO') Go To 9930
+      If (KWord(1:4).eq.'SYMM') Go To 900
+      If (KWord(1:4).eq.'SYMT') Go To 6060
+      If (KWord(1:4).eq.'TARG') Go To 37
+      If (KWord(1:4).eq.'TDEL') Go To 7072
+      If (KWord(1:4).eq.'TEST') Go To 991
+      If (KWord(1:4).eq.'THRC') Go To 9021
+      If (KWord(1:4).eq.'THRE') Go To 941
+      If (KWord(1:4).eq.'THRL') Go To 37
+      If (KWord(1:4).eq.'THRS') Go To 907
+      If (KWord(1:4).eq.'TINK') Go To 8014
+      If (KWord(1:4).eq.'TITL') Go To 910
+      If (KWord(1:4).eq.'TRAN') Go To 8026
+      If (KWord(1:4).eq.'UNCO') Go To 43
+      If (KWord(1:4).eq.'UNIQ') Go To 45
+      If (KWord(1:4).eq.'UNNO') Go To 908
+      If (KWord(1:4).eq.'UPON') Go To 1001
+      If (KWord(1:4).eq.'VECT') Go To 905
+      If (KWord(1:4).eq.'VART') Go To 8032
+      If (KWord(1:4).eq.'VARR') Go To 8033
+      If (KWord(1:4).eq.'VERB') Go To 9122
+      If (KWord(1:4).eq.'VERI') Go To 40
+      If (KWord(1:4).eq.'WEIG') Go To 7014
+      If (KWord(1:4).eq.'WELL') Go To 986
+      If (KWord(1:4).eq.'WRUC') Go To 44
+      If (KWord(1:4).eq.'XBAS') Go To 1924
+      If (KWord(1:4).eq.'XFIE') Go To 975
+      If (KWord(1:4).eq.'XRIC') Go To 9085
+      If (KWord(1:4).eq.'XYZ ') Go To 1917
+      If (KWord(1:4).eq.'ZCON') Go To 8017
+      If (KWord(1:4).eq.'ZMAT') Go To 1920
+      If (KWord(1:4).eq.'ZONL') Go To 8028
+*
+      If (KWord(1:4).eq.'END ') Go To 997
+      If (lTtl) Go To 911
+      iChrct=Len(KWord)
+      Last=iCLast(KWord,iChrct)
+      Write (LuWr,*)
+      Call WarningMessage(2,KWord(1:Last)//' is not a keyword!,'//
+     &               ' Error in keyword.')
+      Call Quit_OnUserError()
+*
+c977  Call WarningMessage(2,' Premature end of input file.')
+c     Call Quit_OnUserError()
+*
+c988  Call WarningMessage(2,' Error while reading input file.;'//
+c    &                ' Last read was:'//KWord)
+c     Call Abend()
+#ifdef _FDE_
+*                                                                      *
+****** EMBE ************************************************************
+*                                                                      *
+*     Read in the name of a file for an embedding potential on a grid
+*
+ 666  embPot=.true.
+      Call Put_iScalar('embpot',1)
+ 667  KWord = Get_Ln(LuRd)
+      if(KWord(1:4).eq."ENDE") then
+       ! Sanity check
+       if (embPotInBasis.and.(.not.outGridPathGiven).and.(embWriteDens
+     &      .or.embWriteESP.or.embWriteGrad.or.embWriteHess)) then
+        Call WarningMessage(2,' No grid to write output in embedding.')
+        Call Quit_OnUserError()
+       end if
+       ! Write the embpot runfile
+       Call EmbPotWrRun
+       Go To 998
+      end if
+      ! Switch whether the potential is given in basis set
+      ! representation instead of grid representation
+      if (KWord(1:4).eq."BASI") then
+       embPotInBasis = .true.
+       write(LuWr,*) "Set embPotInBasis to ", embPotInBasis
+       Go To 667
+      end if
+      ! Get the EMBInfile path containing an embedding pot. on a grid
+      if(KWord(1:4).eq."EMBI") then
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,embPotPath,1)
+       Go To 667
+      end if
+      ! If the output grid is different from the input grid a path to
+      ! a grid file is specified here
+      if(KWord(1:4).eq."OUTG") then
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,outGridPath,1)
+       outGridPathGiven=.true.
+       Go To 667
+      end if
+      ! If given, the final density is written out on a grid, the path
+      ! to the file where to write it to must be given as well.
+      if(KWord(1:4).eq."WRDE") then
+       embWriteDens=.true.
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,embOutDensPath,1)
+       Go To 667
+      end if
+      ! If given, the final electrostatic potential is written out on
+      ! a grid, the path to the file where to write it to must be given
+      ! as well.
+      if(KWord(1:4).eq."WREP") then
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,embOutEspPath,1)
+       embWriteESP=.true.
+       Go To 667
+      end if
+      ! If given, the density gradient is written out on a grid, the
+      ! path to the file where to write it to must be given as well.
+      if(KWord(1:4).eq."WRGR") then
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,embOutGradPath,1)
+       embWriteGrad=.true.
+       Go To 667
+      end if
+      ! If given, the Hessian of the density is written out on a grid,
+      ! the path to the file where to write it to must be given as
+      ! well.
+      if(KWord(1:4).eq."WRHE") then
+       embWriteHess=.true.
+       KWord = Get_Ln(LuRd)
+       Call Get_S(1,embOutHessPath,1)
+       Go To 667
+      end if
+      ! Should not be reached.
+       Call WarningMessage(2,
+     &             'Error in input of EMBEdding block!')
+       Call Quit_OnUserError()
+#endif
+*                                                                      *
+****** SYMM ************************************************************
+*                                                                      *
+*     Read distinct symmetry operators apart for the unity operator
+*
+ 900  SymmSet=.true.
+      KWord = Get_Ln(LuRd)
+      GWInput=.True.
+      If (.not.DoneCoord.and.iCoord.ne.0) Then
+       Call WarningMessage(2,
+     &             'SYMMETRY keyword is not compatible with COORD')
+       Call Quit_OnUserError()
+      End If
+      If (Run_Mode.eq.S_Mode) Then
+         Call WarningMessage(2,'Seward input error!')
+         Write (LuWr,'(A,A,A)') 'The command : "',Previous_Command,
+     &                          '" is not allowed'
+     &                        //' in Seward input when Gateway is used!'
+         Write (LuWr,*)
+         Call Quit_OnUserError()
+      End If
+      Call UpCase(KWord)
+      iChrct=Len(KWord)
+ 901  Last=iCLast(KWord,iChrct)
+      iFrst=iCFrst(KWord,iChrct)
+      If (iFrst.le.Last) Then
+         nOper = nOper + 1
+         Oper(nOper)(1:1) = KWord(iFrst:iFrst)
+         KWord(iFrst:iFrst) = ' '
+         iFrst = iFrst + 1
+         If (KWord(iFrst:iFrst).eq.' ') Go To 901
+         Oper(nOper)(2:2) = KWord(iFrst:iFrst)
+         KWord(iFrst:iFrst) = ' '
+         iFrst = iFrst + 1
+         If (KWord(iFrst:iFrst).eq.' ') Go To 901
+         Oper(nOper)(3:3) = KWord(iFrst:iFrst)
+         KWord(iFrst:iFrst) = ' '
+         Go to 901
+      Else
+         Go To 998
+      End If
+*                                                                      *
+****** FILE ************************************************************
+*                                                                      *
+*     Specify filename for input orbitals
+*
+ 904  Line = Get_Ln(LuRd)
+      Call FileOrb(Line,SW_FileOrb)
+      Go To 998
+*                                                                      *
+****** VECT ************************************************************
+*                                                                      *
+*     Change mode of Seward to property calculations.
+*
+ 905  Prprt = .True.
+      Go To 998
+*                                                                      *
+****** ORBC ************************************************************
+*                                                                      *
+*     Request property output with explicit listing of orbital
+*     contributions.
+*
+ 906  Short = .False.
+      Go To 998
+*                                                                      *
+****** THRS ************************************************************
+*                                                                      *
+*     Change default for non-zero occupation numbers
+*
+ 907  KWord = Get_Ln(LuRd)
+      Call Get_F(1,Thrs,1)
+      Thrs = Abs(Thrs)
+      Go To 998
+*                                                                      *
+****** UNNO ************************************************************
+*                                                                      *
+*     Change default to unnormalized integrals
+*
+ 908  UnNorm = .True.
+      Go To 998
+*                                                                      *
+****** RADI ************************************************************
+*                                                                      *
+*     Integral cutoff to be based on radial overlap integrals
+*
+ 909  lSchw = .False.
+      Go To 998
+*                                                                      *
+****** TITL ************************************************************
+*                                                                      *
+*     Read the Title card
+*
+ 910  Key = Get_Ln(LuRd)
+ 911  Continue
+      GWInput = Run_Mode.eq.G_Mode
+      lTtl = .True.
+      nTtl = nTtl + 1
+      If (nTtl.gt.10) Then
+         Call WarningMessage(2,' Too many title cards')
+         Call Quit_OnUserError()
+      End If
+      i1=iCFrst(Key,80)
+      i2=iCLast(Key,80)
+      nc = 80-(i2-i1+1)
+      nc2=nc/2
+      nc3=(nc+1)/2
+      Title(nTtl)=BLine(1:nc2)//Key(i1:i2)//BLine(1:nc3)
+      Go To 9988
+*                                                                      *
+****** ECPS **** or ****** AUXS ****************************************
+*                                                                      *
+*     Allow printing of ECP data
+*
+ 912  nPrint(2)=Max(10,nPrint(2))
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** BSSH ************************************************************
+*                                                                      *
+*     Allow printing of ECP data
+*
+ 9121 nPrint(2)=Max(6,nPrint(2))
+      Go To 998
+*                                                                      *
+****** VERB ************************************************************
+*                                                                      *
+*     Verbose printing
+*
+ 9122 nPrint(2)=Max(10,nPrint(2))
+      nPrint(117)=6
+      nPrint(80)=6
+      nPrint( 1)=6
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*                                                                      *
+****** ZMAT ************************************************************
+*                                                                      *
+*     Read Basis Sets & Coordinates in Z-Matrix format
+*
+1920  Continue
+      if(isxbas.eq.0) Call Quit_OnUserError()
+      Call ZMatrixConverter(LuRd,LuWr,mxAtom,STDINP,lSTDINP,
+     &   iglobal,nxbas,xb_label,xb_bas,iErr)
+      If (iErr.ne.0) Call Quit_OnUserError()
+      GWInput=.True.
+      Call Gen_RelPointers(-(Info-1))
+      Call StdSewInput(1,nInfo,LuRd,ifnr,mdc,iShll,BasisTypes,
+     &                 STDINP,lSTDINP,iErr,DInf,nDInf)
+      Call Gen_RelPointers(Info-1)
+      If (iErr.ne.0) Call Quit_OnUserError()
+      Go To 998
+*                                                                      *
+****** XBAS ************************************************************
+*                                                                      *
+1924   Continue
+       call read_xbas(LuRd,iglobal,nxbas,xb_label,xb_bas,ierr)
+       GWInput=.True.
+       isxbas=1
+       if(ierr.eq.1) Call Quit_OnUserError()
+       goto 998
+*                                                                      *
+****** XYZ  ************************************************************
+*                                                                      *
+1917  Continue
+      if(isxbas.eq.0) Call Quit_OnUserError()
+      Call XMatrixConverter(LuRd,LuWr,mxAtom,STDINP,lSTDINP,
+     &   iglobal,nxbas,xb_label,xb_bas,iErr)
+      If (iErr.ne.0) Call Quit_OnUserError()
+      GWInput=.True.
+      Call Gen_RelPointers(-(Info-1))
+      Call StdSewInput(1,nInfo,LuRd,ifnr,mdc,iShll,BasisTypes,
+     &                 STDINP,lSTDINP,iErr,DInf,nDInf)
+      Call Gen_RelPointers(Info-1)
+      If (iErr.ne.0) Call Quit_OnUserError()
+      XYZdirect=.true.
+*      If (SymmSet) Then
+*         Call WarningMessage(2,
+*     &                 'SYMMETRY keyword is not compatible with XYZ')
+*         Call Quit_OnUserError()
+*      End If
+      If (GroupSet) Then
+         Call WarningMessage(2,
+     &                 'GROUP keyword is not compatible with XYZ')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+
+*                                                                      *
+****** COOR ************************************************************
+*                                                                      *
+*     Read Basis Sets & Coordinates in xyz format
+*
+6000  If (SymmSet) Then
+         Call WarningMessage(2,
+     &                 'SYMMETRY keyword is not compatible with COORD')
+         Call Quit_OnUserError()
+      End If
+      If (iOpt_XYZ.eq.0) Then
+         Call WarningMessage(2,
+     &            'COORD keyword is not compatible with non-XYZ format')
+         Call Quit_OnUserError()
+      End If
+c      If (CoordSet) Then
+c         Call WarningMessage(2,'There is more than one COORD keyword!')
+c*        Should this be an error and stop? Only if no HYPER or GEO?
+c      End If
+      if(isxbas.eq.1) Call Quit_OnUserError()
+      iCoord=iCoord+1
+
+      CoordSet=.true.
+      GWInput=.True.
+      Call XYZread(LuRd,ForceZMAT,nCoord, iErr)
+      If (iErr.ne.0) Call Quit_OnUserError()
+      Call XYZcollect(iCoord,nCoord,OrigTrans,OrigRot,nFragment)
+      Go To 998
+*                                                                      *
+****** GROUP ***********************************************************
+*                                                                      *
+*     Read information for a group
+*
+6010  If (SymmSet) Then
+         Call WarningMessage(2,
+     &                 'SYMMETRY keyword is not compatible with GROUP')
+         Call Quit_OnUserError()
+      End If
+      If (.not.CoordSet) Then
+         Call WarningMessage(2,'COORD keyword is not found')
+         Call Quit_OnUserError()
+      End If
+c Group command found - good reason to give up
+      KeepGroup=Get_Ln(LuRd)
+c Simplistic validity check for value
+      temp1=KeepGroup
+      Call UpCase(temp1)
+      If (temp1(1:4).eq.'FULL') Goto 6015
+      If (temp1(1:1).eq.'E') Goto 6015
+      If (temp1(1:2).eq.'C1') Goto 6015
+      If (temp1(1:5).eq.'NOSYM') Goto 6015
+      Do i=1,StrnLn(temp1)
+        If (temp1(i:i).ne.'X'.and.
+     &      temp1(i:i).ne.'Y'.and.
+     &      temp1(i:i).ne.'Z'.and.
+     &      temp1(i:i).ne.' ') Then
+          Call WarningMessage(2,
+     &    'Illegal symmetry group or operator: '//temp1(:StrnLn(temp1)))
+          Call Quit_OnUserError()
+        End If
+      End Do
+6015  Continue
+      GroupSet=.true.
+      GWInput=.True.
+      DoneCoord=.True.
+      goto 998
+*                                                                      *
+****** BSSE ************************************************************
+*                                                                      *
+*     Read information for a group
+*
+6020  Continue
+      if(.not.CoordSet) Then
+         Call WarningMessage(2,'COORD keyword is not found')
+         Call Quit_OnUserError()
+      End If
+c Group command found - good reason to give up
+      KWord=Get_Ln(LuRd)
+      read(Kword,*,end=6666,err=6666) iBSSE
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** MOVE ************************************************************
+*                                                                      *
+*     allow to MOVE coordinates
+*
+6040  Continue
+      if(.not.CoordSet) Then
+         Call WarningMessage(2,'COORD keyword is not found')
+         Call Quit_OnUserError()
+      End If
+c Group command found - good reason to give up
+      isHold=0
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** NOMOVE **********************************************************
+*                                                                      *
+*     Do NOT allow to MOVE coordinates
+*
+6050  Continue
+      if(.not.CoordSet) Then
+         Call WarningMessage(2,'COORD keyword is not found')
+         Call Quit_OnUserError()
+      End If
+c Group command found - good reason to give up
+      isHold=1
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** SYMT ************************************************************
+*                                                                      *
+*     Threshold for findsym
+*
+6060  Continue
+      if(.not.CoordSet) Then
+         Call WarningMessage(2,'COORD keyword is not found')
+         Call Quit_OnUserError()
+      End If
+c Group command found - good reason to give up
+      KWord=Get_Ln(LuRd)
+      read(Kword,*,end=6666, err=6666) SymThr
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** NODE ************************************************************
+*                                                                      *
+*     Set global delete parameters to disable orbital deleting
+*     Keywords: NODElete at 7070
+*               SDELete  at 7071
+*               TDELete  at 7072
+*
+7070  continue
+      Call Put_dScalar('S delete thr',0.0d0)
+      Call Put_dScalar('T delete thr',1.0d15)
+      goto 998
+7071  continue
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,sDel,1)
+      Call Put_dScalar('S delete thr',sDel)
+      goto 998
+7072  continue
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,tDel,1)
+      Call Put_dScalar('T delete thr',tDel)
+      goto 998
+7700  continue
+      KWord = Get_Ln(LuRd)
+      ExtBasDir=KWord
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** BASI ************************************************************
+*                                                                      *
+*     Read information for a basis set
+*
+ 920  continue
+      If (CoordSet) then
+         GWInput=.True.
+         If (BasisSet) Then
+            KeepBasis=
+     &             KeepBasis(1:index(KeepBasis,' '))//','//Get_Ln(LuRd)
+         Else
+            KeepBasis=Get_Ln(LuRd)
+         Endif
+         BasisSet=.True.
+         temp1=KeepBasis
+         Call UpCase(temp1)
+        if (INDEX(temp1,'INLINE').ne.0) then
+       Write(LuWr,*) 'XYZ input and Inline basis set are not compatible'
+       Write(LuWr,*) 'Consult the manual how to change inline basis set'
+       Write(LuWr,*) ' into basis set library'
+         Call Quit_OnUserError()
+         endif
+         iOpt_XYZ=1
+         Goto 998
+      Else
+         iOpt_XYZ=0
+      End If
+      GWInput=.True.
+      nCnttp = nCnttp + 1
+      If (Run_Mode.eq.S_Mode) Then
+         Call WarningMessage(2,'Seward input error!')
+         Write (LuWr,*) 'The command : "',Previous_Command,
+     &               '" is not allowed'
+     &              //' in the Seward input when the Gateway is used!'
+         Write (LuWr,*)
+         Call Quit_OnUserError()
+      End If
+      If (nCnttp.gt.Mxdbsc) Then
+         Call WarningMessage(2,' Increase Mxdbsc')
+         Call Quit_OnUserError()
+      End If
+      NoZMAT=.True.
+*
+*     Read the basis set label
+*
+      Key = Get_Ln(LuRd)
+      BSLbl = Key(1:80)
+*
+*     If dummy atom point at the ANO-RCC set where the specification is.
+*
+      Call UpCase(BSLbl)
+      iDummy_basis=0
+      If (BSLbl(1:2).eq.'X.'.and.Index(BSLbl,'INLINE').eq.0.and.
+     &    Index(BSLbl,'RYDBERG').eq.0) Then
+         Call ICopy(4,BasisTypes,1,BasisTypes_save,1)
+         BSLbl_Dummy=BSLbl
+         BSLbl='X.ANO-RCC.'
+         Do i=11,80
+           BSLbl(i:i)='.'
+         End do
+         iDummy_basis=1
+      End If
+*     Call UpCase(BSLbl)
+      LenBSL=Len(BSLbl)
+      Last=iCLast(BSLbl,LenBSL)
+      GWInput=.True.
+      Indx=Index(BSLbl,'/')
+      If (Indx.eq.0) Then
+         Fname=BasLib
+         Indx = Last+1
+         Bsl(nCnttp)=BSLbl
+      Else
+         Fname= BSLbl(Indx+2:Last)
+         If (Fname.eq.' ') Then
+            Call WarningMessage(2,
+     &                     ' No basis set library specified for'
+     &                   //'BSLbl='//BSLbl(1:Indx-1)//' Fname='//Fname)
+            Call Quit_OnUserError()
+         End If
+ 1919    If (Fname(1:1).eq.' ') Then
+            Fname(1:79)=Fname(2:80)
+            Fname(80:80) = ' '
+            Go To 1919
+         End If
+         Bsl(nCnttp)=BSLbl(1:Indx-1)
+      End If
+*
+      n=INDEX(Bsl(nCnttp),' ')
+      If (n.eq.0) n=81
+      Do i=n,80
+        Bsl(nCnttp)(i:i)='.'
+      End Do
+*
+      If ((Show.and.nPrint(2).ge.6) .or.
+     &    Write_BasLib) Then
+         Write (LuWr,*)
+         Write (LuWr,*)
+         Write(LuWr,'(1X,A,I5,A,A)')
+     &           'Basis Set ',nCnttp,' Label: ', BSLbl(1:Indx-1)
+         Write(LuWr,'(1X,A,A)') 'Basis set is read from library:',
+     *         Fname(1:index(Fname,' '))
+      End if
+*
+      jShll = iShll
+      SODK(nCnttp)=.False.
+      AuxCnttp(nCnttp)=.False.
+      Bsl_Old(nCnttp)=Bsl(nCnttp)
+      mdciCnttp(nCnttp)=mdc
+      Call Gen_RelPointers(-(Info-1))
+      Call GetBS(Fname,Bsl(nCnttp),Indx-1,lAng,ipExp,
+     &           ipCff,ipCff_Cntrct,ipCff_Prim,ipFockOp,
+     &           nExp,nBasis,nBasis_Cntrct,MxShll,iShll,
+     &           MxAng,Charge(nCnttp),
+     &           iAtmNr(nCnttp),BLine,Ref, PAM2(nCnttp),
+     &           ipPAM2xp(nCnttp),ipPAM2cf(nCnttp),nPAM2(nCnttp),
+     &           FockOp(nCnttp),
+     &           ECP(nCnttp),NoPairL(nCnttp),SODK(nCnttp),
+     &           ipM1xp(nCnttp),ipM1cf(nCnttp),nM1(nCnttp),
+     &           ipM2xp(nCnttp),ipM2cf(nCnttp),nM2(nCnttp),ipBk,
+     &           CrRep(nCnttp),nProj,nAIMP,ipAkl,ip_Occ,iOptn,
+     &           UnNorm,nDel,
+     &            nVal,   nPrj,   nSRO,   nSOC,  nPP,
+     &           ipVal_, ipPrj_, ipSRO_, ipSOC_,ipPP_,
+     &           LuRd,BasisTypes,AuxCnttp(nCnttp),
+     &           nFragType(nCnttp),nFragCoor(nCnttp),nFragEner(nCnttp),
+     &           nFragDens(nCnttp),ipFragType(nCnttp),ipFragCoor(nCnttp)
+     &           ,ipFragEner(nCnttp),ipFragCoef(nCnttp),IsMM(nCnttp),
+     &           STDINP,lSTDINP,.False.,Expert,ExtBasDir,
+     &           DInf,nDInf)
+      Call Gen_RelPointers(Info-1)
+*
+      Do_FckInt = Do_FckInt .and. FockOp(nCnttp) .and.
+     &            iAtmNr(nCnttp).le.96
+#ifdef _DEMO_
+      Do_GuessOrb = .False.
+#else
+      Do_GuessOrb = Do_GuessOrb .and. iAtmNr(nCnttp).le.96
+#endif
+*
+      If (iDummy_Basis.eq.1) Call ICopy(4,BasisTypes_Save,1,
+     &                                    BasisTypes,1)
+      If (itype.eq.0) Then
+         If (BasisTypes(3).eq.1 .or. BasisTypes(3).eq.2)
+     &       iType=BasisTypes(3)
+      Else
+         If (BasisTypes(3).eq.1 .or. BasisTypes(3).eq.2) Then
+            If (BasisTypes(3).ne.iType) Then
+               imix=1
+               BasisTypes(3)=-1
+            End If
+            iType=BasisTypes(3)
+         End If
+      End If
+      If (itype.eq.1) ifnr=1
+      If (itype.eq.2) ifnr=0
+*
+      If (nSOC.gt.-1) Then
+         Do l = 1, MxAng
+            kDel(l,nCnttp)=nDel(l)
+         End Do
+      End If
+      If (Show.and.nPrint(2).ge.6 .and.
+     &   Ref(1).ne.BLine .and. Ref(2).ne.Bline) Then
+         Write (LuWr,'(1x,a)')  'Basis Set Reference(s):'
+         If (Ref(1).ne.BLine) Write (LuWr,'(5x,a)') Ref(1)
+         If (Ref(2).ne.BLine) Write (LuWr,'(5x,a)') Ref(2)
+         Write (LuWr,*)
+         Write (LuWr,*)
+      End If
+      lPAM2 = lPAM2 .or. PAM2(nCnttp)
+      ECP(nCnttp)=(nPP+nPrj+nSRO+nSOC+nM1(nCnttp)+nM2(nCnttp)).ne.0
+      lPP=lPP .or. nPP.ne.0
+      lECP = lECP .or. ECP(nCnttp)
+      lNoPair = lNoPair .or. NoPairL(nCnttp)
+*
+      iAngMx=Max(iAngMx,lAng)
+*     No transformation needed for s and p shells
+      Transf(jShll+1)=.False.
+      Prjct(jShll+1)=.False.
+      Transf(jShll+2)=.False.
+      Prjct(jShll+2)=.False.
+      pChrg(nCnttp)=.False.
+      Fixed(nCnttp)=.False.
+      nOpt(nCnttp) = iOptn
+      ipVal(nCnttp) = ipVal_
+      ipPrj(nCnttp) = ipPrj_
+      ipSRO(nCnttp) = ipSRO_
+      ipSOC(nCnttp) = ipSOC_
+      ipPP(nCnttp)  = ipPP_
+      nVal_Shells(nCnttp) = nVal
+      nPrj_Shells(nCnttp) = nPrj
+      nSRO_Shells(nCnttp) = nSRO
+      nSOC_Shells(nCnttp) = nSOC
+      nPP_Shells(nCnttp)  = nPP
+      nTot_Shells(nCnttp) = nVal+nPrj+nSRO+nSOC+nPP
+      ipCntr(nCnttp) = ipExp(iShll+1)
+      nCnt = 0
+      lAux = lAux .or. AuxCnttp(nCnttp)
+      If (AuxCnttp(nCnttp)) Then
+         Do iSh = jShll+1, iShll
+            AuxShell(iSh)=.True.
+         End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Compute the effective radius of this center
+*
+      iAng = 0
+      Thrshld_R=1.0D-08
+      Do iSh = ipVal_, ipVal_+nVal-1
+         RMax_R=Zero
+         Do iPrim = 0, nExp(iSh)-1
+            ValExp = Work(ipExp(iSh)+iPrim)
+            RMax_R = Max(RMax_R,
+     &                   Eval_RMax(ValExp,iAng,Thrshld_R))
+         End Do
+         RMax_Shll(iSh)=RMax_R
+C        Write (LuWr,*) 'RMax_R=',RMax_R
+         iAng = iAng + 1
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Here we will have to fix that the 6-31G family of basis sets
+*     should by default be used with 6 d-functions rather than 5.
+*
+      KWord=BSLbl(1:Indx-1)
+      Call UpCase(KWord)
+      If (INDEX(KWord,'6-31G').ne.0) Then
+         Do iSh = jShll+3, iShll
+            Prjct(iSh)=.False.
+            Transf(iSh)=.False.
+         End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Automatic onset of muonic charge if the basis type is muonic.
+*     This will also automatically activate finite nuclear mass
+*     correction.
+*
+      If (INDEX(KWord,'MUONIC').ne.0) Then
+         fmass(nCnttp)=
+     &    CONST_MUON_MASS_IN_SI_ / CONST_ELECTRON_MASS_IN_SI_
+         FNMC=.True.
+         Nuclear_Model=Gaussian_Type
+         tDel=1.0D50
+         Call Put_dScalar('T delete thr',tDel)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+ 777  KWord = Get_Ln(LuRd)
+      Call UpCase(KWord)
+      Call LeftAd(KWord)
+      If (KWord(1:4).eq.'PSEU') Then
+         pChrg(nCnttp)=.True.
+         Fixed(nCnttp)=.True.
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'ACDT') Then
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,aCD_Thr(nCnttp),1)
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'MUON') Then
+         fmass(nCnttp)=
+     &    CONST_MUON_MASS_IN_SI_ / CONST_ELECTRON_MASS_IN_SI_
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'NUCL') Then
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,ExpNuc(nCnttp),1)
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'FIXE') Then
+         Fixed(nCnttp)=.True.
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'SPHE') Then
+         If (Index(KWord,'ALL').ne.0) Then
+            Do iSh = jShll+3, iShll
+               Transf(iSh)=.True.
+               Prjct(iSh)=.True.
+            End Do
+            Go To 777
+         End If
+         ist = index(KWord,' ')
+         iAng = 2
+         Do iSh = jShll+3, iShll
+            If (Index(KWord(ist:80),AngTyp(iAng)).ne.0) Then
+               Transf(iSh) = .True.
+               Prjct(iSh) = .True.
+            End If
+            iAng = iAng + 1
+         End Do
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'CART') Then
+         If (Index(KWord,'ALL').ne.0) Then
+            Do iSh = jShll+1, iShll
+               Transf(iSh)=.False.
+               Prjct(iSh)=.False.
+            End Do
+            Go To 777
+         End If
+         ist = index(KWord,' ')
+         iAng = 0
+         Do iSh = jShll+1, iShll
+            If (Index(KWord(ist:80),AngTyp(iAng)).ne.0) Then
+               Transf(iSh) = .False.
+               Prjct(iSh) = .False.
+            End If
+            iAng = iAng + 1
+         End Do
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'CONT') Then
+         If (Index(KWord,'ALL').ne.0) Then
+            Do iSh = jShll+1, iShll
+               Prjct(iSh)=.False.
+            End Do
+            Go To 777
+         End If
+         ist = index(KWord,' ')
+         iAng = 0
+         Do iSh = jShll+1, iShll
+            If (Index(KWord(ist:80),AngTyp(iAng)).ne.0)
+     &          Prjct(iSh) = .False.
+            iAng = iAng + 1
+         End Do
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'CHAR') Then
+         KWord = Get_Ln(LuRd)
+         Call UpCase(KWord)
+         Call Get_F(1,Charge(nCnttp),1)
+         ist = index(KWord,' ')
+         If (IsMM(nCnttp).ne.0) Then
+            Call WarningMessage(1,
+     &         ' Found a charge associated with a MM atom. Ignore it')
+            Charge(nCnttp) = Zero
+         End If
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'FRAG') Then
+         pChrg(nCnttp)=.True.
+         Fixed(nCnttp)=.True.
+         lFAIEMP=.True.
+         Go To 777
+      End If
+      If (KWord(1:4).eq.'END ') Then
+         If (nCnt.eq.0) Then
+            Call WarningMessage(2,' Input error, no center specified!')
+            Call Quit_OnUserError()
+         End If
+         nCntr(nCnttp) = nCnt
+         mdc = mdc + nCnt
+         If (iShll.lt.MxShll) ipExp(iShll+1) = ipExp(iShll+1) + nCnt*3
+*        Compute the number of elements stored in the dynamic memory
+*        so far.
+         nInfo = ipExp(iShll+1) - Info
+* the next line seems to convince IBM XLF 6.1 to forgo its otherwise
+* crass behaviour. Who can tell why? Peter Knowles, 7/99
+         ninfo_stupid = nInfo
+         Go To 998
+      End If
+*
+*     Read Coordinates
+*
+      nCnt = nCnt + 1
+      If (mdc+nCnt.gt.Mxdc) Then
+         Call WarningMessage(2,' RdCtl: Increase Mxdc')
+         Write (LuWr,*) '        Mxdc=',Mxdc
+         Call Quit_OnUserError()
+      End If
+      iend=Index(KWord,' ')
+      If (iEnd.gt.LENIN+1) Then
+         Write (6,*) 'Warning: the label ', KWord(1:iEnd),
+     &               ' will be truncated to ',LENIN,' characters!'
+      End If
+      LblCnt(mdc+nCnt) = KWord(1:Min(LENIN,iend-1))
+      dbas=LblCnt(mdc+nCnt)(1:LENIN)
+      Call Upcase(dbas)
+      If (dbas.eq.'DBAS') Then
+         RMat_On=.True.
+      End If
+      If (mdc+nCnt.gt.1) then
+        Call ChkLbl(LblCnt(mdc+nCnt),LblCnt,mdc+nCnt-1)
+      endif
+      iOff=ipCntr(nCnttp)+(nCnt-1)*3
+      Call Get_F(2,Work(iOff),3)
+      If (Index(KWord,'ANGSTROM').ne.0) Then
+         Do i = 0, 2
+            Work(iOff+i) = Work(iOff+i)/angstr
+         End Do
+      End If
+*
+      If(Cell_l) Then
+      nCnt0 = nCnt
+      iOff0=iOff
+      lthCell = lthCell + 1
+      AdCell(lthCell) = mdc+nCnt0  ! the sequence atom No
+      ii = 0
+      Do n1=-ispread(1),ispread(1)
+         Do n2=-ispread(2),ispread(2)
+            Do n3=-ispread(3),ispread(3)
+               If((n1.Eq.0).And.(n2.Eq.0).And.(n3.Eq.0)) GoTo 110
+
+                  ii = ii + 1
+
+                  If(ii.GE.10000) Then
+                     Call WarningMessage(2,' Too many atoms in Seward')
+                     Call Quit_OnUserError()
+                  Else
+                     If(ii.LT.1000) Then
+                        CHAR4 = INT2CHAR(ii,3)
+                        CHAR4 ='_'//CHAR4(1:3)
+                     Else
+                        CHAR4 = INT2CHAR(ii,4)
+                     End If
+                  End If
+
+                  nCnt = nCnt + 1
+
+                  If (mdc+nCnt.gt.Mxdc) Then
+                     Call WarningMessage(2,' RdCtl: Increase Mxdc')
+                     Write (LuWr,*) '        Mxdc=',Mxdc
+                     Call Quit_OnUserError()
+                  End If
+
+                  iend=Index(KWord,' ')
+                  If (iEnd.gt.5) Then
+                     Write (6,*) 'Warning: the label ', KWord(1:iEnd),
+     &               ' will be truncated to ',LENIN,' characters!'
+                  End If
+                  LblCnt(mdc+nCnt) = KWord(1:Min(LENIN,iend-1))//
+     &              CHAR4
+
+                  Call ChkLbl(LblCnt(mdc+nCnt),LblCnt,mdc+nCnt-1)
+
+                  iOff=ipCntr(nCnttp)+(nCnt-1)*3
+
+*                 Copy old coordinate  first
+                  CALL DCOPY_(3,Work(iOff0),1,Work(iOff),1)
+                  CALL DAXPY_(3,DBLE(n1),VCell(1,1),1,Work(iOff),1)
+                  CALL DAXPY_(3,DBLE(n2),VCell(1,2),1,Work(iOff),1)
+                  CALL DAXPY_(3,DBLE(n3),VCell(1,3),1,Work(iOff),1)
+*
+  110          Continue
+*
+            End Do
+         End Do
+      End Do
+      End If
+      Go To 777
+*                                                                      *
+****** PRIN ************************************************************
+*                                                                      *
+*     Print level
+*
+ 930  KWord = Get_Ln(LuRd)
+      GWInput = Run_Mode.eq.G_Mode
+      Call Get_I(1,n,1)
+      Do i = 1, n
+         KWord = Get_Ln(LuRd)
+         Call Get_I(1,jRout,1)
+         Call Get_I(2,iPrint,1)
+         nPrint(jRout)=iPrint
+      End Do
+      Go To 998
+*                                                                      *
+****** OPTO ************************************************************
+*                                                                      *
+*     Reduce the output for optimizations
+*
+ 940  lOPTO = .True.
+      Go To 998
+*                                                                      *
+****** THRE ************************************************************
+*                                                                      *
+*     Threshold for writing integrals to disk
+*
+ 941  KWord = Get_Ln(LuRd)
+      Call Get_F(1,ThrInt,1)
+      ThrInt = Abs(ThrInt)
+      ThrInt_UsrDef = .True.
+      Go To 998
+*                                                                      *
+****** CUTO ************************************************************
+*                                                                      *
+*     Cutoff for computing primitive integrals [a0|c0]
+*
+ 942  KWord = Get_Ln(LuRd)
+      Call Get_F(1,CutInt,1)
+      CutInt = Abs(CutInt)
+      CutInt_UsrDef = .True.
+      Go To 998
+*                                                                      *
+****** RTRN ************************************************************
+*                                                                      *
+*     Defining max bond distance for bonds, angles and dihedrals
+*     Define max number of atoms to list for
+*
+ 950  KWord = Get_Ln(LuRd)
+      Call Upcase(KWord)
+      Call Get_I(1,Max_Center,1)
+      Call Get_F(2,rtrnc,1)
+      If (Index(KWord,'ANGSTROM').ne.0)
+     &    Rtrnc = Rtrnc/angstr
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** MEMO ************************************************************
+*                                                                      *
+*     Screen off memory
+*
+c951  KWord = Get_Ln(LuRd)
+c     Call Get_I(1,memhid,1)
+c     If (MemHid.le.0) MemHid = 1
+c     Go To 998
+*                                                                      *
+****** DIRE ************************************************************
+*                                                                      *
+*     Force direct calculations & disable two-electron integrals
+*
+ 9770 DirInt = .True.
+      Onenly = .True.
+      iChk_DC=1
+      If ( (iChk_RI+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &           'Direct is incompatible with RI and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Do_RI=.False.
+      Go To 998
+*                                                                      *
+****** EXPE ************************************************************
+*                                                                      *
+*     Expert mode
+*
+ 9771 Expert = .True.
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*                                                                      *
+****** DIST ************************************************************
+*                                                                      *
+*     Enable computation of integral distribution
+*
+ 954  Dist = .True.
+      Go To 998
+*                                                                      *
+****** MOLC or DCRN ****************************************************
+*                                                                      *
+*     Weight for DCR summation (this is the default for conventional
+*     calculations)
+*
+ 957  Continue
+ 958  MolWgh=0
+      MolWgh_UsrDef=.true.
+      Go To 998
+*                                                                      *
+****** MOLP ************************************************************
+*                                                                      *
+*     Weight for DCR summation modified to MOLPRO format
+*
+ 959  MolWgh=2
+      MolWgh_UsrDef=.true.
+      Go To 998
+*                                                                      *
+****** MOLE ************************************************************
+*                                                                      *
+*     Weight for DCR summation modified to MOLECULE format
+*
+ 960  MolWgh=1
+      MolWgh_UsrDef=.true.
+      Go To 998
+*                                                                      *
+****** PETI ************************************************************
+*                                                                      *
+*     Compute integrals in SO format or petite list
+*
+ 961  Petite=.True.
+      lSOInt=.False.
+      Go To 998
+*                                                                      *
+****** RELI ************************************************************
+*                                                                      *
+*     Compute integrals for first order relativistic corrections
+*     of the energy, i.e. the mass-velocity integrals and the
+*     one-electron Darwin contract term integrals.
+*
+ 962  lRel=.True.
+      Go To 998
+*                                                                      *
+****** JMAX ************************************************************
+*                                                                      *
+*     Change max j quantum number for the rigid rotor analysis
+*
+ 971  KWord = Get_Ln(LuRd)
+      Call Get_I(1,jMax,1)
+      Go To 998
+*                                                                      *
+****** MULT ************************************************************
+*                                                                      *
+*     Read order of highest multipole to be computed
+*
+ 972  KWord = Get_Ln(LuRd)
+      Call Get_I(1,nMltpl,1)
+      Go To 998
+*                                                                      *
+****** CENT ************************************************************
+*                                                                      *
+*     User specified centers of multipole moment operators.
+*
+ 973  KWord = Get_Ln(LuRd)
+      Call Get_I(1,nTemp,1)
+      If (lMltpl) Then
+         Call WarningMessage(2,
+     &               ' Abend: User specified centers already defined;'
+     &             //' Abend: Correct input error!')
+         Call Quit_OnUserError()
+      Else
+         lMltpl = .TRUE.
+      End If
+*     Allocate temporary memory for user defined centers
+      Call mma_allocate(RTmp,3,nTemp,label='RTmp')
+      Call mma_allocate(ITmp,nTemp,label='ITmp')
+      Do 1502 i = 1, nTemp
+         KWord = Get_Ln(LuRd)
+         Call Get_I(1,iMltpl,1)
+         Call Get_F(2,RTmp(1,i),3)
+         If (Index(KWord,'ANGSTROM').ne.0)
+     &       Call DScal_(3,One/angstr,RTmp(1,i),1)
+         ITmp(i) = iMltpl
+ 1502 Continue
+      Go To 998
+*                                                                      *
+****** EMPC ************************************************************
+*                                                                      *
+*     Compute Orbital-Free Embedding integrals from Point Charges
+*             specified in XFIEld
+*
+ 974  DoEmPC=.True.
+      isHold=1 ! avoid coordinate moving
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** XFIE ************************************************************
+*                                                                      *
+*     User specified external field
+*
+ 975  lXF=.True.
+      GWInput=.True.
+      KWord = Get_Ln(LuRd)
+*     Open external file if the line does not start with an integer
+      LuRd_saved=LuRd
+      Read(KWord,*,Err=9751) ibla
+      Goto 9752
+9751  LuRd=1
+      Call Get_S(1,filename,1)
+9753  Call OpnFl(filename(1:(Index(filename,' ')-1)),LuRd,Exist)
+      If (.not.Exist) Then
+         Call WarningMessage(2,
+     &                'Error! File not found: '//
+     &        filename(1:(Index(filename,' ')-1)))
+         Call Quit_OnUserError()
+      End If
+      write(LuWr,*)'Reading external field from file: ',
+     &        filename(1:(Index(filename,' ')-1))
+      KWord = Get_Ln(LuRd)
+9752  Call Get_I(1,nXF,1)
+      Convert=.False.
+      Call Upcase(kWord)
+      If (Index(KWord,'ANGSTROM').ne.0) Then
+          Convert=.True.
+          ix=Index(KWord,'ANGSTROM')
+          KWord(ix:ix+7)='        '
+      End If
+*
+      KWord(170:180)='-2 -2 -2 -2'
+      Call Put_Ln(KWord)
+      Call Get_I(2,nOrd_XF,1)
+      Call Get_I(3,iXPolType,1)
+      Call Get_I(4,nXMolnr,1)
+      Call Get_I(5,nReadEle,1)
+
+*     Set defaults: ch+dip, no polarisabilities,
+*                   exclude only its own multipole,
+*                   no element read
+      if(nOrd_XF.eq.-2) nOrd_XF=1
+      if(iXPolType.eq.-2) iXPolType=0
+      if(nXMolnr.eq.-2) nXMolnr=0
+      if(nReadEle.eq.-2) nReadEle=0
+
+      If ((nOrd_XF.gt.2).or.(nOrd_XF.lt.-1)) Then
+         Call WarningMessage(2,'Error! Illegal value of nOrd_XF')
+         Write(LuWr,*)'nOrd_XF= ', nOrd_XF
+         Call Quit_OnUserError()
+      EndIf
+      If ((iXPolType.gt.2).or.(iXPolType.lt.0)) Then
+         Call WarningMessage(2,'Error! Illegal value of iXPolType')
+         Write(LuWr,*)'iXPolType= ', iXPolType
+         Call Quit_OnUserError()
+      EndIf
+      If ((nXMolnr.gt.100).or.(nXMolnr.lt.0)) Then
+         Call WarningMessage(2,'Error! Illegal value of nXMolnr')
+         Write(LuWr,*)'nXMolnr= ', nXMolnr
+         Call Quit_OnUserError()
+      EndIf
+      If ((nReadEle.gt.1).or.(nReadEle.lt.0)) Then
+         Call WarningMessage(2,'Error! Illegal value of nReadEle')
+         Write(LuWr,*)'nReadEle= ', nReadEle
+         Call Quit_OnUserError()
+      EndIf
+*
+      nData_XF=3
+      Do iOrd_XF = 0, nOrd_XF
+         nData_XF = nData_XF +  (iOrd_XF+1)*(iOrd_XF+2)/2
+C        nData_XF = nData_XF +  2*iOrd_XF+1
+      End Do
+
+      if(iXPolType.gt.0) then
+         nData_XF=nData_XF+6
+         lRF=.true.  ! Polarisabilities treated as Langevin
+      endif
+*
+      If(iXPolType.eq.1) Then
+         nDataRead=nData_XF-5   !Read only one pol value
+      Else
+         nDataRead=nData_XF
+      Endif
+*
+      lenXF=nXF*nData_XF
+      lenXMolnr=2*((nXMolnr*nXF+1)/2)/RtoI
+      lenXEle=2*((nXF+1)/2)/RtoI
+
+*---- Get pointer to the next free space in dynamic memory
+      ipXF=ipExp(iShll+1)
+      ipXMolnr_r=ipXF+lenXF
+      ipXEle_r=ipXMolnr_r+lenXMolnr
+*---- Update pointer to the next free space in dynamic memory
+      ipExp(iShll+1)=ipXEle_r+lenXEle
+      nInfo = nInfo + lenXF + lenXMolnr + lenXEle
+*
+      ipXMolnr=ip_of_iWork(Work(ipXMolnr_r))
+      ipXEle=ip_of_iWork(Work(ipXEle_r))
+*
+      Call Upcase(KWord)
+*
+      ip = ipXF
+      Do iXF = 1, nXF
+         iWork(ipXEle+(iXF-1))=0   ! default: no element spec.
+*
+*     If reading from external file, use free format to allow
+*     long lines of input. On the other hand, comments are
+*     not allowed in external files.
+         If(LuRd.ne.LuRd_saved) then
+            Read(LuRd,*)(iWork(ipXMolnr+(iXF-1)*nXMolnr+k),
+     &           k=0,nXMolnr-1),
+     &           (iWork(ipXEle+(iXF-1)+k),k=0,nReadEle-1),
+     &           (Work(ip+k),k=0,nDataRead-1)
+         Else
+            KWord = Get_Ln(LuRd)
+            KWord(170:180)=' 0.0 0.0 0.0'
+            Call Put_Ln(KWord)
+
+            Call Get_I(1,iWork(ipXMolnr+(iXF-1)*nXMolnr),nXMolnr)
+            Call Get_I(nXMolnr+1,iWork(ipXEle+(iXF-1)),nReadEle)
+            Call Get_F(nXMolnr+nReadEle+1,Work(ip),nDataRead)
+         EndIf
+*
+            Work(ip  ) = Work(ip  )*ScaleFactor
+            Work(ip+1) = Work(ip+1)*ScaleFactor
+            Work(ip+2) = Work(ip+2)*ScaleFactor
+         If (Convert) Then
+            Work(ip  ) = Work(ip  )/angstr
+            Work(ip+1) = Work(ip+1)/angstr
+            Work(ip+2) = Work(ip+2)/angstr
+         End If
+         ip = ip + nData_XF
+*
+      End Do
+*
+*---- Close file and reset LuRd if external file was used
+      If(LuRd.ne.LuRd_saved) then
+         Close(LuRd)
+         LuRd = LuRd_saved
+      EndIf
+      if(isXfield.eq.1) goto 9755
+      Go To 998
+*                                                                      *
+****** DOUG ************************************************************
+*                                                                      *
+*     Full Douglas-Kroll operator
+*
+ 976  continue
+      IRELAE=0
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full Douglas-Kroll (DK1) operator
+*
+ 9001 continue
+      IRELAE=1
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full Douglas-Kroll (DK2) operator
+*
+ 9002 continue
+      IRELAE=2
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Douglas-Kroll (DK3) operator
+*
+ 9003 continue
+      IRELAE=3
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full Douglas-Kroll (DK3) operator
+*
+ 9004 continue
+      IRELAE=4
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full RESC operator
+*
+ 978  continue
+      IRELAE=11
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full ZORA
+*
+ 9011 continue
+      IRELAE=21
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full ZORA-FP
+*
+ 9012 continue
+      IRELAE=22
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Full IORA
+*
+ 9013 continue
+      IRELAE=23
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Exact decoupling X2C method
+*
+ 9014 continue
+      IRELAE=101
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Exact decoupling BSS method
+*
+ 9015 continue
+      IRELAE=102
+      DKroll=.True.
+      GWInput=.True.
+      go to 998
+*
+*     Switch on the old DKH routine
+*
+ 8121 continue
+      IRFLAG1=1
+      GWInput=.True.
+      goto 998
+*                                                                      *
+****** BSSM ************************************************************
+*                                                                      *
+*     BSS method
+ 9760 continue
+      BSS=.True.
+      GWInput=.True.
+      go to 976
+*                                                                      *
+****** AMFI ************************************************************
+*                                                                      *
+*     AMFI integrals
+*
+ 9761 Continue
+      lAMFI=.True.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** AMF1 ************************************************************
+*                                                                      *
+*     AMFI integrals
+*
+ 8761 Continue
+      lAMFI=.True.
+      iAMFn = 1
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** AMF2 ************************************************************
+*                                                                      *
+*     AMFI integrals (including 2nd-order)
+*
+ 8762 Continue
+      lAMFI=.True.
+      iAMFn = 2
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** AMF3 ************************************************************
+*                                                                      *
+*     AMFI integrals (including 3rd-order)
+*
+ 8763 Continue
+      lAMFI=.True.
+      iAMFn = 3
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** FAKE ************************************************************
+*                                                                      *
+*     Fake run : conventional, RI or CD ERIs not computed
+*                but some info is set to runfile (e.g. CD thrs)
+*                Not the same as ONEOnly !!
+*
+ 9759 Continue
+      Fake_ERIs = .true.
+      Go To 998
+*                                                                      *
+****** FINI ************************************************************
+*                                                                      *
+*     Finite nuclei - Gaussian type
+*
+ 9762 Continue
+      Nuclear_Model=Gaussian_Type
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** MGAU ************************************************************
+*                                                                      *
+*     Finite nuclei - modified Gaussian type
+*
+ 8009 Continue
+      Nuclear_Model=mGaussian_Type
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** PART ************************************************************
+*                                                                      *
+*     Show partitioning statistics
+*
+ 9763 Continue
+      nPrint(10)=6
+      Go To 998
+*                                                                      *
+****** FPCO ************************************************************
+*                                                                      *
+*     Force partitioning for contracted functions
+*
+ 9764 Continue
+      force_part_c=.True.
+      Go To 998
+*                                                                      *
+****** FPPR ************************************************************
+*                                                                      *
+*     Force partitioning for primitive functions
+*
+ 9765 Continue
+      force_part_p=.True.
+      Go To 998
+*                                                                      *
+****** NOTA ************************************************************
+*                                                                      *
+*     Do not use tables for the roots and weights of the
+*     Rys polynomials.
+*
+ 980  NoTab = .TRUE.
+      Go To 998
+*                                                                      *
+****** WELL ************************************************************
+*                                                                      *
+*-----Read radius and exponents for spherical well integrals
+*     and coefficient
+*
+ 986  KWord = Get_Ln(LuRd)
+      GWInput=.True.
+      Call Get_I(1,nWel,1)
+*---- Get pointer to the next free space in dynamic memory
+      ipWel=ipExp(iShll+1)
+      ipW = ipWel
+      If (nWel.le.0) Then
+*--------Use automatic set up for well integrals
+         nWel=3
+         Do iWel = 1, nWel
+            Work(ipW+2)=WellCff(iWel)
+            Work(ipW+1)=WellExp(iWel)
+            Work(ipW  )=WellRad(iWel)
+            ipW = ipW + 3
+         End Do
+      Else
+         Do iWel = 1, nWel
+*---------- Read the Coefficient, Exponent, and Radius
+            KWord = Get_Ln(LuRd)
+            call Get_F(1,Work(ipW+2),1)
+            call Get_F(2,Work(ipW+1),1)
+            call Get_F(3,Work(ipW  ),1)
+            If (Index(KWord,'ANGSTROM').ne.0) Then
+               Work(ipW)=Work(ipW)/angstr
+               Work(ipW+1)=Work(ipW+1)*angstr
+            End If
+            ipW = ipW + 3
+         End Do
+      End If
+*---- Update pointer to the next free space in dynamic memory
+      ipExp(iShll+1)=ipW
+      nInfo = nInfo + nWel*3
+      Go To 998
+*                                                                      *
+****** NODK ************************************************************
+*                                                                      *
+*     Do not compute Douglas-Kroll integrals.
+*
+ 989  NoDKroll = .TRUE.
+      Go To 998
+*                                                                      *
+****** ONEO ************************************************************
+*                                                                      *
+*     Do not compute two electron integrals.
+*
+ 990  Onenly = .TRUE.
+      Go To 998
+*                                                                      *
+****** TEST ************************************************************
+*                                                                      *
+*     Process only the input.
+*
+ 991  Test = .TRUE.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** SDIP ************************************************************
+*                                                                      *
+*     Compute integrals for transition dipole moment
+*
+ 992  Vlct = .TRUE.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** EPOT ************************************************************
+*                                                                      *
+*     Compute the electric potential for a number of points.  If nEF is
+*     set to 0 this will cause the points to coincide with the unique
+*     centers.
+*
+ 9932 nOrdEF=Max(nOrdEF,0)
+      GWInput=.True.
+      IF (EFgiven) Then
+        Call WarningMessage(2,'Only one of EPOT,EFLD,FLDG may be given')
+        Call Quit_OnUserError()
+      End If
+      EFgiven=.True.
+      Go To 9931
+*                                                                      *
+****** EFLD ************************************************************
+*                                                                      *
+*     Compute the electric potential and electric field for a number of
+*     points. If nEF is set to 0 this will cause the points to coincide
+*     with the unique centers.
+*
+ 993  nOrdEF=Max(nOrdEF,1)
+      GWInput=.True.
+      IF (EFgiven) Then
+        Call WarningMessage(2,'Only one of EPOT,EFLD,FLDG may be given')
+        Call Quit_OnUserError()
+      End If
+      EFgiven=.True.
+      Go To 9931
+*                                                                      *
+****** FLDG ************************************************************
+*                                                                      *
+*     Compute the electric potential, electric field, and electric field
+*     gradient for a number of points. If nEF is set to 0 this will
+*     cause the points to coincide with the Unique centers.
+*
+ 994  nOrdEF=Max(nOrdEF,2)
+      GWInput=.True.
+      IF (EFgiven) Then
+        Call WarningMessage(2,'Only one of EPOT,EFLD,FLDG may be given')
+        Call Quit_OnUserError()
+      End If
+      EFgiven=.True.
+      Go To 9931
+*
+ 9931 KWord = Get_Ln(LuRd)
+      Call Get_I(1,nEF,1)
+      If (nEF.lt.0) nEF = 0
+      If (nEF.eq.0) Go To 998
+      Call mma_allocate(EFt,3,nEF,label='nEF')
+      Do iEF = 1, nEF
+         KWord = Get_Ln(LuRd)
+* Check whether a label is specified instead of a coordinate
+         Call Get_S(1,Key,1)
+         Call LeftAd(Key)
+         Call Upcase(Key)
+         jTmp = iChar(Key(1:1))
+         If (jTmp .ge. 65 .AND. jTmp .le. 90) Then
+            iEnd=Index(Key,' ')-1
+            iOff = 0
+            iFound_Label = 0
+            Do iCnttp = 1, nCnttp
+               iStrt = ipCntr(iCnttp)
+               Do iCnt = iOff+1, iOff+nCntr(iCnttp)
+                  If (Key(1:iEnd) .Eq. LblCnt(iCnt)(1:iEnd)) Then
+                     iFound_Label = 1
+                     Do I = 1,3
+                        EFt(I,iEF) = Work(iStrt+I-1)
+                     End Do
+                  End If
+                  iStrt = iStrt + 3
+               End Do
+               iOff = iOff + nCntr(iCnttp)
+            End Do
+            If (iFound_Label .Eq. 0) Then
+               Call WarningMessage(2,';'
+     &                     //' Error in processing the keyword FLDG.;'
+     &                     //' The label '''//Key(1:iEnd)
+     &                  //''' could not be found among the centers.;'
+     &                     //' Remember to specify the atom center'
+     &                     //' before specifying the FLDG keyword.')
+               Call Quit_OnUserError()
+            End If
+         Else
+            Call Get_F(1,EFt(1,iEF),3)
+            If (Index(KWord,'ANGSTROM').ne.0)
+     &         Call DScal_(3,One/angstr,EFt(1,iEF),1)
+         End If
+      End Do
+      Go To 998
+*                                                                      *
+****** ANGM ************************************************************
+*                                                                      *
+*     Orbital angular momentum
+*
+ 995  lOAM = .True.
+      GWInput=.True.
+      Call mma_allocate(OAMt,3,label='OAMt')
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,OAMt,3)
+      If (Index(KWord,'ANGSTROM').ne.0)
+     &    Call DScal_(3,One/angstr,OAMt,1)
+      Go To 998
+*                                                                      *
+****** ANGM derivative restriction *************************************
+*                                                                      *
+*     Orbital angular momentum restriction
+*
+ 1001 lUPONLY = .True.
+      Go To 998
+*
+ 1002 lDOWNONLY = .True.
+      Go To 998
+*                                                                      *
+****** OMQ *************************************************************
+*                                                                      *
+*     Orbital angular momentum
+*
+ 999  lOMQ = .True.
+      GWInput=.True.
+      Call mma_allocate(OMQt,3,label='OMQt')
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,OMQt,3)
+      If (Index(KWord,'ANGSTROM').ne.0)
+     &    Call DScal_(3,One/angstr,OMQt,1)
+      Go To 998
+*                                                                      *
+****** AMPR ************************************************************
+*                                                                      *
+*     Angular momentum products
+*
+ 9951 lAMP = .True.
+      GWInput=.True.
+      If (Run_Mode.eq.S_Mode.and.GWInput) Go To 9989
+      ipAMP=ipExp(iShll+1)
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,Work(ipAMP),3)
+      If (Index(KWord,'ANGSTROM').ne.0)
+     &     Call DScal_(3,One/angstr,
+     &       Work(ipAMP),1)
+      ipExp(iShll+1)=ipAMP+3
+      nInfo = nInfo + 3
+      Go To 998
+*                                                                      *
+****** DSHD ************************************************************
+*                                                                      *
+*     Compute the diamagnetic shielding for a number of points. If nDMS
+*     is set to 0 this will cause the points to coincide with the
+*     unique centers.
+*
+ 996  lDMS = .True.
+      GWInput=.True.
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,Dxyz,3)
+      KWord = Get_Ln(LuRd)
+      Call Get_I(1,nDMS,1)
+      If (nDMS.lt.0) nDMS = 0
+      If (nDMS.eq.0) Go To 998
+      Call mma_allocate(DMSt,3,nDMS,label='DMSt')
+      Do iDMS = 1, nDMS
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,DMSt(1,iDMS),3)
+         If (Index(KWord,'ANGSTROM').ne.0)
+     &        Call DScal_(3,One/angstr,DMSt(1,iDMS),1)
+      End Do
+      Go To 998
+*                                                                      *
+****** NOPA ************************************************************
+*                                                                      *
+*     Set integral packing flag
+*     Note      : this flag is only active if iWRopt=0
+*     iPack=0   : pack 2el integrals (= Default)
+*     iPack=1   : do not pack 2el integrals
+*
+ 9910 iPack=1
+      Go To 998
+*                                                                      *
+****** SQUA ************************************************************
+*                                                                      *
+*     Set integral ordering flag
+*     Note      : this flag is only active if iWRopt=0
+*     iSquar=0  : diagonal and sub diagonal symmetry blocks of
+*                 2el integrals are stored, only (= Default)
+*     iSquar=1  : All symmetry blocks of 2el integrals with
+*                 iSym.ge.jSym and kSym.ge.lSym are stored
+*
+ 9920 Write (LuWr,*) 'The SQUARE option is obsolete and is ignored!'
+      Go To 998
+*                                                                      *
+****** STDO ************************************************************
+*                                                                      *
+*     Set integral write option for 2 el integrals
+*     iWRopt=0  : 2 el integrals are written in the MOLCAS2 format,
+*                 i.e., in canonical order, no labels and packed format
+*                 (= Default)
+*     iWRopt=1  : 2 el integrals are written in a format identical
+*                 to MOLECULE, i.e., values and labels
+*
+ 9930 iWRopt=1
+      Go To 998
+*                                                                      *
+****** PKTH ************************************************************
+*                                                                      *
+*     Read desired packing accuracy ( Default = 1.0D-14 )
+*     Note      : this flag is only active if iWRopt=0
+*
+ 9940 KWord = Get_Ln(LuRd)
+      Call Get_F(1,PkAcc,1)
+      PkAcc = Abs(PkAcc)
+      Go To 998
+*                                                                      *
+****** SKIP ************************************************************
+*                                                                      *
+*     Read skip parameters,i.e.,
+*     if 2el integral symmetry blocks containing a given symmetry
+*     will not be needed in subsequent calculations their computation
+*     ans storage can be omitted.
+*     ( Default = 0,0,0,0,0,0,0,0 )
+*     Note      : this flag is only activ if iWRopt=0
+*
+ 9950 KWord = Get_Ln(LuRd)
+      lSkip = .True.
+      ChSkip = KWord(1:80)
+      Go To 998
+*                                                                      *
+****** EXTR ************************************************************
+*                                                                      *
+*     Put the program name and the time stamp onto the extract file
+*
+c23456789012345678901234567890123456789012345678901234567890123456789012
+ 9960 Write (LuWr,*)'RdCtl: keyword EXTRACT is obsolete and is ignored!'
+      Go To 998
+*                                                                      *
+****** REAC ************************************************************
+*                                                                      *
+*     Read reaction field input.
+*
+ 9970 Continue
+      GWInput=.True.
+      If (.Not.RF_read) Then
+         Call InpRct(LuRd)
+         If (lLangevin.or.PCM) Go To 9971
+*
+*------- Add a center corresponding to the center of the RF cavity.
+*
+         RF_read=.True.
+ 9971    Continue
+*
+      Else
+         Call WarningMessage(2,
+     &                  'RdCtl: A second RF-input block discovered!')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+*                                                                      *
+***** GRID *************************************************************
+*                                                                      *
+ 9773 Continue
+      Call Funi_input(LuRd)
+      Go To 998
+*                                                                      *
+****** CLIG ************************************************************
+*                                                                      *
+*     Speed of light (in au)
+*
+ 9000 KWord = Get_Ln(LuRd)
+      Call Get_F(1,CLight,1)
+      CLight = Abs(CLight)
+      write(LuWr,*)'The speed of light in this calculation =', CLight
+      Go To 998
+*                                                                      *
+***** NEMO *************************************************************
+*                                                                      *
+ 800  Continue
+      NEMO=.True.
+      Go To 998
+*                                                                      *
+***** RMAT *************************************************************
+*                                                                      *
+*     RmatR    : radius of the R-matrix sphere (bohr)
+*
+ 880  KWord = Get_Ln(LuRd)
+      Call Get_F(1,RMatR,1)
+      Go To 998
+*                                                                      *
+***** RMEA *************************************************************
+*                                                                      *
+*     Epsabs   : absolute precision of numerical radial integration
+*
+ 881  KWord = Get_Ln(LuRd)
+      Call Get_F(1,Epsabs,1)
+      Go To 998
+*                                                                      *
+***** RMER *************************************************************
+*                                                                      *
+*     Epsrel   : relative precision of numerical radial integration
+*
+ 882  KWord = Get_Ln(LuRd)
+      Call Get_F(1,Epsrel,1)
+      Go To 998
+*                                                                      *
+***** RMQC *************************************************************
+*                                                                      *
+*     qCoul    : effective charge of the target molecule
+*
+ 883  KWord = Get_Ln(LuRd)
+      Call Get_F(1,qCoul,1)
+      Go To 998
+*                                                                      *
+***** RMDI *************************************************************
+*                                                                      *
+*     dipol(3) : effective dipole moment of the target molecule
+*
+ 884  KWord = Get_Ln(LuRd)
+      Call Get_F(1,dipol,3)
+      dipol1=Abs(dipol(1))+Abs(dipol(2))+Abs(dipol(3))
+      Go To 998
+*                                                                      *
+***** RMEQ *************************************************************
+*                                                                      *
+*     epsq     : minimal value of qCoul and/or dipol1 to be considered
+*
+ 885  KWord = Get_Ln(LuRd)
+      Call Get_F(1,epsq,1)
+      Go To 998
+*                                                                      *
+***** RMBP *************************************************************
+*                                                                      *
+*     bParm    : Bloch term parameter
+*
+ 886  KWord = Get_Ln(LuRd)
+      Call Get_F(1,bParm,1)
+      Go To 998
+*                                                                      *
+***** GIAO *************************************************************
+*                                                                      *
+*     Enable GIAO integrals.
+*
+ 9020 GIAO=.True.
+      Go To 998
+*                                                                      *
+***** NOCH *************************************************************
+*                                                                      *
+*     Deactivate Cholesky decomposition.
+*
+ 9089 Continue
+      Cholesky=.False.
+      CholeskyWasSet=.True.
+      Do_RI=.False.
+      Go To 998
+*                                                                      *
+***** CHOL *************************************************************
+*                                                                      *
+*     Activate Cholesky decomposition with default settings.
+*     This section can only be executed once.
+*
+ 9091 Continue
+      Do_RI=.False.
+      If (.not. CholeskyWasSet) Then
+         CholeskyWasSet=.True.
+         Cholesky=.True.
+         Do_RI=.False.
+         DirInt = .True.
+         Call Cho_Inp(.True.,-1,6)
+         iChk_CH=1
+      End If
+      If ( (iChk_RI+iChk_DC) .gt. 0) Then
+         Call WarningMessage(2,
+     &           'Cholesky is incompatible with RI and Direct keywords')
+         Call Quit_OnUserError()
+      EndIf
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*                                                                      *
+***** THRC *************************************************************
+*                                                                      *
+*     Set Cholesky decomposition threshold to specified value.
+*
+ 9021 Continue
+      KWord=Get_Ln(LuRd)
+      Call Get_F(1,CholeskyThr,1)
+      Go To 998
+*                                                                      *
+***** 1CCD *************************************************************
+*                                                                      *
+*     Use one-center Cholesky.
+*
+ 9022 Continue
+      do1CCD=.true.
+      Do_RI=.False.
+      iChk_Ch=1
+      If ( (iChk_RI+iChk_DC) .gt. 0) Then
+         Call WarningMessage(2,
+     &           'Cholesky is incompatible with RI and Direct keywords')
+         Call Quit_OnUserError()
+      EndIf
+      Go To 998
+*                                                                      *
+***** CHOI *************************************************************
+*                                                                      *
+*     Activate Cholesky decomposition with user-defined settings.
+*     This section can be executed any number of times.
+*     User-defined settings will be preferred to defaults also if the
+*     keywords appear in "wrong" order,
+*
+*     ChoInput
+*     ...
+*     End ChoInput
+*     Cholesky
+*
+ 9092 Continue
+      Do_RI=.False.
+      CholeskyWasSet=.True.
+      Cholesky=.True.
+      DirInt = .True.
+      Call Cho_Inp(.False.,LuRd,6)
+      iChk_CH=1
+      If ( (iChk_RI+iChk_DC) .gt. 0) Then
+         Call WarningMessage(2,
+     &           'Cholesky is incompatible with RI and Direct keywords')
+         Call Quit_OnUserError()
+      EndIf
+      Go To 998
+*                                                                      *
+***** RP-C *************************************************************
+*                                                                      *
+ 9093 lRP=.True.
+      KWord = Get_Ln(LuRd)
+      jTmp=0
+      nRP_prev=-1
+      Read(KWord,*,err=9082) nRP
+      isnumber=1
+      ifile=index(KWord,' ')
+      do i=1,ifile
+        ii=index(' 0123456789',KWord(i:i))
+        if(ii.eq.0) then
+           isnumber=0
+        endif
+      enddo
+      if(isnumber.eq.0) goto 9082
+*
+**    Inline input
+*
+      Call UpCase(KWord)
+      If (Index(KWord,'ANGSTROM').ne.0) Then
+         Fact=One/Angstr
+      Else
+         Fact=One
+      End If
+      nRP=3*nRP
+      ipRP1=ipExp(iShll+1)
+      nInfo=nInfo + 2*nRP
+      ipExp(iShll+1)=ipRP1 + 2*nRP
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,E1,1)
+      Call Read_v(LuRd,Work(ipRP1),1,nRP,1,iErr)
+      Call DScal_(nRP,Fact,Work(ipRP1    ),1)
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,E2,1)
+      Call Read_v(LuRd,Work(ipRP1+nRP),1,nRP,1,iErr)
+      Call DScal_(nRP,Fact,Work(ipRP1+nRP),1)
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*
+**    Files
+*
+ 9082 Continue
+      RPSet=.true.
+      jTmp=jTmp+1
+      ifile=index(KWord,' ')
+      If(KWord(1:1).eq.'/') then
+        call f_inquire(KWord(1:ifile-1),Exist)
+        Key=KWord
+      Else
+        call getenvf('MOLCAS_SUBMIT_DIR',Directory)
+        if(Directory(1:1).ne.' ') then
+          i=index(Directory,' ')
+          Key=Directory(1:i-1)//'/'//KWord(1:ifile-1)
+          ifile=i+ifile
+          call f_inquire(Key(1:iFile-1),Exist)
+        Else
+          Exist=.false.
+        End If
+        If (.not.Exist) Then
+          Key=Key(i+1:iFile-1)
+          ifile=ifile-i
+          call f_inquire(Key(1:iFile-1),Exist)
+        End If
+      End If
+      If (.not.Exist) Then
+        Call WarningMessage(2,'File '//
+     &                            Key(1:ifile)//' is not found')
+        Call Quit_OnUserError()
+      End If
+      LuIn=8
+      LuIn=isFreeUnit(LuIn)
+      call molcas_open(LuIn,Key(1:iFile-1))
+*
+      KWord = Get_Ln(LuIn)
+      Read(KWord,*,err=9083) nRP
+      If (nRP_prev.ge.0 .and. nRP.ne.nRP_prev) Then
+        Call WarningMessage(2,'The numbers of atoms in the two RP'//
+     &                        ' structures do not match.')
+        Call Quit_OnUserError()
+      End IF
+      nRP_prev=nRP
+      nRP=3*nRP
+      KWord = Get_Ln(LuIn)
+      Call UpCase(KWord)
+      If (Index(KWord,'BOHR').ne.0) Then
+         Fact=One
+      Else
+         Fact=One/Angstr
+      End If
+      If (jTmp.eq.1) Then
+         LuRP=10
+         LuRP=isFreeUnit(LuRP)
+         call molcas_open(LuRP,'findsym.RP1')
+         ipRP1=ipExp(iShll+1)
+         nInfo=nInfo + 2*nRP
+         ipExp(iShll+1)=ipRP1 + 2*nRP
+         Read(KWord,*,err=9083) E1
+*
+**  write a separate file for findsym
+*
+         Write(LuRP,*) nRP/3
+         Write(LuRP,'(a)')
+         Do i=1,nRP/3
+            KWord = Get_Ln(LuIn)
+            Read(KWord,*,err=9083) Key,(Work(ipRP1+3*(i-1)+j),j=0,2)
+            Write(LuRP,'(A,3F20.12)') Key(1:LENIN),
+     &                   (Work(ipRP1+3*(i-1)+j)*Fact,j=0,2)
+         End Do
+         Call DScal_(nRP,Fact,Work(ipRP1    ),1)
+         KWord = Get_Ln(LuRd)
+         close(LuIn)
+         close(LuRP)
+         Go To 9082
+      Else
+         LuRP=10
+         LuRP=isFreeUnit(LuRP)
+         call molcas_open(LuRP,'findsym.RP2')
+         Write(LuRP,*) nRP/3
+         Write(LuRP,'(a)')
+         Read(KWord,*,err=9083) E2
+         Do i=1,nRP/3
+            KWord = Get_Ln(LuIn)
+            Read(KWord,*,err=9083) Key,(Work(ipRP1+nRP+3*(i-1)+j),j=0,2)
+            Write(LuRP,'(A,3F20.12)') Key(1:LENIN),
+     &            (Work(ipRP1+nRP+3*(i-1)+j)*Fact,j=0,2)
+         End Do
+         Call DScal_(nRP,Fact,Work(ipRP1+nRP),1)
+         close(LuRP)
+      End If
+*
+      close(LuIn)
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*
+**    Error
+*
+ 9083 Continue
+      Write(6,'(a,a)') 'Error reading from file ',Key(1:iFile-1)
+      Write(6,'(a,a)') 'unable to process line: ',KWord
+      Call Quit_OnUserError()
+*                                                                      *
+***** SADD *************************************************************
+*                                                                      *
+*     Saddle options
+ 9081 Key = Get_Ln(LuRd)
+      Call Get_F(1,SadStep,1)
+      GWInput = Run_Mode.eq.G_Mode
+      Go To 998
+*                                                                      *
+***** CELL *************************************************************
+*                                                                      *
+*     VCell(3,3)    : the vectors of the cell
+*
+ 887  Key = Get_Ln(LuRd)
+      Call Upcase(Key)
+      If (Index(Key,'ANGSTROM').ne.0) KWord = Get_Ln(LuRd)
+      Call Get_F(1,VCell(1,1),3)
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,VCell(1,2),3)
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,VCell(1,3),3)
+      If (Index(Key,'ANGSTROM').ne.0) Call DScal_(9,One/angstr,VCell,1)
+      Cell_l = .TRUE.
+      Call mma_allocate(AdCell,MxAtom)
+      Go To 998
+*                                                                      *
+***** SPAN *************************************************************
+*                                                                      *
+*     Set span factor in Cholesky decomposition (0 < span < 1).
+*     The span decides the smallest diagonal element that can be
+*     treated as span*max(Diag). Span=1 thus implies full pivoting.
+*
+ 890  Continue
+      KWord = Get_Ln(LuRd)
+      Call Get_F(1,spanCD,1)
+      spanCD(1)=abs(spanCD(1))
+      Go To 998
+*                                                                      *
+***** SPREAD ***********************************************************
+*                                                                      *
+*     ispread(3)    : the number of cells to spread in different directions
+*
+ 889  KWord = Get_Ln(LuRd)
+      Call Get_I(1,ispread,3)
+      Go To 998
+*                                                                      *
+***** LOW  *************************************************************
+*                                                                      *
+*     Activate low-accuracy Cholesky decomposition.
+*
+ 9094 Continue
+      Do_RI=.False.
+      If (.not. CholeskyWasSet) Then
+         CholeskyWasSet=.True.
+         Cholesky=.True.
+         DirInt = .True.
+         Call Cho_Inp(.True.,-1,6)
+         Call Cho_InpMod('LOW ')
+         Thrshld_CD=1.0D-4
+      End If
+      Go To 998
+*                                                                      *
+***** MEDI *************************************************************
+*                                                                      *
+*     Activate medium-accuracy Cholesky decomposition.
+*
+ 9095 Continue
+      Do_RI=.False.
+      If (.not. CholeskyWasSet) Then
+         CholeskyWasSet=.True.
+         Cholesky=.True.
+         DirInt = .True.
+         Call Cho_Inp(.True.,-1,6)
+         Call Cho_InpMod('MEDI')
+         Thrshld_CD=1.0D-6
+      End If
+      Go To 998
+*                                                                      *
+***** HIGH *************************************************************
+*                                                                      *
+*     Activate high-accuracy Cholesky decomposition.
+*
+ 9096 Continue
+      Do_RI=.False.
+      If (.not. CholeskyWasSet) Then
+         CholeskyWasSet=.True.
+         Cholesky=.True.
+         DirInt = .True.
+         Call Cho_Inp(.True.,-1,6)
+         Call Cho_InpMod('HIGH')
+         Thrshld_CD=1.0D-8
+      End If
+      Go To 998
+*                                                                      *
+***** DIAG *************************************************************
+*                                                                      *
+ 9087 Continue
+      DiagCheck=.true.
+      Go To 998
+*                                                                      *
+***** RI   *************************************************************
+*                                                                      *
+*     Active RI approach
+*
+ 9097 Continue
+      Do_RI=.True.
+      GWInput=.True.
+      iRI_Type=3
+      iChk_RI=1
+      If ( (iChk_DC+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &          'RI is incompatible with Direct and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+ 9098 Continue
+      Do_RI=.True.
+      GWInput=.True.
+      iRI_Type=1
+      iChk_RI=1
+      If ( (iChk_DC+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &          'RI is incompatible with Direct and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+ 9099 Continue
+      Do_RI=.True.
+      GWInput=.True.
+      iRI_Type=2
+      iChk_RI=1
+      If ( (iChk_DC+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &          'RI is incompatible with Direct and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+ 9080 Continue
+      Do_RI=.True.
+      GWInput=.True.
+      iRI_Type=4
+      iChk_RI=1
+      If ( (iChk_DC+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &          'RI is incompatible with Direct and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+ 9085 Continue
+      Do_RI=.True.
+      GWInput=.True.
+      iRI_Type=5
+      iChk_RI=1
+      If ( (iChk_DC+iChk_CH) .gt. 0) Then
+         Call WarningMessage(2,
+     &          'RI is incompatible with Direct and Cholesky keywords')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+*                                                                      *
+***** NOGU *************************************************************
+*                                                                      *
+*     Disable atomatic execution of GuessOrb
+*
+ 9100 Do_GuessOrb=.FALSE.
+      Go To 998
+*                                                                      *
+***** Rxxyzz ***********************************************************
+*                                                                      *
+*     DKH option: order and parameterization.
+*     xx: order of Hamiltonian
+*      y: parameterization
+*     zz: order of properties
+*
+ 657  Continue
+      DKroll=.True.
+*
+*     DKH order in the Hamiltonian
+*
+      read( KWord(2:3), * ) idk_ord
+      IRELAE = 1000 + idk_ord * 10
+*
+*     Method of parametrization
+*
+      If (kWord(4:4).eq.'O') IRELAE=IRELAE+1
+      If (kWord(4:4).eq.'E') IRELAE=IRELAE+2
+      If (kWord(4:4).eq.'S') IRELAE=IRELAE+3
+      If (kWord(4:4).eq.'M') IRELAE=IRELAE+4
+      If (kWord(4:4).eq.'C') IRELAE=IRELAE+5
+*
+*     DKH order in the property integrals
+*
+      If ( KWord(5:5).ge.'0' .and.
+     &     KWord(5:5).le.'9' .and.
+     &     KWord(6:6).ge.'0' .and.
+     &     KWord(6:6).le.'9' ) then
+        read( KWord(5:6), * ) iprop_ord
+          IRELAE = IRELAE + iprop_ord * 10000
+      Else
+          IRELAE = IRELAE + idk_ord * 10000
+      End If
+*
+      Go To 998
+*                                                                      *
+***** LDKH *************************************************************
+*                                                                      *
+*     Local Douglas-Kroll-Hess/X2C/BSS
+*
+ 658  If (SymmSet.or.nIrrep.gt.1) Then
+         Call WarningMessage(2,
+     &      'Local approach is not yet implemented with SYMMETRY')
+         Call Quit_OnUserError()
+      End If
+      LDKroll=.True.
+*     GWInput=.True.
+      nCtrLD=0
+      radiLD=5.5d0
+*
+      KWord = Get_Ln(LuRd)
+      Call Upcase(KWord)
+      If (KWord(1:3).eq.'DLU') Go To 998
+      If (KWord(1:3).eq.'DLH') Then
+        radiLD=0.0d0
+        Go To 998
+      End If
+      read(KWord,*,end=6582, err=6582) nCtrLD, radiLD
+      If (nCtrLD.gt.10) Then
+         Call WarningMessage(2,
+     &           'The number of centers for LDKH is limited to 10')
+         call Quit_OnUserError()
+      End If
+      If (Index(KWord,'ANGSTROM').ne.0) Then
+          radiLD = radiLD/angstr
+      End If
+*
+      KWord = Get_Ln(LuRd)
+      Call Upcase(KWord)
+      read(KWord,*,end=6666, err=6581) (iCtrLD(i),i=1,nCtrLD)
+      Go To 998
+ 6581 read(Kword,*,end=6666, err=6666) (CtrLDK(i),i=1,nCtrLD)
+      Call Get_nAtoms_all(nAtom)
+      k=0
+      Do i=1,nAtom
+        Do j=1,nCtrLD
+          if (CtrLDK(j).eq.LblCnt(i)(1:LENIN)) Then
+             iCtrLD(j)=i
+             k=k+1
+          End If
+        End Do
+      End Do
+      If (k.ne.nCtrLD) Then
+         Call WarningMessage(2,'Error in LDKH Centers definitions')
+         Call Quit_OnUserError()
+      End If
+      Go To 998
+*
+**    Automatic choice: all heavy elements (from K 19)
+*
+ 6582 Continue
+CDP      If (nCtrLD.eq.0) radiLD=0.0d0
+      Key=KWord
+      Go To 9989
+*                                                                      *
+***** FOOC *************************************************************
+*                                                                      *
+*     Force the use of the out-of-core RI algorithm.
+*
+ 8000 Force_Out_of_Core=.True.
+      Go To 998
+*                                                                      *
+***** CDTH *************************************************************
+*                                                                      *
+*     Threshold for CD to generate RICD auxiliary basis sets
+*
+ 8001 Key = Get_Ln(LuRd)
+      Call Get_F(1,Thrshld_CD,1)
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** SHAC *************************************************************
+*                                                                      *
+*     Skip high angular combinations when constructing RICD aux basis.
+*
+ 8002 Skip_High_AC=.True.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** KHAC *************************************************************
+*                                                                      *
+*     Keep high angular combinations when constructing RICD aux basis.
+*
+ 8003 Skip_High_AC=.False.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** ACD  *************************************************************
+*                                                                      *
+*     Generate a aCD basis.
+*
+ 8004 Do_acCD_Basis=.False.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** ACCD *************************************************************
+*                                                                      *
+*     Generate a acCD basis.
+*
+ 8005 Do_acCD_Basis=.True.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** NACC *************************************************************
+*                                                                      *
+*     Generate a nacCD basis.
+*
+ 8030 Do_acCD_Basis=.False.
+      Do_nacCD_Basis=.True.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** DOFM *************************************************************
+*                                                                      *
+*     DoFMM: activate FMM option
+*
+ 8006 DoFMM = .True.
+      Go To 998
+*                                                                      *
+***** NOAM *************************************************************
+*                                                                      *
+*     No computation of AMFI integrals
+*
+ 8007 NoAMFI=.True.
+      Go To 998
+*                                                                      *
+***** RPQM *************************************************************
+*                                                                      *
+*     Set RPQMin for FMM option
+*
+ 8008 Key = Get_Ln(LuRd)
+      Call Get_F(1,RPQMin,1)
+      Go To 998
+*                                                                      *
+***** CONS *************************************************************
+*                                                                      *
+*     Have the Gateway read the constraints for Slapaf
+*
+ 8010 Continue
+      GWInput=.True.
+      Lu_UDC=97
+      Lu_UDC = IsFreeUnit(Lu_UDC)
+      Call Molcas_Open(Lu_UDC,'UDC.Gateway')
+ 8011 Continue
+         Key=Get_Ln(LuRd)
+         Call UpCase(Key)
+         Write (Lu_UDC,'(A)') Trim(Key)
+         If (Key(1:4).ne.'END ') Go To 8011
+*     This rather obscure feature seems to be needed to to make Intel
+*     compilers behave like the others when detecting EOF
+      End File(Lu_UDC)
+      Close(Lu_UDC)
+      Go To 998
+*                                                                      *
+***** NGEX *************************************************************
+*                                                                      *
+*     Have the Gateway read the constraints for Numerical_gradient
+*
+  501 Continue
+      GWInput=.True.
+      Lu_UDC=97
+      Lu_UDC = IsFreeUnit(Lu_UDC)
+      Call Molcas_Open(Lu_UDC,'UDC.NG')
+  502 Continue
+         Key=Get_Ln(LuRd)
+         Call UpCase(Key)
+         If (AdjustL(Key).eq.'INVERT') Then
+            Invert=.True.
+            Go To 502
+         End If
+         Write (Lu_UDC,'(A)') Trim(Key)
+         If (Key(1:4).ne.'END ') Go To 502
+*     This rather obscure feature seems to be needed to to make Intel
+*     compilers behave like the others when detecting EOF
+      End File(Lu_UDC)
+      Close(Lu_UDC)
+      Go To 998
+*                                                                      *
+***** LOCA or LDF1 or LDF **********************************************
+*                                                                      *
+*     Activate Local Density Fitting.
+*
+   35 Continue
+         LocalDF=.True.
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** LDF2 *************************************************************
+*                                                                      *
+*     Activate Local Density Fitting with 2-center functions included
+*     when needed to achieve target accuracy.
+*
+   36 Continue
+         LocalDF=.True.
+         Call LDF_SetLDF2(.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** TARG or THRL *****************************************************
+*                                                                      *
+*     Set target accuracy for Local Density Fitting.
+*     This implies inclusion of 2-center functions (the only way we can
+*     affect accuracy).
+*
+   37 Continue
+         Key=Get_Ln(LuRd)
+         Call Get_F(1,Target_Accuracy,1)
+         Call LDF_SetThrs(Target_Accuracy)
+         LocalDF=.True.
+         Call LDF_SetLDF2(.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** APTH *************************************************************
+*                                                                      *
+*     Set screening threshold for LDF - i.e. threshold for defining
+*     significant atom pairs.
+*
+   38 Continue
+         Key=Get_Ln(LuRd)
+         Call Get_F(1,APThr,1)
+         Call LDF_SetPrescreen(APThr)
+         LocalDF=.True.
+         APThr_UsrDef=.True.
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** CHEC *************************************************************
+*                                                                      *
+*     LDF debug option: check pair integrals.
+*
+   39 Continue
+         Call LDF_SetOptionFlag('CHEC',.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** VERI *************************************************************
+*                                                                      *
+*     LDF debug option: verify fit for each atom pair.
+*
+   40 Continue
+         Call LDF_SetOptionFlag('VERI',.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** OVER *************************************************************
+*                                                                      *
+*     LDF debug option: check overlap integrals (i.e. charge)
+*
+   41 Continue
+         Call LDF_SetOptionFlag('OVER',.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** CLDF *************************************************************
+*                                                                      *
+*     Constrained LDF - read constraint order
+*     order=-1 --- unconstrained
+*     order=0  --- charge (i.e. overlap)
+*
+   42 Continue
+         Key=Get_Ln(LuRd)
+         Call Get_I(1,iCLDF,1)
+         Call LDF_AddConstraint(iCLDF)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** UNCO *************************************************************
+*                                                                      *
+*     Unconstrained LDF (same as CLDF=-1)
+*
+   43 Continue
+         Call LDF_AddConstraint(-1)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** WRUC *************************************************************
+*                                                                      *
+*     Write unconstrained coefficients to disk.
+*     Only meaningful along with constrained fitting.
+*     For debugging purposes: enables constrained fit verification in
+*     modules other than Seward.
+*
+   44 Continue
+         Call LDF_SetOptionFlag('WRUC',.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** UNIQ *************************************************************
+*                                                                      *
+*     LDF: use unique atom pairs.
+*
+   45 Continue
+         Call LDF_SetOptionFlag('UNIQ',.True.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** NOUN *************************************************************
+*                                                                      *
+*     LDF: do not use unique atom pairs.
+*
+   46 Continue
+         Call LDF_SetOptionFlag('UNIQ',.False.)
+         GWInput=.False. ! Only in Seward
+      Go To 998
+*                                                                      *
+***** RLDF *************************************************************
+*                                                                      *
+*     Activate local DF/RI, Roland's original LDF test implementation
+*
+ 8012 LDF=.True.
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** NOAL *************************************************************
+*                                                                      *
+*     Do not align reactants and products
+*
+ 7013 Do_Align=.False.
+      If (Align_Only) Then
+         Call WarningMessage(2,
+     &       'Keywords ALIG and NOAL are not compatible')
+         Call Quit_OnUserError()
+      End If
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** WEIG *************************************************************
+*                                                                      *
+*     Weights for alignment of reactants and products
+*
+ 7014 Align_Weights=Get_Ln(LuRd)
+      Call UpCase(Align_Weights)
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+***** ALIG *************************************************************
+*                                                                      *
+*     Align reactants and products
+*
+ 8013 Align_Only=.True.
+      If (.not.Do_Align) Then
+         Call WarningMessage(2,
+     &       'Keywords ALIG and NOAL are not compatible')
+         Call Quit_OnUserError()
+      End If
+      GWInput=.True.
+      Go To 998
+*                                                                      *
+****** TINK ************************************************************
+*                                                                      *
+*     Read Coordinates in Tinker's xyz format
+*
+8014  If (SymmSet) Then
+         Call WarningMessage(2,
+     &                 'SYMMETRY keyword is not compatible with TINKER')
+         Call Quit_OnUserError()
+      End If
+      DoTinker = .True.
+      If (MyRank.eq.0) Then
+        ITkQMMM = 1
+        ITkQMMM = IsFreeUnit(ITkQMMM)
+        Call Molcas_Open (ITkQMMM,'QMMM')
+        Write(ITkQMMM,'(A)') 'Molcas -1 0'
+        Close (ITkQMMM)
+c
+        Call Getenvf('TINKER ',Key)
+        mLine = Len(Key)
+        iLast = iCLast(Key,mLine)
+        if (iLast.eq.0) Then
+          Call Getenvf('MOLCAS',Key)
+          mLine = Len(Key)
+          iLast = iCLast(Key,mLine)
+          Key = Key(1:iLast)//'/tinker/bin'
+        End If
+        iLast = iCLast(Key,mLine)
+        Call Getenvf('Project',Project)
+        mLine = Len(Project)
+        jLast = iCLast(Project,mLine)
+        Key = Key(1:iLast)//'/tkr2qm_s '//Project(1:jLast)//'.xyz'//
+     &                 '>'//Project(1:jLast)//'.Tinker.log'
+        mLine = Len(Key)
+        iLast = iCLast(Key,mLine)
+        Write(6,*) 'TINKER keyword found, run ',Key(1:iLast)
+        Call StatusLine(' Gateway:',' Read input from Tinker')
+        RC=0
+        Call Systemf(Key(1:iLast),RC)
+        If (RC.ne.0) Then
+          Key='RdCtl_Seward: Tinker call terminated abnormally'
+          Call WarningMessage(2,Key)
+          Call Abend()
+        End If
+      End If
+#ifdef _MOLCAS_MPP_
+      If (Is_Real_Par()) Then
+         Call GA_Sync()
+         Call PFGet_ASCII('QMMM')
+         Call GA_Sync()
+      End If
+#endif
+      iCoord=iCoord+1
+      CoordSet=.True.
+      Call Molcas_Open (ITkQMMM,'QMMM')
+      Call XYZread(ITkQMMM,ForceZMAT,nCoord,iErr)
+      Close(ITkQMMM)
+      If (iErr.ne.0) Then
+        Key='RdCtl_Seward: Tinker+XYZread failed:'//
+     &          ' check Tinker input files'
+        Call WarningMessage(2,Key)
+        Call Abend()
+      End If
+      Call XYZcollect(iCoord,nCoord,OrigTrans,OrigRot,nFragment)
+      GWInput = .True.
+      Go To 998
+*                                                                      *
+***** ORIG *************************************************************
+*                                                                      *
+*     Defines translation and rotation for each xyz-file
+*
+ 8015 Origin_input = .True.
+      If(FragSet) Then
+         Write(6,*) 'Keywords FRGM and ORIG are mutually exclusive!'
+         Call Quit_OnUserError()
+      End If
+      If(.not. OriginSet) Then
+         Call mma_allocate(OrigTrans,3,nFragment,label='OrigTrans')
+         Call mma_allocate(OrigRot,3,3,nFragment,label='OrogRot')
+         OriginSet = .True.
+      End If
+      Do iFrag = 1, nFragment
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,OrigTrans(1,iFrag),3)
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,OrigRot(1,1,iFrag),9)
+      End Do
+      GWinput = .True.
+      Go To 998
+*                                                                      *
+***** HYPE *************************************************************
+*                                                                      *
+ 8016 KWord = Get_Ln(LuRd)
+      geoInput = .true.
+      writeZmat = .true.
+      Call Get_F(1,HypParam,3)
+      GWinput = .True.
+      HyperParSet = .True.
+      Go To 998
+*                                                                      *
+***** ZCON *************************************************************
+*                                                                      *
+ 8017 ZConstraints = .true.
+      writeZMat = .true.
+      GWinput = .True.
+      Go To 998
+*                                                                      *
+***** SCAL *************************************************************
+*                                                                      *
+ 8018 KWord = Get_Ln(LuRd)
+      Call Get_F(1,ScaleFactor,1)
+      GWinput = .True.
+      if(.not.CoordSet) then
+         Call WarningMessage(2,'Scale can be used only with xyz input')
+         Call Quit_OnUserError()
+      endif
+      Go To 998
+*                                                                      *
+***** DOAN *************************************************************
+*                                                                      *
+ 8019 Call Put_iScalar('agrad',1)
+      Go To 998
+*                                                                      *
+***** GEOE *************************************************************
+*                                                                      *
+ 8020 Kword = Get_Ln(LuRd)
+      Call Get_I(1,iGeoInfo(2),1)
+      GWinput = .True.
+      iGeoInfo(1) = 1
+      Call Put_iArray('GeoInfo',iGeoInfo,2)
+      Go To 998
+*                                                                      *
+***** OLDZ *************************************************************
+*                                                                      *
+ 8021 GWinput = .True.
+      oldZmat = .True.
+      Go To 998
+*                                                                      *
+***** OPTH *************************************************************
+*                                                                      *
+ 8022 GWinput = .True.
+      Kword = Get_Ln(LuRd)
+      Call Get_I(1,iOptimType,1)
+      Kword = Get_Ln(LuRd)
+      Call Get_F(1,StepFac1,1)
+      if(iOptimType .eq. 2) Then
+         KWord = Get_Ln(LuRd)
+         Call Get_F(1,gradLim,1)
+      end if
+      Go To 998
+*                                                                      *
+***** NOON *************************************************************
+*                                                                      *
+ 8023 Do_OneEl = .False.
+      Go To 998
+*                                                                      *
+***** GEO  *************************************************************
+*                                                                      *
+ 8024 geoInput = .true.
+      writeZMat = .true.
+*     Parameters for the gridsize is set to default-values if geo is
+*     used instead of hyper
+      If(.not. HyperParSet) Then
+            HypParam(1) = 0.15d0
+            HypParam(2) = 2.5d0
+            HypParam(3) = 2.5d0
+      End If
+      GWinput = .True.
+      Go To 998
+*                                                                      *
+***** GEN1INT **********************************************************
+*                                                                      *
+*        GEN1INT integrals
+ 9023 lPSOI=.true.
+      !Write(6,*) 'lPSOI',lPSOI,nAtoms
+      Go To 998
+*                                                                      *
+***** FRGM *************************************************************
+*                                                                      *
+ 8025 Origin_input= .True.
+      GWinput = .True.
+      If(OriginSet) Then
+         Write(6,*) 'Keywords FRGM and ORIG are mutually exclusive!'
+         Call Quit_OnUserError()
+      End If
+      If(.not.FragSet) then
+         Call mma_allocate(OrigTrans,3,nFragment,label='OrigTrans')
+         Call mma_allocate(OrigRot,3,3,nFragment,label='OrogRot')
+*     Set up no translation and no rotation as default
+         Call FZero(OrigTrans,3*nFragment)
+         Call FZero(OrigRot,9*nFragment)
+         Do i = 1, nFragment
+            OrigRot(1,1,i)   = 1.0d0
+            OrigRot(2,2,i)   = 1.0d0
+            OrigRot(3,3,i)   = 1.0d0
+         End Do
+         FragSet = .True.
+      End If
+      Kword = Get_Ln(LuRd)
+      Call Get_I(1,iFrag,1)
+      Go To 998
+*                                                                      *
+***** TRAN *************************************************************
+*                                                                      *
+ 8026 If(.not. FragSet) Then
+         Write(6,*) 'Keyword TRANS must be preceded by keyword FRAG!'
+         Call Quit_OnUserError()
+      End If
+      GWinput = .True.
+      Kword = Get_Ln(LuRd)
+      Call Get_F(1,OrigTrans(1,iFrag),3)
+      Go To 998
+*                                                                      *
+****** ROT  ************************************************************
+*                                                                      *
+ 8027 If(.not. FragSet) Then
+         Write(6,*) 'Keyword ROT must be preceded by keyword FRAG!'
+
+      End If
+      GWinput = .True.
+      Kword = Get_Ln(LuRd)
+      Call Get_F(1,OrigRot(1,1,iFrag),9)
+      Go To 998
+*                                                                      *
+******* ZONL ***********************************************************
+*                                                                      *
+ 8028 GWinput = .True.
+      WriteZMat = .True.
+      Go To 998
+*                                                                      *
+******* BASL ***********************************************************
+*                                                                      *
+ 8029 GWinput = .True.
+      BasLib=Get_Ln(LuRd)
+      Write_BasLib=.True.
+      Go To 998
+*                                                                      *
+******* NUME ***********************************************************
+*                                                                      *
+ 8031 GWinput = .True.
+      Do_Numerical_Gradients=.True.
+      Go To 998
+*                                                                      *
+******* VART ***********************************************************
+*                                                                      *
+ 8032 GWinput = .True.
+      VarT=.True.
+      Go To 998
+*                                                                      *
+******* VARR ***********************************************************
+*                                                                      *
+ 8033 GWinput = .True.
+      VarR=.True.
+      Go To 998
+*                                                                      *
+******* SHAK ***********************************************************
+*                                                                      *
+ 8050 Continue
+      GWinput = .True.
+      KWord = Get_Ln(LuRd)
+      Call Upcase(KWord)
+      Call Get_F(1,Shake,1)
+      If (Index(KWord,'ANGSTROM').ne.0) Shake = Shake/angstr
+*---- Simple way of changing the seed: add zeros or spaces to the line
+      Do i=1,Len(KWord)
+        iSeed = iSeed+iChar(KWord(i:i))
+      End Do
+      Go To 998
+*                                                                      *
+****** PAMF ************************************************************
+*                                                                      *
+*     Disable AMFI for an atom type
+*
+ 8060 KWord = Get_Ln(LuRd)
+      nPAMFI=nPAMFI+1
+      Call Get_I(1,iPAMFI(nPAMFI),1)
+      Go To 998
+*                                                                      *
+******* GROM ***********************************************************
+*                                                                      *
+*     Import definition of QMMM system from Gromacs
+*
+ 8034 Continue
+#ifdef _GROMACS_
+      If (SymmSet) Then
+         Message = 'SYMMETRY keyword is not compatible with GROMACS'
+         Call WarningMessage(2,Message)
+         Call Quit_OnUserError()
+      End If
+      DoGromacs = .True.
+      GWInput = .True.
+      VarT = .True.
+      VarR = .True.
+*
+* Check for options
+      KWord = Get_Ln(LuRd)
+      Call UpCase(KWord)
+      If (KWord(1:4).Eq.'SIMP') Then
+         nCastMM = 0
+         Call mma_allocate(CastMM,nCastMM)
+      Else If (KWord(1:4).Eq.'CAST') Then
+         KWord = Get_Ln(LuRd)
+         Call Get_I(1,nCastMM,1)
+         If (nCastMM.LE.0) Then
+            Message = 'nCastMM is zero or negative'
+            Call WarningMessage(2,Message)
+            Call Quit_OnUserError()
+         End If
+         Call mma_allocate(CastMM,nCastMM)
+         KWord = Get_Ln(LuRd)
+         Call Get_I(1,CastMM,nCastMM)
+         Do iCastMM = 1,nCastMM
+            If (CastMM(iCastMM).LE.0) Then
+               Message = 'Impossible, MM index < 1'
+               Call WarningMessage(2,Message)
+               Call Quit_OnUserError()
+            End If
+         End Do
+      Else
+         Message='GROMACS keyword found, but no valid option'
+         Call WarningMessage(2,Message)
+         Call Quit_OnUserError()
+      End If
+*
+* After the call to Fetch_QMMM, the inner subsystem is in a temporary
+* xyz file and the outer subsystem is on the runfile
+      Call Fetch_QMMM(CastMM,nCastMM)
+*
+      Call mma_deallocate(CastMM)
+*
+* Let Molcas read the xyz file
+      iCoord = iCoord+1
+      CoordSet = .True.
+      LuXYZ = 1
+      LuXYZ = isFreeUnit(LuXYZ)
+      Call molcas_open(LuXYZ,'GMX.XYZ')
+      Call XYZread(LuXYZ,ForceZMAT,nCoord,iErr)
+      If (iErr.NE.0) Then
+         Message='RdCtl_Seward: XYZread returned non-zero error code'
+         Call WarningMessage(2,Message)
+         Call Abend()
+      End If
+      Call XYZcollect(iCoord,nCoord,OrigTrans,OrigRot,nFragment)
+      Close(LuXYZ)
+#else
+      Message = 'Interface to Gromacs not installed'
+      Call WarningMessage(2,Message)
+      Call Quit_OnUserError()
+#endif
+      Go To 998
+*                                                                      *
+******* LINK ***********************************************************
+*                                                                      *
+*     Define link atoms for a Molcas/Gromacs run
+*
+ 8036 Continue
+#ifdef _GROMACS_
+      GWInput = .True.
+      KWord = Get_Ln(LuRd)
+      Call Get_I(1,nLA,1)
+      If (nLA.LE.0) Then
+         Message = 'LA definition: nLA is zero or negative'
+         Call WarningMessage(2,Message)
+         Call Quit_OnUserError()
+      End If
+#ifdef _DEBUG_
+      Write(LuWr,'(/,a)') ' Link atoms (Gromacs numbering):'
+      Write(LuWr,'(/,a)') '      LA     QM     MM     Scaling factor'
+#endif
+      Call mma_allocate(DefLA,3,nLA)
+      Call mma_allocate(FactLA,nLA)
+      Do iLA = 1,nLA
+         KWord = Get_Ln(LuRd)
+         Call Get_I(1,DefLA(1,iLA),3)
+         Call Get_F(4,FactLA(iLA),1)
+#ifdef _DEBUG_
+         Write(LuWr,'(i8,2i7,F19.8)') (DefLA(i,iLA),i=1,3),FactLA(iLA)
+#endif
+         If (DefLA(1,iLA).LE.0) Then
+            Call WarningMessage(2,'LA definition: index of LA atom < 1')
+            Call Quit_OnUserError()
+         Else If (DefLA(2,iLA).LE.0) Then
+            Call WarningMessage(2,'LA definition: index of QM atom < 1')
+            Call Quit_OnUserError()
+         Else If (DefLA(3,iLA).LE.0) Then
+            Call WarningMessage(2,'LA definition: index of MM atom < 1')
+            Call Quit_OnUserError()
+         Else If (FactLA(iLA).LE.Zero.Or.FactLA(iLA).GE.One) Then
+            Call WarningMessage(2,'LA definition: bad scaling factor')
+            Call Quit_OnUserError()
+         End If
+      End Do
+      Call Put_iArray('LA Def',DefLA,3*nLA)
+      Call Put_dArray('LA Fact',FactLA,nLA)
+      Call mma_deallocate(DefLA)
+      Call mma_deallocate(FactLA)
+#else
+      Message = 'Interface to Gromacs not installed'
+      Call WarningMessage(2,Message)
+      Call Quit_OnUserError()
+#endif
+      Go To 998
+*                                                                      *
+****** EMFR ************************************************************
+*                                                                      *
+ 8035 GWinput = .True.
+      Kword = Get_Ln(LuRd)
+      EMFR=.True.
+      Call Get_F(1,KVector,3)
+      Temp=Sqrt(KVector(1)**2+KVector(2)**2+KVector(3)**2)
+      KVector(1)=KVector(1)/Temp
+      KVector(2)=KVector(2)/Temp
+      KVector(3)=KVector(3)/Temp
+*     Get the wavelength in atomic units.
+      Call Get_F(4,Lambda,1)
+      If (Index(KWord,'ANGSTROM').ne.0) Lambda  = Lambda/angstr
+      If (Index(KWord,'NANOMETER').ne.0) Then
+         Lambda  = Ten*Lambda/angstr
+      ENd If
+      KVector(1)=((Two*Pi)/Lambda)*KVector(1)
+      KVector(2)=((Two*Pi)/Lambda)*KVector(2)
+      KVector(3)=((Two*Pi)/Lambda)*KVector(3)
+      Go To 998
+*                                                                      *
+****** NOCD ************************************************************
+*                                                                      *
+ 9084 GWinput = .True.
+      If (.NOT.CholeskyWasSet) Then
+         Do_RI=.False.
+         iRI_Type=0
+         Cholesky=.False.
+         CholeskyWasSet=.True.
+      End If
+      Go To 998
+*                                                                      *
+****** FNMC ************************************************************
+*                                                                      *
+ 9086 GWinput = .True.
+      FNMC=.True.
+      Go To 998
+*                                                                      *
+****** EFP  ************************************************************
+*                                                                      *
+ 9088 GWinput = .True.
+      Kword = Get_Ln(LuRd)
+      Call Get_I(1,nEFP_fragments,1)
+      Allocate(FRAG_TYPE(nEFP_fragments))
+      Allocate(ABC(3,nEFP_fragments))
+      Kword = Get_Ln(LuRd)
+      Call Upcase(kWord)
+      If (KWord.eq.'XYZABC') Then
+         Coor_Type=XYZABC_type
+         nEFP_Coor=6
+         Allocate(EFP_COORS(nEFP_Coor,nEFP_fragments))
+         Write (LuWr,*) 'XYZABC option to be implemented'
+         Call Abend()
+      Else If (KWord.eq.'POINTS') Then
+         Coor_Type=POINTS_type
+         nEFP_Coor=9
+         Allocate(EFP_COORS(nEFP_Coor,nEFP_fragments))
+         Do iFrag = 1, nEFP_fragments
+            KWord = Get_Ln(LuRd)
+            FRAG_Type(iFrag)=KWord
+            Do i = 1, 3
+               KWord = Get_Ln(LuRd)
+               iend=Index(KWord,' ')
+               If (iEnd.gt.LENIN+1) Then
+                  Write (LuWr,*) 'Warning: the label ', KWord(1:iEnd),
+     &                        ' will be truncated to ',LENIN,
+     &                        ' characters!'
+               End If
+               ABC(i,iFrag) = KWord(1:Min(LENIN,iend-1))
+               Call Get_F(2,EFP_COORS((i-1)*3+1,iFrag),3)
+            End Do
+         End Do
+      Else If (KWord.eq.'ROTMAT') Then
+         Coor_Type=ROTMAT_type
+         nEFP_Coor=12
+         Allocate(EFP_COORS(nEFP_Coor,nEFP_fragments))
+         Write (LuWr,*) 'ROTMAT option to be implemented'
+         Call Abend()
+      Else
+         Write (LuWr,*) 'Illegal EFP format :',KWord
+         Write (LuWr,*)
+         Write (LuWr,*) 'Allowed format: XYZABC,'
+         Write (LuWr,*) '                POINTS, and'
+         Write (LuWr,*) '                ROTMAT'
+      End If
+      EFP=.True.
+      Go To 998
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*     P O S T   P R O C E S S I N G                                    *
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*
+ 997  Continue
+      Call Mk_DMET_Shell(Info,nInfo,nBfn)
+      Do_GuessOrb=.False.
+      mdc = mdc + Mx_mdc
+c     Postprocessing for COORD
+c      ik=index(KeepBasis,'....')
+c      if(ik.ne.0) then
+c        KeepBasis=KeepBasis(1:ik-1)
+c      endif
+      If (CoordSet) Then
+         Do ik=len(KeepBasis),1,-1
+            If (KeepBasis(ik:ik).ne.' '.and.KeepBasis(ik:ik).ne.'.')
+     &         Go To 1997
+         End Do
+1997     Continue
+         KeepBasis=KeepBasis(1:ik)
+         Call ProcessXYZ(BasisSet, KeepBasis, KeepGroup,iBSSE,
+     &                   SymThr,isHold,ScaleFactor,HyperParSet,
+     &                   isXfield)
+
+         if(writeZmat) then
+            stepFactor = stepFac1/(hypParam(1)*hypParam(1))
+            Call Geo_Setup_Drv(ishold,oldZMat,zConstraints,
+     &                         geoInput,hypParam,nFragment,iOptimType,
+     &                         stepFactor,gradLim)
+         end if
+         DoneCoord=.true.
+      if(isXfield.eq.1) then
+         LuRd_saved=LuRd
+         filename='findsym.xfield'
+         lXF=.True.
+         goto 9753
+      endif
+      endif
+9755  continue
+      If (CoordSet) Then
+         CoordSet=.false.
+         LuRdSave=LuRd
+         LuFS=IsFreeUnit(1)
+         Call Molcas_Open(LuFS,'FS.std')
+         LuRd=LuFS
+         GWInput=.True.
+         Go To 998
+      Else
+         If (DoneCoord) Then
+           Close(LuFS)
+           LuRd=LuRdSave
+         End If
+      End If
+*
+**    post-processing for RP-Coord
+*
+      If (lRP.and.RPset) Then
+        Call Gen_RelPointers(-(Info-1))
+        Call processRP(KeepGroup,SymThr,DInf,nDInf)
+        Call Gen_RelPointers(Info-1)
+      End If
+*
+**
+*
+      lAMFI=lAMFI .and. .Not. NoAMFI
+*
+*     Disable the RI flag if only one-electron integrals are
+*     requested
+*
+      Do_RI = .Not.Onenly .and. Do_RI
+      If (Do_RI) Then
+         If (LDF .and. LocalDF) Then
+            Call WarningMessage(2,'LDF and LocalDF are incompatible')
+            Call Quit_OnUserError()
+         End If
+      End If
+*
+      iPrint = nPrint(iRout)
+*
+      Mx_Shll = iShll + 1
+*
+      If (nCnttp.eq.0) then
+         Call WarningMessage(2,'Input does not contain any basis sets')
+         Call Quit_OnUserError()
+      End If
+      If (mdc.eq.0) Then
+         Call WarningMessage(2,'Input does not contain coordinates')
+         Call Quit_OnUserError()
+      End If
+      If (iAngMx.lt.0) Then
+         Call WarningMessage(2,
+     &     ' There is an error somewhere in the input!;iAngMx.lt.0')
+         Call Quit_OnUserError()
+      End If
+      If (iAngMx.gt.MxAng) Then
+         Call WarningMessage(2,' Too High angular momentum !!!')
+         Call Quit_OnUserError()
+      End If
+      If (DoTinker.and.DoGromacs) Then
+         Call WarningMessage(2,
+     &      'TINKER and GROMACS keywords cannot be used together')
+         Call Quit_OnUserError()
+      End If
+      If (DoTinker.and.iCoord.gt.1) Then
+         Call WarningMessage(2,
+     &      'TINKER and COORD keywords cannot be used together')
+         Call Quit_OnUserError()
+      End If
+      If (DoGromacs.and.iCoord.gt.1) Then
+         Call WarningMessage(2,
+     &      'GROMACS and COORD keywords cannot be used together')
+         Call Quit_OnUserError()
+      End If
+*
+      If (Test) Then
+         Do_GuessOrb=.False.
+         Do_FckInt=.False.
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Automatic DK and AMFI option for relativistic basis sets
+*                                                                      *
+************************************************************************
+*                                                                      *
+      if (Expert) then
+         Call WarningMessage(2,
+     &      ';WARNING: EXPERT option is ON!;')
+      endif
+
+      IF (BSS.AND..Not.DKroll) Then
+         Call WarningMessage(2,
+     &           'ERROR; BSSM GOES ALWAYS WITH DOUGLAS.'//
+     &           'THE OPPOSITE IS NOT TRUE')
+         Call Abend()
+      End If
+*
+      If ((lECP.or.lPP).and.DKroll.and..Not.Expert) Then
+         Call WarningMessage(2,
+     &               ' ECP option not compatible with Douglas-Kroll!;')
+         Call Quit_OnUserError()
+      End If
+*
+      If (imix.eq.1) Then
+         Call WarningMessage(2,
+     &      ';ERROR: input is inconsistent!;'
+     &    //'SEWARD found basis sets of mixed relativistic'
+     &    //' and non-relativistic types!;')
+         if(.not.Expert) Call Quit_OnUserError()
+      End If
+      If (ifnr.eq.1) Then
+         If (DKroll) Then
+         Call WarningMessage(2,
+     *    'WARNING: you requested the DK-option for;'
+     *   //'a non-relativistic basis.;'
+     *   //'This request will be ignored;')
+         End If
+         If (.Not.Expert) DKroll=.False.
+      Else If (ifnr.eq.0) Then
+         lAMFI=.True. .and. .NOT. NoAMFI
+         If (.Not.DKroll) Then
+            DKroll=.True.
+C           If (iRELAE.eq.-1) IRELAE=201022
+            If (iRELAE.eq.-1) IRELAE=  1022
+         End If
+         If (MolWgh.ne.0 .and. MolWgh.ne.2) MolWgh=2
+      End If
+*
+      If (NoDKroll) DKroll=.false.
+      If (DoEMPC) isHold=1
+*
+      If ((lECP.or.lPP).and.lAMFI.and..Not.Expert) Then
+         Call WarningMessage(2,
+     &               ' ECP option not compatible with AMFI!;')
+         Call Quit_OnUserError()
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Cholesky-specific postprocessing:
+*     0) if 1C-CD is requested, do it.
+*     1) reset integral prescreening thresholds (if not user-defined).
+*     2) use default Cholesky normalization (if not user-defined);
+*        for AMFI or Douglas-Kroll, use Molcas normalization (again,
+*        if not user-defined).
+*     3) Turn off Onenly flag, which might be set through the Direct
+*        keyword. Thus, specifying Cholesky will force 2-el. int.
+*        processing even with Direct specifed as well!
+*     4) Turn off Dist flag (makes no sense with Cholesky).
+*     5) Integral format on disk is irrelevant, except that Aces II is
+*        not allowed. So, reset iWrOpt or quit (for Aces II).
+*     6) if Cholesky threshold is specified, use it.
+*     7) if span factor is specified, use it.
+*
+      If (do1CCD) Then
+         If (.not.Cholesky) Then
+            DirInt = .True.
+            Call Cho_Inp(.True.,-1,6)
+         End If
+         Cholesky=.True.
+         Call Cho_InpMod('1CCD')
+      End If
+      If (Cholesky) Then
+         If (Onenly) Then
+            Cholesky=.false. ! we gotta be lazy in such cases
+         Else
+            If (.not. CutInt_UsrDef) CutInt = Cho_CutInt
+            If (.not. ThrInt_UsrDef) ThrInt = Cho_ThrInt
+            If (.not. MolWgh_UsrDef) Then
+               If (lAMFI .or. DKroll) Then
+                  MolWgh = 2
+               Else
+                  MolWgh = Cho_MolWgh
+               End If
+            End If
+            If (Dist) Dist =.False.
+            If (iWrOpt .eq. 2) Then
+               Write(LuWr,*)
+     &         'Acess II format not allowed with Cholesky!!'
+               Call Quit_OnUserError()
+            Else If (iWrOpt.ne.0 .and. iWrOpt.ne.3) Then
+               iWrOpt = 0
+            End If
+            If (CholeskyThr(1).ge.0.0d0) Then
+               Thrshld_CD=CholeskyThr(1)
+               Call Cho_SetDecompositionThreshold(Thrshld_CD)
+               Call Put_Thr_Cho(Thrshld_CD)
+            End If
+            If (spanCD(1).ge.0.0d0) Then
+               v=min(spanCD(1),1.0d0)
+               Call Cho_SetSpan(v)
+            End If
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+#ifdef _NO_F90_COMPILER_
+      If (DoFMM) Then
+         Call WarningMessage(2,
+           'ERROR: your MOLCAS version does not have the'
+     &   //' F90 code which does the FMM part.;'
+     &   //' Run the calculations without the FMM option'
+     &   //' or install MOLCAS with a F90 compiler!; ')
+         Call Quit_OnUserError()
+      End If
+#endif
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Run_Mode.eq.S_Mode) Go To 888
+      nIrrep = 2 ** nOper
+      iOper(0) = 0
+      Do i = 1, nOper
+         iOper(i) = 0
+         Do j = 1, 3
+          If(Oper(i)(j:j).eq.'X') iOper(i) = iOper(i) + 1
+          If(Oper(i)(j:j).eq.'Y') iOper(i) = iOper(i) + 2
+          If(Oper(i)(j:j).eq.'Z') iOper(i) = iOper(i) + 4
+         End Do
+         If (iOper(i).eq.0) Then
+            Call WarningMessage(2,
+     &               'RdCtl: Illegal symmetry operator!')
+            Write (LuWr,*) 'Oper=',Oper(i)
+            Write (LuWr,*)
+            Call Abend()
+         End If
+      End Do
+
+      If ((iXPolType.ne.0).and.(nIrrep.ne.1)) Then
+         Call WarningMessage(2,
+     &                'Polarizabilities are not compatible'
+     &              //' with symmetry.')
+         Call Quit_OnUserError()
+      EndIf
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Generate all operations of the group
+*
+      If (nOper.ge.2) Then
+         iOper(4) = iOper(3)
+         iOper(3) = iEor(iOper(1),iOper(2))
+      End If
+      If (nOper.eq.3) Then
+         iOper(5) = iEor(iOper(1),iOper(4))
+         iOper(6) = iEor(iOper(2),iOper(4))
+         iOper(7) = iEor(iOper(1),iEor(iOper(2),iOper(4)))
+      End If
+      If (lSkip) then
+         Call Put_Ln(ChSkip)
+         Call Get_I(1,iSkip,nIrrep)
+         Do_GuessOrb=.FALSE.
+      End If
+      If (nIrrep.eq.1) Then
+         Petite=.True.
+         lSOInt  =.True.
+      End If
+      Do iIrrep=0,nIrrep-2
+         Do jIrrep=iIrrep+1,nIrrep-1
+            If (iOper(iIrrep).eq.iOper(jIrrep)) Then
+              Call WarningMessage(2,
+     &                     ' The generators of the point group are'
+     &                   //' over defined, correct input!;'
+     &                   //' Abend: correct symmetry specifications!')
+               Call Quit_OnUserError()
+            End If
+         End Do
+      End Do
+*
+*     Put nIrrep and iOper on the run file to set up iPrmt
+*
+      Call Put_iScalar('NSYM',nIrrep)
+      Call Put_iArray('Symmetry operations',iOper,nIrrep)
+*
+*     Make a dummy call to iPrmt to initiate and avoid I/O recursion if
+*     the function woul be called the first time in an I/O statement.
+*
+ 888  Continue
+      iDummy=iPrmt(0,0)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Prprt) Then
+         Onenly = .True.
+         Vlct   = .False.
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Post processing for FAIEMP fragment data
+*
+      Call Gen_RelPointers(-(Info-1))
+      If (lFAIEMP.and.Run_Mode.ne.S_Mode)
+     &   Call FragExpand(nInfo,LuRd,DInf,nDInf)
+      Call Gen_RelPointers(Info-1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Post processing for RI and RI/CD option
+*
+      If ( Do_RI .and. Run_Mode.ne.S_Mode ) Then
+         If (iRI_Type.eq.4) Then
+*
+*           Generate on-the-fly aCD or aTrue.cCD auxiliary basis sets.
+*
+            Call Mk_RICD_Shells(Info,nInfo)
+*
+         Else
+*
+*           Pick up an externally defined auxiliary basis set.
+*
+            Call Mk_RI_Shells(Info,nInfo,LuRd)
+*
+         End If
+      End If
+      If (Do_RI .and. LocalDF .and. Run_Mode.eq.S_Mode) Then
+         Call SetTargetAccuracy_LDF()
+         If (CutInt_UsrDef .and. .not.APThr_UsrDef) Then
+            Call LDF_SetPrescreen(CutInt)
+            Call LDF_CheckThrs()
+         End If
+         Call LDF_CheckConfig()
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Post processing for Well integrals
+*
+      ip = ipWel
+      Do iWel = 1, nWel
+         If (Work(ip).lt.Zero) Then
+            If (.Not.lRF) Then
+               Call WarningMessage(2,
+     &                        '; Input inconsistency!; ;'
+     &                      //'Relative positions of well integrals'
+     &                      //' can only be used if the cavity radius'
+     &                      //' has been specified!')
+               Call Quit_OnUserError()
+            End If
+            Work(ip)=rds+Abs(Work(ip))
+         End If
+         ip = ip + 3
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+*---- Generate labels for cartesian and spherical basis sets.
+*     Generate the transformation matrix for cartesian to sphericals
+*     and contaminants.
+*
+      Call Sphere(iAngMx)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Put up list for point at which the orbital angular momentum
+*     will be computed.
+*
+      If (lOAM .and. .NOT.(Run_Mode.eq.S_Mode)) Then
+         ipOAM=ipExp(Mx_Shll)
+         call dcopy_(3,OAMt,1,Work(ipOAM),1)
+         Call mma_deallocate(OAMt)
+         ipExp(Mx_Shll) = ipOAM + 3
+         nInfo = nInfo + 3
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Put up list for point at which the orbital magnetic quadrupole
+*     will be computed.
+*
+      If (lOMQ .and. .NOT.(Run_Mode.eq.S_Mode)) Then
+         ipOMQ=ipExp(Mx_Shll)
+         Call DCopy_(3,OMQt,1,Work(ipOMQ),1)
+         Call mma_deallocate(OMQt)
+         ipExp(Mx_Shll) = ipOMQ + 3
+         nInfo = nInfo + 3
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Put up list for point at which the electric field will be
+*     evaluated. If nEF=0 the default points will be the unique
+*     centers.
+*
+      If (nOrdEF.ge.0.and. .NOT.(Run_Mode.eq.S_Mode)) Then
+         ipEF=ipExp(Mx_Shll)
+         If (nEF.ne.0) Then
+            call dcopy_(3*nEF,EFt,1,Work(ipEF),1)
+            Call mma_deallocate(EFt)
+         Else
+            nEF = 0
+            Do iCnttp = 1, nCnttp
+               If (.NOT.AuxCnttp(iCnttp) .and. .NOT.FragCnttp(iCnttp))
+     &         nEF = nEF + nCntr(iCnttp)
+            End Do
+            iEF = ipEF
+            Do iCnttp = 1, nCnttp
+               If (.NOT.AuxCnttp(iCnttp) .and.
+     &             .NOT.FragCnttp(iCnttp)) Then
+                  ixyz = ipCntr(iCnttp)
+                  call dcopy_(3*nCntr(iCnttp),Work(ixyz),1,Work(iEF),1)
+                  iEF = iEF + 3*nCntr(iCnttp)
+               End If
+            End Do
+         End If
+         ipExp(Mx_Shll) = ipEF + nEF*3
+         nInfo = nInfo + nEF*3
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Put up list for point at which the diamagnetic shielding will
+*     be evaluated. If nDMS=0 the default points will be the unique
+*     centers.
+*
+      If (lDMS.and. .NOT.(Run_Mode.eq.S_Mode)) Then
+         ipDMS=ipExp(Mx_Shll)
+         If (nDMS.ne.0) Then
+            call dcopy_(3*nDMS,DMSt,1,Work(ipDMS),1)
+            call mma_deallocate(DMSt)
+         Else
+            nDMS = 0
+            Do iCnttp = 1, nCnttp
+               nDMS = nDMS + nCntr(iCnttp)
+            End Do
+            ipDMS=ipExp(Mx_Shll)
+            iDMS = ipDMS
+            Do iCnttp = 1, nCnttp
+               ixyz = ipCntr(iCnttp)
+               call dcopy_(3*nCntr(iCnttp),Work(ixyz),1,Work(iDMS),1)
+               iDMS = iDMS + 3*nCntr(iCnttp)
+            End Do
+         End If
+         ipExp(Mx_Shll)=ipDMS + nDMS*3
+         nInfo = nInfo + nDMS*3
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Allocate memory for iSOff. This is the last thing to be done
+*     before unused core is release!!!!!
+*
+      If (Run_Mode.ne.S_Mode) Then
+         Max_Cnt=0
+         Do iCnttp = 1, nCnttp
+            Max_Cnt=Max(Max_Cnt,nCntr(iCnttp))
+         End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     If no multipole moment integrals are requested turn also of the
+*     computation of the velcity integrals.
+*
+      If (nMltpl.eq.0) Vlct=.False.
+*
+*     This is the highest order of any property operator.
+*     The default value of 4 is due to the mass-velocity operator
+*     which is computed by default.
+*
+      nPrp = Max(4,nMltpl)
+*
+*     Setup of tables for coefficients of the Rys roots and weights.
+*
+      nDiff=0
+      If (iAngMx.eq.0) nDiff=2
+      DoRys=.True.
+      If (DKroll.and.nOrdEF.gt.0) nDiff=nDiff+nOrdEF
+      If (.Not.Test.and.Run_Mode.ne.S_Mode) Call SetUp_RW(DoRys,nDiff)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Fix the fock matrix fields in Info while the memory has not
+*     been fixed in size.
+*
+      Call Gen_RelPointers(-(Info-1))
+      If (Do_GuessOrb.and.Run_Mode.ne.S_Mode) Then
+         Call Fix_FockOp(1,nInfo,LuRd,DInf,nDInf)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Store information for the Douglas-Kroll code.
+*
+      If (DKroll.or.NEMO) Call Fill_rInfo1(Work(Info),nInfo)
+      Call Gen_RelPointers(Info-1)
+*                                                                      *
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Compute kOffAO and lOffAO
+*
+      Call Setup_OffAO()
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (nTtl.ne.0.and.Run_Mode.eq.G_Mode) Then
+         If (iPrint.ge.6) Then
+            Write (LuWr,*)
+            Write (LuWr,'(15X,88A)') ('*',i=1,88)
+            Write (LuWr,'(15X,88A)') '*', (' ',i=1,86), '*'
+            Do iTtl = 1, nTtl
+               Write (LuWr,'(15X,A,A,A)') '*   ',Title(iTtl),'   *'
+            End Do
+            Write (LuWr,'(15X,88A)') '*', (' ',i=1,86), '*'
+            Write (LuWr,'(15X,88A)') ('*',i=1,88)
+         Else
+            Write (LuWr,*)
+            Write (LuWr,'(A)') ' Title:'
+            Do iTtl = 1, nTtl
+               Write (LuWr,'(8X,A)') Title(iTtl)
+            End Do
+            Write (LuWr,*)
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Generate the Character table for all Irreps
+*
+*     All Irreps are one dimensional, i.e. the Character for the
+*     unit operator is 1 in all irreps.
+*     The totally symmetric representation will have the character
+*     of 1 for any given operation
+*     Now, the Irreps are due to classes of operations and will
+*     present the character of this class. In case of Abelian groups
+*     or other one dimensional groups the classes will have one
+*     and only one operation. Hence, the operations themselves can
+*     be used to present the character of the Irreps.
+*
+      Call ChTab(iOper,nIrrep,iChTbl,rChTbl,lIrrep,lBsFnc,iSigma)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Setup characteristics for cartesian basis functions.
+*     Observe that this is affected by the defined generators.
+*     In the array we will set the bit corresponding to a symop
+*     if that symop will alter the sign of the basis function.
+*
+      iSymX = 0
+      iSymY = 0
+      iSymZ = 0
+      Do i = 0, nIrrep-1
+         If (iAnd(iOper(i),1).ne.0) iSymX = 1
+         If (iAnd(iOper(i),2).ne.0) iSymY = 2
+         If (iAnd(iOper(i),4).ne.0) iSymZ = 4
+      End Do
+      iChCar(1) = iSymX
+      iChCar(2) = iSymY
+      iChCar(3) = iSymZ
+      lxyz = 0
+      Do ixyz = 0, Max(iAngMx,1)
+         Do ix = ixyz, 0, -1
+            jx = Mod(ix,2)
+            iyMax=ixyz-ix
+            Do iy = iyMax, 0 , -1
+               jy = Mod(iy,2)
+               lxyz=lxyz+1
+               iz=ixyz-ix-iy
+               jz = Mod(iz,2)
+               jxyz = jx * iSymX + jy * iSymY + jz * iSymZ
+               iChBas(lxyz) = jxyz
+            End Do
+         End Do
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Generate list of Stabilizers , Stabilizer Index
+*     and distinct cosets
+*
+      mCentr=0
+      mCentr_Aux=0
+      mCentr_Frag=0
+      nOper=0
+      If (nIrrep.eq.8) nOper=3
+      If (nIrrep.eq.4) nOper=2
+      If (nIrrep.eq.2) nOper=1
+      MaxDCR = nIrrep
+      Do iCnttp = 1, nCnttp
+         nCnt = nCntr(iCnttp)
+         ixyz = ipCntr(iCnttp)
+         Do iCnt = 1, nCnt
+            mdc = iCnt + mdciCnttp(iCnttp)
+            Mx_mdc = Max(Mx_mdc,mdc)
+            If (mdc.gt.Mxdc) Then
+               Call WarningMessage(2,' mdc.gt.Mxdc!;'
+     &                      //' Increase Mxdc in info.fh.')
+               Write (LuWr,*) ' Mxdc=',Mxdc
+               Call Abend()
+            End If
+*
+*           The symmetry operators of the fragment's atoms should
+*           always be identical to that of the fragment's
+*           pseudocenter/placeholder
+*
+            If (FragCnttp(iCnttp)) Then
+*              Check the FragExpand routine!
+               iChxyz = iChCnt(nFragCoor(mdc))
+            Else
+*
+*------------- To assign the character of a center we need to find
+*              the cartesian components that are permutable. We
+*              will only need to loop over the generators of the
+*              group. We will use the three first bits to indicate if
+*              the cartesian component is affected by any symmetry
+*              operation.
+*
+               iChxyz=iChAtm(Work(ixyz),iOper,nOper,iChCar)
+            End If
+            iChCnt(mdc) = iChxyz
+            Call Stblz(iChxyz,iOper,nIrrep,nStab(mdc),jStab(0,mdc),
+     &                 MaxDCR,iCoSet(0,0,mdc))
+*
+*           Perturb the initial geometry if the SHAKE keyword was given,
+*           but maintain the symmetry
+*
+            If (Shake.gt.Zero) Then
+               jTmp=0
+               Do j=1,nStab(mdc)-1
+                  jTmp=iOr(jTmp,jStab(j,mdc))
+               End Do
+               Do j=0,2
+                  If (iAnd(jTmp,2**j).eq.0) Then
+                     Work(ixyz+j)=Work(ixyz+j)+
+     &                            Shake*(Two*Random_Molcas(iSeed)-One)
+                  End If
+               End Do
+            End If
+            ixyz = ixyz + 3
+            If (FragCnttp(iCnttp)) Then
+               mCentr_Frag = mCentr_Frag + nIrrep/nStab(mdc)
+            Else If (AuxCnttp(iCnttp)) Then
+               mCentr_Aux = mCentr_Aux + nIrrep/nStab(mdc)
+            Else
+               mCentr = mCentr + nIrrep/nStab(mdc)
+            End If
+         End Do
+      End Do
+      If (mCentr.gt.MxAtom) Then
+         Call WarningMessage(2,'RdCtl: mCentr.gt.MxAtom')
+         Write (6,*) 'mCentr=',mCentr
+         Write (6,*) 'Edit src/Include/Molcas.fh'
+         Write (6,*) 'Set MxAtom to the value of mCentr.'
+         Write (6,*) 'Recompile MOLCAS and try again!'
+         Call Abend()
+      End If
+C     Mx_mdc=mdc
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Process the weights used for alignment and distance measurement
+*
+      Call Process_Weights(iPrint)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Set structures for TS optimization according to the Saddle
+*     method.
+*
+      Call Gen_RelPointers(-(Info-1))
+      If (Run_Mode.ne.G_Mode) Then
+         Call Saddle(DInf,nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Read coordinates from run file (if any), ditto for external
+*     field. Do not do this in the Gateway!
+*
+         Call GeoNew(Show,DInf,nDInf)
+         If (lXF) Call GeoNew_PC(Dinf,nDInf)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Gen_GeoList(Work(Info),nInfo)
+      Call Gen_RelPointers(Info-1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Generate list of centers for multipole operators
+*
+      Call SetMltplCenters()
+*
+*     Put in user specified centers if any
+*
+      If (lMltpl) Then
+         Do i = 1, nTemp
+            iMltpl = ITmp(i)
+            If (iMltpl.le.nMltpl) call dcopy_(3,RTmp(1,i),1,
+     &                                         Coor_MPM(1,iMltpl+1),1)
+         End Do
+         Call mma_deallocate(RTmp)
+         Call mma_deallocate(ITmp)
+      End If
+#ifdef _DEBUG_
+       Call RecPrt(' Multipole centers',' ',Coor_MPM,3,nMltpl+1)
+#endif
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Deallocate fields from keyword ORIGIN
+*
+      If(Origin_input) Then
+         Call mma_deallocate(OrigRot)
+         Call mma_deallocate(OrigTrans)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (NoZMAT .and. .NOT.ForceZMAT) Call Put_iScalar('N ZMAT',0)
+      If (Run_Mode.ne.S_Mode) Call Put_iArray('BasType',BasisTypes,4)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Run_Mode.eq.G_Mode)
+     &   Call Put_lScalar('Invert constraints',Invert)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Release unused core. This section should be the last section in
+*     this routine. DON'T MOVE IT!
+*
+      If (Run_Mode.ne.S_Mode) Then
+*
+         Call Allocate_Work(Info_tmp,nInfo)
+         Call dCopy_(nInfo,Work(Info),1,Work(Info_tmp),1)
+         Call Free_Work(Info)
+         Call Gen_RelPointers(-(LctInf-1))
+         Call Allocate_Work(Info,nInfo)
+         LctInf=Info
+         Call Gen_RelPointers(LctInf-1)
+         Call dCopy_(nInfo,Work(Info_tmp),1,Work(Info),1)
+         Call Free_Work(Info_tmp)
+*
+         If (iPrint.ge.99) Then
+            Write (LuWr,*) ' ****            nPrint           ****'
+            Write (LuWr,'(26(1X,10I4,/))') nPrint
+            Write (LuWr,*) ' *************************************'
+            Write (LuWr,*) ' nInfo=',nInfo
+C           Call RecPrt('Memory dump',' ',Work(Info),(nInfo+4)/5,5)
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call qExit('RdCtl')
+      Return
+6666  Call WarningMessage(2,'Unable to read data from '//KWord)
+      call Quit_OnUserError()
+      End
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+      Subroutine SetTargetAccuracy_LDF()
+      Implicit None
+#include "localdf.fh"
+      If (Thr_Accuracy.lt.0.0d0) Call LDF_SetDefaultThrs()
+      Return
+      End
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+      Subroutine LDF_CheckThrs()
+      Implicit None
+#include "localdf.fh"
+      If (Thr_Accuracy.lt.0.0d0) Then
+         Call WarningMessage(2,'LDF: Thr_Accuracy<0')
+         Call Quit_OnUserError()
+      End If
+      If (Thr_Prescreen.lt.0.0d0) Then
+         Call WarningMessage(2,'LDF: Thr_Prescreen<0')
+         Call Quit_OnUserError()
+      End If
+      Thr_Prescreen=min(Thr_Prescreen,Thr_Accuracy)
+      Return
+      End
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+      Subroutine LDF_SetOptionFlag(Option,Value)
+      Implicit None
+      Character*4 Option
+      Logical Value
+#include "localdf.fh"
+      If (Option.eq.'LDF2') Then
+         LDF2=Value
+      Else If (Option.eq.'CHEC') Then
+         CheckPairIntegrals=Value
+      Else If (Option.eq.'VERI') Then
+         VerifyFit=Value
+      Else If (Option.eq.'OVER') Then
+         CheckOverlapIntegrals=Value
+      Else If (Option.eq.'WRUC') Then
+         WriteUnconstrainedC=Value
+      Else If (Option.eq.'UNIQ') Then
+         UseUniqueAtomPairs=Value
+      Else
+         Call WarningMessage(2,'LDF_SetOptionFlag: unknown Option')
+         Write(6,'(A,A)') 'Option=',Option
+         Write(6,'(A,L1)') 'Value=',Value
+         Call LDF_Quit(1)
+      End If
+      Return
+      End
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
+      Subroutine LDF_CheckConfig()
+      Implicit None
+#include "localdf.fh"
+#include "para_info.fh"
+      ! Debug write of unconstrained coefficients:
+      ! 1) makes no sense for unconstrained LDF => reset
+      ! 2) not implemented in parallel => error
+      WriteUnconstrainedC=WriteUnconstrainedC .and. LDF_Constraint.ne.-1
+#ifdef _MOLCAS_MPP_
+      If (WriteUnconstrainedC) Then
+         If (nProcs.gt.1 .and. Is_Real_Par()) Then
+            Call WarningMessage(2,
+     &   'Write unconstrained coefficients not implemented in parallel')
+            Call Quit_OnUserError()
+         End If
+      End If
+#endif
+      ! Using unique atom pairs is buggy, warn!
+      If (UseUniqueAtomPairs) Then
+         Call WarningMessage(1,
+     &   'WARNING: using unique atom pairs may cause erroneous results')
+         Call xFlush(6)
+      End If
+      Return
+      End
diff --git a/src/dmet_util/seward_dmet.f b/src/dmet_util/seward_dmet.f
new file mode 100644
index 0000000..dcd0021
--- /dev/null
+++ b/src/dmet_util/seward_dmet.f
@@ -0,0 +1,597 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v.2.1.  *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 2017 Varinia Bernales and Roland Lindh                 *
+************************************************************************
+      Subroutine Seward_DMET(ireturn,DMET_h,DMET_g,nBfn)
+c.... please do not move this line further down (required for fortsplit)
+************************************************************************
+*                                                                      *
+* (c) Copyright 1989, 1990, 1991, and 1992                             *
+* Roland Lindh                                                         *
+* Dept. of Theoretical Chemistry                                       *
+* University of Lund, SWEDEN                                           *
+*                                                                      *
+* and                                                                  *
+*                                                                      *
+* IBM                                                                  *
+* International Business Machine Corporation                           *
+*                                                                      *
+* No part of this code may be copied or redistributed without the      *
+* written permission of the copyright owner.                           *
+* The copyright owner does not take any responsibility for any         *
+* errors in the code or documentation.                                 *
+*                                                                      *
+* All rights reserved.                                                 *
+*                                                                      *
+************************************************************************
+************************************************************************
+* In 1867, William Seward, for 2 cents per acre, purchased             *
+* Alaska, a valueless wasteland of ice and snow.                       *
+*                                                                      *
+* In 1990, Roland Lindh and Ungsik Ryu worked on molecular             *
+* integral evaluation, an exhausted scientific area with no            *
+* room for innovation.                                                 *
+*                                                                      *
+* Bowen Liu                                                            *
+* April, 1990                                                          *
+************************************************************************
+************************************************************************
+*                                                                      *
+*  Object: Driver for the one and two electron integral program        *
+*          SEWARD. SEWARD computes integrals for cartesian and         *
+*          spherical harmonic gaussian basis functions.                *
+*                                                                      *
+*                                                                      *
+* Called from: None                                                    *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              SetUp0                                                  *
+*              DmpInf                                                  *
+*              Input_Seward                                            *
+*              SetUp                                                   *
+*              Drv1El                                                  *
+*              Drv2El                                                  *
+*                                                                      *
+*  Author: Roland Lindh, IBM Almaden Research Center, San Jose, CA     *
+*          July '89 - May '90                                          *
+*                                                                      *
+* (c) Copyright 1989 IBM                                               *
+* All rights reserved.                                                 *
+* (c) Copyright 1990 IBM                                               *
+* All rights reserved.                                                 *
+*                                                                      *
+*          Roland Lindh, Dept. of Theoretical Chemistry, University of *
+*          Lund, SWEDEN. Modified to use Schwartz inequality for pre-  *
+*          screening, July 1991.                                       *
+*                                                                      *
+************************************************************************
+      use Real_Spherical
+      use Period
+      use GeoList
+      use MpmC
+      Implicit Real*8 (A-H,O-Z)
+      Real*8 DMET_h(nBfn,nBfn), DMET_g(nBfn**4)
+      External Integral_WrOut, Integral_WrOut2, Integral_RI_3
+      Real*8, Dimension(:), Allocatable :: MemHide
+#include "real.fh"
+#include "itmax.fh"
+#include "info.fh"
+#include "warnings.fh"
+#include "WrkSpc.fh"
+#include "stdalloc.fh"
+#include "nsd.fh"
+#include "setup.fh"
+#include "status.fh"
+#include "lundio.fh"
+#include "print.fh"
+#include "gateway.fh"
+#ifdef _FDE_
+#include "embpotdata.fh"
+#endif
+      Integer iix(2), nChoV(8), GB
+      Logical PrPrt_Save, Exist, DoRys, lOPTO
+      Real*8  DiagErr(4), Dummy(2)
+C-SVC: identify runfile with a fingerprint
+      Character cDNA*256
+      Logical IsBorn, Do_OneEl
+      Integer IsGvMode
+*                                                                      *
+************************************************************************
+*                                                                      *
+      lOPTO = .False.
+      nByte = iiLoc(iix(2)) - iiLoc(iix(1))
+      Call CWTime(TCpu1,TWall1)
+*
+*     Prologue
+*
+      iRout=1
+      Call qEnter('Seward')
+      LuWr=6
+      PrPrt_Save = .False. ! dummy initialize
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Figure out the run_mode
+*
+*     Seward can be run in two different modes!
+*     GS_Mode: does the work of both Gateway and Seward
+*     S_Mode:  only the work of Seward
+*
+*
+*     Check if the run file is there
+*
+      Call f_Inquire('RUNFILE',Exist)
+      If (Exist) Then
+         Call Qpg_iScalar('Run_Mode',Exist)
+         If (Exist) Then
+*
+*           The Run_mode of the runfile is either GS_Mode or G_Mode
+*
+            Call Get_iScalar('Run_Mode',Run_Mode)
+*
+*           If the Run_mode is that Gateway is in action then Seward
+*           should be run in S_mode.
+*
+            If (Run_Mode.eq.G_Mode) Run_Mode=S_Mode
+         Else
+            Run_Mode=GS_Mode
+         End If
+      Else
+*
+*        Seward runs without Gateway
+*
+         Run_Mode=GS_Mode
+         Call MkRun(iRC,0)
+         Call Put_iScalar('Run_Mode',Run_Mode)
+*
+*     Determine and save the fingerprint of the runfile in a field with
+*     label 'BirthCertificate' if it is empty.  This allows us to
+*     uniquely identify the runfile and any later associated files.
+*
+         Call qpg_cArray('BirthCertificate',IsBorn,nDNA)
+         If (.NOT.IsBorn) Then
+           Call Get_Genome(cDNA,nDNA)
+           Call Put_cArray('BirthCertificate',cDNA,nDNA)
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Get the memory size available
+*
+      Call SetMem('Clear=Off')
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     If Seward is run in S_mode most of the input is already on the
+*     runfile. If Seward is run in GS_Mode it will handle the input and
+*     runfile in the conventional way.
+*
+      If (Run_Mode.eq.S_Mode) Then
+*
+*        S_Mode
+*
+         Call Seward_Init()
+         DoRys=.True.
+         nDiff=0
+         Call GetInf(Info,nInfo,DoRys,nDiff,1)
+         Primitive_Pass=.True.
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Else
+*
+*        GS_Mode
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        Initialize common blocks
+*
+         Call Seward_Init()
+         Call Funi_Init()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        Call GetMem to get pointer to first available core allocation.
+*
+         kB=2**10
+         MB=kb*kB
+         GB=kb*MB/8 ! adjust to real*8
+         Call GetMem('Info','Max','Real',iDum,MaxM)
+         nDInf=Max(MaxM/4,Min((9*MaxM)/10,GB))
+         Call GetMem('Info','ALLO','REAL',Info,nDInf)
+         Call FZero(Work(Info),nDInf)
+         Info_Status=Active
+         LctInf = Info
+         nInfo = 0
+*
+      End If ! Run_Mode.eq.S_Mode
+
+************************************************************************
+*   columbus support: initialize additional items in Runfile
+*   default: no mixed operation
+      call Put_iScalar('Columbus',0)
+      call Put_iScalar('colgradmode',0)
+      dummy(1)=0.0d0
+      dummy(2)=0.0d0
+      call Put_dArray ('MR-CISD energy',dummy,2)
+      Call NQGrid_Init()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Spool the input
+*
+      LuSpool=21
+      Call SpoolInp(LuSpool)
+*     Read the input from input file
+*
+      Call RdCtl_DMET(Info,nInfo,LuSpool,lOPTO,Do_OneEl,
+     &                  Work(Info),nDInf,nBfn)
+      Call GvMode(IsGvMode)
+      if(IsGvMode.gt.0) Onenly=.true.
+*
+      Call Close_LuSpool(LuSpool)
+*
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+ 199  Continue
+*
+*     Process the input.
+*
+      Call Input_Seward(lOPTO,Info,Work(Info),nDInf)
+*
+      If (Primitive_Pass) Then
+         PrPrt_Save = PrPrt
+         PrPrt=.False.
+      Else
+         PrPrt=PrPrt_Save
+      End If
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*     Compute the Nuclear potential energy
+*
+      If (.Not.Primitive_Pass) Then
+         Call Gen_RelPointers(-(Info-1))
+         Call DrvN0(Work(Info),nInfo)
+         Call Gen_RelPointers(Info-1)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Show) Then
+*
+*        Print out basis set information
+*
+         Write(6,*)
+         Write(6,'(6X,A)')'Basis set specifications :'
+         Write(6,'(6X,A,T30,8(2X,A))')
+     &         'Symmetry species',     (lIrrep(i),i=0,nIrrep-1)
+         Write(6,'(6X,A,T30,8I5)')'Basis functions',
+     &                                 (nBas(i),i=0,nIrrep-1)
+         Write(6,*)
+*
+      End If
+
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     If only test case then clean up!
+*
+      If (Test) Go To 9999
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Write/update information on the run file.
+*
+      If (.Not.Primitive_Pass) Then
+         Call Gen_RelPointers(-(Info-1))
+         Call DmpInf(Work(Info),nInfo)
+         Call basis2run(Work(Info),nInfo)
+         Call Gen_RelPointers(Info-1)
+      End If
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*     ONE-ELECTRON INTEGRAL SECTION
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+#ifdef _FDE_
+      ! Embedding
+      if (embPot.and..not.embPotInBasis) then
+       Call embPotInit(.false.)
+      end if
+#endif
+
+      Lu_One=2
+      iOpt = 1
+      iRC = -1
+*
+*     Generate primimitive integrals only if needed.
+*
+      If (Primitive_Pass.and.(DKroll.or.Nemo)) Then
+         Call OpnOne(iRC,iOpt,'ONEREL',Lu_One)
+         Call OneBas('PRIM')
+      Else
+         Call OpnOne(iRC,iOpt,'ONEINT',Lu_One)
+      End If
+      If (iRC.ne.0) Then
+         Call WarningMessage(2,
+     &                  ' *** Error in subroutine INPUT ***;'
+     &                //'     Abend in subroutine OpnOne')
+         Call Abend()
+      End If
+*
+      If (Do_OneEl.and.
+     &    (.Not.Primitive_Pass .or.
+     &    (Primitive_Pass.and.(DKroll.or.NEMO)) ) )
+     &   Call Drv1El_DMET(DMET_h,nBfn)
+*
+      iOpt = 0
+      iRC = -1
+      Call ClsOne(iRC,iOpt)
+      If (iRC.ne.0) then
+         Call WarningMessage(2,
+     &              ' *** Error in SEWARD main ***;'
+     &            //'  Abend in subroutine ClsOne')
+         Call Abend()
+      End If
+
+#ifdef _FDE_
+      ! Embedding
+      if (embPot.and..not.embPotInBasis) Call embPotFreeMem
+#endif
+
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*     If a pass in which primitive integrals where computed do a second
+*     pass.
+*
+      If (Primitive_Pass) Then
+         Primitive_Pass=.False.
+         Call Free_iSD()
+         Go To 199
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Branch out if only one-electron integrals are to be computed!
+*
+      If (Onenly) Go To 9999
+*                                                                      *
+*     If ERIs/CD/RI already available, one may want not to redo it!
+*
+      If (Fake_ERIs) Then
+         Call set_fake_ERIs()
+         Go To 9999
+      EndIf
+************************************************************************
+************************************************************************
+*                                                                      *
+*     TWO-ELECTRON INTEGRAL SECTION
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*
+      Call mma_allocate(MemHide,Memhid)
+*
+      If ( iWRopt.eq.0 ) then
+*
+*------- Molcas format
+*
+         If (Cholesky) Then ! Cholesky decomposition
+            Call Cho_MCA_Drv()
+            Call Get_iArray('NumCho',nChoV,nIrrep)
+            Write(6,'(6X,A,T30,8I5)')'Cholesky vectors',
+     &               (nChoV(i),i=1,nIrrep)
+            Write(6,*)
+            Write(6,*)
+         Else If (Do_RI) Then
+            If (LocalDF) Then
+               Call Drv2El_LocalDF()
+            Else
+               If (nPrint(iRout).ge.6) Then
+                  Write (6,*)
+                  Write (6,'(A)') 'Seward processing 2-center and '
+     &                          //'3-center ERIs'
+                  Write (6,*)
+               End If
+               Call Drv2El_3Center_RI(Integral_RI_3,Zero)
+               Call Get_iArray('NumCho',nChoV,nIrrep)
+               If (nPrint(iRout).ge.6) Then
+                  Write(6,'(6X,A,T30,8I5)')'RI vectors',
+     &                  (nChoV(i),i=1,nIrrep)
+                  Write(6,*)
+                  Write(6,*)
+               End If
+            End If
+         Else
+            iWrOpt_Save=iWrOpt
+            iWrOpt=0
+            Call Sort0
+*
+            Call Drv2El_DMET(Integral_WrOut2,Zero,DMET_g,nBfn)
+*
+            Call Sort1B
+            Call Sort2
+            Call Sort3(MaxDax)
+*
+            If (nPrint(iRout).ge. 6) Then
+               Write (6,*)
+               Write (6,'(A)')
+     &           ' Integrals are written in MOLCAS2 format'
+               Write (6,'(A,I10)')
+     &           ' Total Number of integrals             '//
+     &           '                = ',IntTot
+               Write (6,'(A,I10)')
+     &           ' Number of nonzero integrals passed to '//
+     &           'packing routine = ',NotZer
+               If ( iPack.ne.0 ) Then
+                  Write (6,'(A)')
+     &              ' No packing of integrals has been applied'
+               Else
+                  Write (6,'(A,G10.4)') ' Packing accuracy = ',
+     &                                   PkAcc
+                  Write (6,'(A,I10)')
+     &             ' Highest disk address written',MaxDax
+               End If
+               If ( iSquar.eq.0 ) Then
+                  Write (6,'(A,A)') ' Diagonal and subdiagonal, '
+     &              //'symmetry allowed 2-el',
+     &              ' integral blocks are stored on Disk'
+               Else
+                  Write (6,'(A,A)') ' All symmetry allowed 2-el '
+     &              //'integral blocks are', ' stored on Disk'
+               End If
+            End If
+            iWrOpt=iWrOpt_Save
+         End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Else If (iWRopt.eq.1) Then
+*
+*------- Molecule format (Molcas 1.0)
+*
+         Lu_28=28
+         Lu_28=isfreeunit(Lu_28)
+         Call DaName_MF(Lu_28,'BASINT')
+         iDisk=0
+         lBuf=iiLoc(nUt)-idLoc(Buf)
+         lBuf=(lBuf+nByte)/nByte
+*
+         Call Drv2El(Integral_WrOut,Zero)
+*
+         ip_Buf=ip_of_iWork(Buf)
+         Call iDafile(Lu_28,1,iWork(ip_Buf),lBuf,iDisk)
+         nUt=-1
+         Call iDafile(Lu_28,1,iWork(ip_Buf),lBuf,iDisk)
+         Write (6,*)
+         Write (6,'(A)')' Integrals are written in MOLCAS1 format'
+         Write (6,'(I10,A)') IntTot,' Integrals written on Disk'
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Else
+*
+         Call WarningMessage(2,'Seward: Invalid value of iWRopt!')
+         Call Abend()
+*
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Dist) Then
+         Write (6,*)
+         Write (6,*)
+     & ' Distribution of the Absolute Values of the Integrals'
+         Write (6,*)
+         Write (6,'(1x,10I8)')  (i,i=-20,-11)
+         Write (6,'(1x,10I8)')  (NrInt(i),i=-20,-11)
+         Write (6,*)
+         Write (6,'(1x,10I8)')  (i,i=-10,-1)
+         Write (6,'(1x,10I8)')  (NrInt(i),i=-10,-1)
+         Write (6,*)
+         Write (6,'(1x,10I8)')  (i,i=0,9)
+         Write (6,'(1x,10I8)')  (NrInt(i),i=0,9)
+         Write (6,*)
+      End If
+*
+      Call mma_deallocate(MemHide)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     At the end of the calculation free all memory to check for
+*     corruption of the memory.
+*
+
+ 9999 Call ClsSew
+      If (Allocated(AdCell)) Call mma_deallocate(AdCell)
+      Call mma_deallocate(Coor_MPM)
+      Call mma_deallocate(Chrg)
+      Call mma_deallocate(Mass)
+      Call mma_deallocate(Centr)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call CWTime(TCpu2,TWall2)
+      Call SavTim(4,TCpu2-TCpu1,TWall2-TWall1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Diagonal ERI check
+*
+      If (Cholesky .or. Do_RI) Then
+         If (DiagCheck) Then
+            write(6,*)' ==== Start Diagonal ERI check  ===='
+            Call Cho_X_init(irc,ChFracMem)
+            if (irc.ne.0) then
+               Call WarningMessage(2,
+     &                   ' Seward: Non-zero rc in Cho_X_init.')
+               Call Abend()
+            endif
+            Call Cho_X_CheckDiag(irc,DiagErr)
+            if (irc.ne.0) then
+               Call WarningMessage(2,
+     &                   ' Seward: Non-zero rc in Cho_X_CheckDiag.')
+               Call Abend()
+            endif
+            Call Cho_X_Final(irc)
+            if (irc.ne.0) then
+               Call WarningMessage(2,
+     &                   ' Seward: Non-zero rc in Cho_X_Final.')
+               CALL Abend()
+            endif
+            write(6,*)
+            write(6,*)' ====  End  Diagonal ERI check  ===='
+         EndIf
+      EndIf
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Automatic run of GuessOrb
+*
+*     If (Do_GuessOrb.and.Do_FckInt) Call GuessOrb(iReturn,.FALSE.)
+*     If(IsGvMode.gt.0) then
+*       Call DoGvMode(IsGvMode)
+*     EndIf
+*     If (.not.Prprt.and.Do_OneEl) Call Put_NucAttr()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+*     Epilogue
+*
+      Call qExit('Seward')
+      If (nPrint(iRout).ge.6) Then
+         Call qStat(' ')
+         Call FastIO('STATUS')
+      End If
+*
+*
+      ireturn=_RC_ALL_IS_WELL_
+      If (Test)  Then
+         ireturn=_RC_EXIT_
+      Else
+         If (isGvMode.gt.0.or.lRP_Post)
+     &       ireturn=_RC_INVOKED_OTHER_MODULE_
+      End If
+      Return
+      End
diff --git a/src/guessorb_util/commgo.fh b/src/guessorb_util/commgo.fh
deleted file mode 100644
index 4b8b390..0000000
--- a/src/guessorb_util/commgo.fh
+++ /dev/null
@@ -1,57 +0,0 @@
-************************************************************************
-* This file is part of OpenMolcas.                                     *
-*                                                                      *
-* OpenMolcas is free software; you can redistribute it and/or modify   *
-* it under the terms of the GNU Lesser General Public License, v. 2.1. *
-* OpenMolcas is distributed in the hope that it will be useful, but it *
-* is provided "as is" and without any express or implied warranties.   *
-* For more details see the full text of the license in the file        *
-* LICENSE or in <http://www.gnu.org/licenses/>.                        *
-************************************************************************
-************************************************************************
-*                                                                      *
-* Common data for guessorb.                                            *
-*                                                                      *
-************************************************************************
-*----------------------------------------------------------------------*
-* Parameters                                                           *
-*----------------------------------------------------------------------*
-c      Integer MxSym
-c      Integer MxAtom
-      Integer MxBasis
-c      Parameter ( MxSym   =    8 )
-c      Parameter ( MxAtom  = 2000 )
-      Parameter ( MxBasis = 5000 )
-*----------------------------------------------------------------------*
-* Real*8 data.                                                         *
-*----------------------------------------------------------------------*
-      Real*8 xCharge(MxAtom)
-      Real*8 PrThr
-      Real*8 SThr
-      Real*8 TThr
-      Real*8 GapThr
-      Common /dblgo/ xCharge,PrThr,SThr,TThr,GapThr
-*----------------------------------------------------------------------*
-* Integer data.                                                        *
-*----------------------------------------------------------------------*
-      Integer nSym
-      Integer nBas(MxSym)
-      Integer nOcc(MxSym)
-      Integer nVir(MxSym)
-      Integer nDel(MxSym)
-      Integer nNuc
-      Integer iPrFmt
-      Common /intgo/ nSym,nBas,nOcc,nVir,nDel,nNuc,iPrFmt
-*----------------------------------------------------------------------*
-* Character data.                                                      *
-*----------------------------------------------------------------------*
-      Character*(LENIN) Name(MxAtom)
-      Character*(LENIN4) Label(MxBasis)
-      Common /chrgo/ Name,Label
-*----------------------------------------------------------------------*
-* Logical data.                                                        *
-*----------------------------------------------------------------------*
-      Logical PrintMOs
-      Logical PrintEor
-      Logical PrintPop
-      Common /loggo/ PrintMOs,PrintEor,PrintPop
diff --git a/src/guessorb_util/gsswfn.fh b/src/guessorb_util/gsswfn.fh
deleted file mode 100644
index 96fafc0..0000000
--- a/src/guessorb_util/gsswfn.fh
+++ /dev/null
@@ -1,19 +0,0 @@
-************************************************************************
-* This file is part of OpenMolcas.                                     *
-*                                                                      *
-* OpenMolcas is free software; you can redistribute it and/or modify   *
-* it under the terms of the GNU Lesser General Public License, v. 2.1. *
-* OpenMolcas is distributed in the hope that it will be useful, but it *
-* is provided "as is" and without any express or implied warranties.   *
-* For more details see the full text of the license in the file        *
-* LICENSE or in <http://www.gnu.org/licenses/>.                        *
-************************************************************************
-#ifdef _HDF5_
-#  include "mh5.fh"
-#endif
-
-      integer                 wfn_fileid,
-     $        wfn_energy, wfn_mocoef, wfn_occnum, wfn_orbene
-
-      common /gsswfn_handles/ wfn_fileid,
-     $        wfn_energy, wfn_mocoef, wfn_occnum, wfn_orbene
diff --git a/src/seward_util/drv1el.f b/src/seward_util/drv1el.f
new file mode 100644
index 0000000..b0daef1
--- /dev/null
+++ b/src/seward_util/drv1el.f
@@ -0,0 +1,2042 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1991, Roland Lindh                                     *
+*               1996, Per Ake Malmqvist                                *
+************************************************************************
+      SubRoutine Drv1El(DInf,nDInf,Info)
+************************************************************************
+*                                                                      *
+* Object: driver for computation of one-electron matrices.             *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              OneEl                                                   *
+*              GetDens                                                 *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, Dept. of Theoretical Chemistry,            *
+*             University of Lund, SWEDEN                               *
+*             January 1991                                             *
+************************************************************************
+      Use GeoList
+      Use MpmC
+      Use PrpPnt
+      Implicit Real*8 (A-H,O-Z)
+      External MltInt, KnEInt, MVeInt,  VeInt,  D1Int,  NAInt,  EFInt,
+     &         OAMInt, OMQInt, DMSInt, WelInt, XFdInt,  PrjInt,
+     &          M1Int,  M2Int, SROInt, AMPInt,  PXPInt,  PXInt,
+     &          VPInt, PPInt, CntInt, EMFInt,
+     &         MltInt_GIAO,
+     &         KneInt_GIAO,
+     &          NAInt_GIAO,
+     &          dTdmu_Int
+      External MltMem, KnEMem, MVeMem,  VeMem,  D1Mem,  NAMem,  EFMem,
+     &         OAMMem, OMQMem, DMSMem, WelMem, XFdMem,  PrjMem,
+     &          M1Mem, M2Mem, SROMem, AMPMem, PXPmem,  PXMem,
+     &          VPMem, PPMem, CntMem, EMFMem,
+     &         MltMem_GIAO,
+     &         KneMem_GIAO,
+     &          NAMem_GIAO,
+     &          dTdmu_Mem
+      Real*8 DInf(nDInf)
+#ifdef _FDE_
+      ! Embedding
+      External embPotMem, embPotKernel
+      Real*8, Dimension(:), Allocatable :: Emb_Int
+#endif
+*     ipList: list of pointers to the integrals of each component
+*             of the operator
+*     OperI: list which irreps a particular component of the operator
+*            belongs to
+*     OperC: list the character of each component of the operator
+*     CoorO: list of origins of the operator, one for each component
+      Integer, Dimension(:), Allocatable :: ipList, OperI, OperC
+      Real*8, Dimension(:), Allocatable :: CoorO, Nuc, KnE_Int, NA_Int,
+     &                                     FragP, OneHam, PtEl,
+     &                                     PtNuc, SumEl, SumNuc
+      Real*8, Dimension(:,:), Allocatable :: PAMexp
+      External PAM2Int, FragPint, PAM2Mem, FragPMem
+      External P_Int, EPEInt,
+     &         P_Mem, EPEMem
+      logical lECPnp,lPAM2np
+#include "itmax.fh"
+#include "info.fh"
+#include "print.fh"
+#include "nq_info.fh"
+#include "real.fh"
+#include "WrkSpc.fh"
+#include "stdalloc.fh"
+#include "wldata.fh"
+#include "property_label.fh"
+#include "oneswi.fh"
+#include "warnings.fh"
+#ifdef _FDE_
+#include "embpotdata.fh"
+#endif
+      Integer iSymR(0:3)
+      Character*8 Label
+      Character*512 FName
+      Real*8 Ccoor(3)
+      Integer iAtmNr2(mxdbsc), nComp
+      Real*8 Charge2(mxdbsc)
+*
+      iRout = 131
+      iPrint = nPrint(iRout)
+*     Call qEnter('Drv1El')
+*
+      Call StatusLine(' Seward:',' Computing 1-electron integrals')
+*
+      Call Set_Basis_Mode('Valence')
+      Call Setup_iSD()
+#ifdef _FDE_
+      if (embPot) call EmbPotRdRun
+#endif
+
+*
+*     set center selector in OneSwi to all centers (default)
+*
+      NDDO = .FALSE.
+      If (Prprt.and.DKroll) Then
+         Call WarningMessage(2,
+     &               'Prprt and DKroll options can not be combined!')
+         Call Quit_OnUserError()
+      End If
+*
+*     We will always compute the following one-electron integrals per
+*     default.
+*     1) Multipole moments up to quadrupole moments
+*     2) Kinetic energy
+*     3) Nuclear Attraction
+*     4) ECP contributions
+*     5) One-Electron Hamiltonian
+*     6) Mass-Velocity
+*     7) Darwin 1-electron contact term
+*
+      lECPnp = lECP
+      lPAM2np = lPAM2
+      if (DKroll.and.Primitive_Pass) then
+         lECPnp = .False.
+      endif
+      If (Prprt) Then
+         FName=SW_FileOrb
+         IF (mylen(FName).eq.0) FName='INPORB'
+         Call GetDens(FName(:mylen(FName)),short,iPrint)
+         Call CollapseOutput(1,'   Molecular properties:')
+         Write (6,'(3X,A)')    '   ---------------------'
+         Write (6,*)
+      End If
+************************************************************************
+************************************************************************
+*1)                                                                    *
+*                                                                      *
+*     Multipole Moments starting with the overlap. If SEWARD is run in *
+*     the property mode we will skip the overlap integrals.            *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+      iLow = 0
+      mMltpl=nMltpl
+      If (Prprt) iLow = 1
+*
+*     If not Douglas-Kroll and primitive pass do no property integrals
+*
+      If (Primitive_Pass) Then
+         iLow=0
+         If (.Not. DKroll) mMltpl=-1
+      End If
+*
+      Do 10 iMltpl = iLow, nMltpl
+         Write (Label,'(A,I2)') 'Mltpl ', iMltpl
+         nComp = (iMltpl+1)*(iMltpl+2)/2
+         Call DCopy_(3,Coor_MPM(1,iMltpl+1),1,Ccoor,1)
+         Call Allocate_Auxiliary()
+         iComp=0
+         Do 11 ix = iMltpl, 0, -1
+            If (Mod(ix,2).eq.0) Then
+               iSymX=1
+            Else
+               ixyz=1
+               iSymX=2**IrrFnc(ixyz)
+               If (Ccoor(1).ne.Zero) iSymX = iOr(iSymX,1)
+            End If
+            Do 12 iy = iMltpl-ix, 0, -1
+               If (Mod(iy,2).eq.0) Then
+                  iSymY=1
+               Else
+                  ixyz=2
+                  iSymY=2**IrrFnc(ixyz)
+                  If (Ccoor(2).ne.Zero) iSymY = iOr(iSymY,1)
+               End If
+               iz = iMltpl-ix-iy
+               If (Mod(iz,2).eq.0) Then
+                  iSymZ=1
+               Else
+                  ixyz=4
+                  iSymZ=2**IrrFnc(ixyz)
+                  If (Ccoor(3).ne.Zero) iSymZ = iOr(iSymZ,1)
+               End If
+               iChO = Mod(ix,2)*iChBas(2)
+     &              + Mod(iy,2)*iChBas(3)
+     &              + Mod(iz,2)*iChBas(4)
+*
+               OperI(1+iComp) = MltLbl(iSymX,MltLbl(iSymY,iSymZ,
+     &                            nIrrep),nIrrep)
+               OperC(1+iComp) = iChO
+               Call DCopy_(3,Coor_MPM(1,iMltpl+1),1,
+     &                    CoorO(1+iComp*3),1)
+               iComp = iComp + 1
+ 12         Continue
+ 11      Continue
+*
+         Call MltNuc(CoorO,Chrg,Centr,kCentr,
+     &               Nuc,iMltpl,nComp)
+*--- pow hack
+         If(iMltpl.eq.0) Then
+            Call Put_dScalar('Total Nuclear Charge',Nuc)
+         End If
+*--- pow hack
+         nOrdOp=iMltpl
+         Call OneEl(MltInt,MltMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        Write FMM multipole moments to disk
+*
+         If (.Not.Prprt.and.DoFMM) Then
+            Write (Label,'(A,I2)') 'FMMInt', iMltpl
+            Call OneEl(MltInt,MltMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+*
+*           FMM overlap distribution centres:
+*           Pretend they are 1-e integrals with three (x,y,z)
+*           components and write to disk in canonical order
+*
+            If(iMltpl.eq.0) Then
+               Write (Label,'(A)') 'FMMCnX'
+               Call OneEl(MltInt,MltMem,Label,ipList,OperI,
+     &                 nComp,CoorO,nOrdOp+1,Nuc,rHrmt,
+     &                 OperC,dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+               Write (Label,'(A)') 'FMMCnY'
+               Call OneEl(MltInt,MltMem,Label,ipList,OperI,
+     &                 nComp,CoorO,nOrdOp+1,Nuc,rHrmt,
+     &                 OperC,dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+               Write (Label,'(A)') 'FMMCnZ'
+               Call OneEl(MltInt,MltMem,Label,ipList,OperI,
+     &                 nComp,CoorO,nOrdOp+1,Nuc,rHrmt,
+     &                 OperC,dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            End If
+         End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        For picture-change corrected integrals.
+*
+         If (DKroll.and.Primitive_Pass) Then
+            Write (Label,'(A,I2)') 'pMp   ', iMltpl
+            PLabel='MltInt'
+            Call FZero(Nuc,nComp)
+            Call OneEl(PXPInt,PXPMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp+2,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+         If (iMltpl.eq.0) Then
+*           these are overlap integrals...
+*           set center selector in OneSwi to single center...
+            NDDO = .TRUE.
+            Write (Label,'(A,I2)') 'MltplS', iMltpl
+            Call OneEl(MltInt,MltMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+*           reset center selector in OneSwi to all centers...
+            NDDO = .FALSE.
+         End If
+*
+         Call Deallocate_Auxiliary()
+*
+ 10   Continue
+************************************************************************
+************************************************************************
+*1a)                                                                   *
+*                                                                      *
+*     PAM integrals                                                    *
+*                                                                      *
+*                                                                      *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (lPAM2np.and..Not.Primitive_Pass) Then
+         Call molcas_open(28,'R_vect')
+         PLabel=' '
+         rHrmt = One
+         iPAMcount=1
+        Do 348 kCnttpPAM = 1, nCnttp
+
+           iAddr=ipPAM2xp(kCnttpPAM)
+           nPAMltpl=nPAM2(kCnttpPAM)
+
+           If(nPAMltpl.lt.0) Go To 348
+           Do 347 iPAMltpl=0,nPAMltpl
+              nOrdOp= iPAMltpl
+              nComp =(iPAMltpl+1)*(iPAMltpl+2)/2
+              iPAMPrim=Int(Work(iAddr))
+              iPAMBas =Int(Work(iAddr+1))
+
+              if(iPAMBas.eq.0.or.iPAMPrim.eq.0) go to 3471
+              Call dcopy_(3,Zero,0,Ccoor,1)
+              Call Allocate_Auxiliary()
+              Do iComp=0,nComp-1
+                 Call dcopy_(3,Work(ipCntr(kCnttpPAM)),
+     &                      1,CoorO(1+3*iComp),1)
+              End Do
+*
+*****    Define symmetry properties of the operator:
+*
+         iComp=0
+         Do 111 ix = iPAMltpl, 0, -1
+            If (Mod(ix,2).eq.0) Then
+               iSymX=1
+            Else
+               ixyz=1
+               iSymX=2**IrrFnc(ixyz)
+               If (Ccoor(1).ne.Zero) iSymX = iOr(iSymX,1)
+            End If
+            Do 121 iy = iPAMltpl-ix, 0, -1
+               If (Mod(iy,2).eq.0) Then
+                  iSymY=1
+               Else
+                  ixyz=2
+                  iSymY=2**IrrFnc(ixyz)
+                  If (Ccoor(2).ne.Zero) iSymY = iOr(iSymY,1)
+               End If
+               iz = iPAMltpl-ix-iy
+               If (Mod(iz,2).eq.0) Then
+                  iSymZ=1
+               Else
+                  ixyz=4
+                  iSymZ=2**IrrFnc(ixyz)
+                  If (Ccoor(3).ne.Zero) iSymZ = iOr(iSymZ,1)
+               End If
+               iChO = Mod(ix,2)*iChBas(2)
+     &              + Mod(iy,2)*iChBas(3)
+     &              + Mod(iz,2)*iChBas(4)
+*
+               OperC(1+iComp) = iChO
+               OperI(1+iComp) = 1
+*
+               iComp = iComp + 1
+ 121        Continue
+ 111     Continue
+*
+*****    Loop over basis finction
+*
+         Call mma_allocate(PAMexp,iPAMPrim,2,label='PAMexp')
+         Call dcopy_(iPAMPrim,Work(iAddr+2),1,PAMexp(1,1),1)
+         Do iPAMf=1,iPAMBas
+            Call dcopy_(iPAMPrim,Work(iAddr+2+iPAMPrim*iPAMf),1,
+     &                  PAMexp(1,2),1)
+            Write (Label,'(A,I2.2,I1.1,I2.2)')
+     &             'PAM', kCnttpPAM,iPAMltpl,iPAMf
+*
+
+            Call dcopy_(nComp,Zero,0,Nuc,1)
+
+            Call OneEl(PAM2Int,PAM2Mem, Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+
+c           iPAMcount=iPAMcount+1
+*
+         End Do
+         Call mma_deallocate(PAMexp)
+         Call Deallocate_Auxiliary()
+ 3471    iAddr=iAddr+2+iPAMPrim*(iPAMBas+1)
+ 347     Continue
+ 348    Continue
+      close(28)
+      End If
+************************************************************************
+************************************************************************
+*2)                                                                    *
+*                                                                      *
+*     Kinetic energy, nuclear attraction and ECP/PP integrals          *
+*                                                                      *
+*     Mass-velocity and One-electron Darwin contact term integrals.    *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+      nComp=1
+*
+      If (.Not.Prprt) Then
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Zero,0,CoorO,1)
+         OperI(1) = 1
+         OperC(1) = iChBas(1)
+*
+         Label='Kinetic '
+         nOrdOp = 2
+         Call OneEl(KnEInt,KnEMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         nOrdOp = 0
+*
+         Label='Attract '
+         Call OneEl(NAInt,NAMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,PotNuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+#ifdef _FDE_
+         ! Embedding
+         if (embPot) then
+          Label='Embpot '
+          Call OneEl(EmbPotKernel,EmbPotMem,Label,ipList,OperI,nComp,
+     &               CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &               dum,1,dum,idum,0,0,
+     &               dum,1,0)
+         end if
+#endif
+
+*        set center selector in OneSwi to two center NA Int...
+         NDDO = .TRUE.
+         Label='AttractS'
+         Call OneEl(NAInt,NAMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,PotNuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*        reset center selector in OneSwi to all centers...
+         NDDO = .FALSE.
+         If (lECPnp.and..Not.Primitive_Pass) Then
+*
+            Label='PrjInt  '
+            Call OneEl(PrjInt,PrjMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            Label='M1Int   '
+            Call OneEl(M1Int, M1Mem, Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            Label='M2Int   '
+            Call OneEl(M2Int, M2Mem, Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            Label='SROInt  '
+            Call OneEl(SROInt,SROMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If     ! lECPnp
+         If (lPP.and..Not.Primitive_Pass) Then
+            Label='PPInt   '
+            Call OneEl(PPInt,PPMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If
+         If (lXF.and..Not.Primitive_Pass) Then
+            mOrdOp=nOrd_XF
+            Label='XFdInt  '
+            Call OneEl(XFdInt,XFdMem,Label,ipList,OperI,nComp,
+     &                 CoorO,mOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If     ! lXF
+         If (lRel.and..Not.Primitive_Pass) Then
+            Label='MassVel '
+            nOrdOp=4
+            Call OneEl(MVeInt,MVeMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            Label='Darwin  '
+            nOrdOp=0
+            Call OneEl(D1Int,D1Mem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If     ! lRel
+*
+         Call Deallocate_Auxiliary()
+      End If
+************************************************************************
+************************************************************************
+*8a)                                                                   *
+*                                                                      *
+*     Velocity integrals.                                              *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=-One
+      If (Vlct.and..Not.Primitive_Pass) Then
+         nOrdOp = 1
+         Label='Velocity'
+         nComp = 3
+         Call Allocate_Auxiliary()
+         Call dcopy_(3*nComp,Zero,0,CoorO,1)
+         ixyz=1
+         OperI(1  ) = 2**IrrFnc(ixyz)
+         OperC(1  ) = iChBas(2)
+         ixyz=2
+         OperI(1+1) = 2**IrrFnc(ixyz)
+         OperC(1+1) = iChBas(3)
+         ixyz=4
+         OperI(1+2) = 2**IrrFnc(ixyz)
+         OperC(1+2) = iChBas(4)
+*
+         Call dcopy_(3,Zero,0,Nuc,1)
+         Call OneEl(VeInt,VeMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+      End If    ! Vlct
+************************************************************************
+************************************************************************
+*8b)                                                                   *
+*                                                                      *
+*     Electromagnetic field radiation integrals.                       *
+*                                                                      *
+*     Note that the integral is not symmetric or antisymmetric!        *
+*                                                                      *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=-One ! Note used
+      If (EMFR.and..Not.Primitive_Pass) Then
+*
+*        The second term in eq. 14 of Bernadotte et al
+*
+         nOrdOp = 0
+         Label='EMFR0'
+         nComp = 2
+         Call Allocate_Auxiliary()
+*        Here we put in the k-vector
+         Call FZero(CoorO,3*nComp)
+         Call dcopy_(3,KVector,1,CoorO,1)
+*
+*        The electromagnetic field operator contributes to all
+*        irreducible irreps, hence OperI=255. Since the operator
+*        it self is not symmetry adopted OperC is set to a dummy value.
+*
+         OperI(1   ) = 255
+         OperI(1+1 ) = 255
+         OperC(1   ) = 0 ! Dummy
+         OperC(1+1 ) = 0 ! Dummy
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(EMFInt,EMFMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+*
+*        The first (dominating) term in eq. 14 of Bernadotte et al
+*
+         nOrdOp = 1
+         Label='EMFR'
+         nComp = 12
+         Call Allocate_Auxiliary()
+*        Here we put in the k-vector
+         Call FZero(CoorO,3*nComp)
+         Call dcopy_(3,KVector,1,CoorO,1)
+*
+*        The electromagnetic field operator contributes to all
+*        irreducible irreps, hence OperI=255. Since the operator
+*        it self is not symmetry adopted OperC is set to a dummy value.
+*
+         OperI(1   ) = 255
+         OperI(1+1 ) = 255
+         OperI(1+2 ) = 255
+         OperI(1+3 ) = 255
+         OperI(1+4 ) = 255
+         OperI(1+5 ) = 255
+         OperI(1+6 ) = 255
+         OperI(1+7 ) = 255
+         OperI(1+8 ) = 255
+         OperI(1+9 ) = 255
+         OperI(1+10) = 255
+         OperI(1+11) = 255
+         OperC(1   ) = 0 ! Dummy
+         OperC(1+1 ) = 0 ! Dummy
+         OperC(1+2 ) = 0 ! Dummy
+         OperC(1+3 ) = 0 ! Dummy
+         OperC(1+4 ) = 0 ! Dummy
+         OperC(1+5 ) = 0 ! Dummy
+         OperC(1+6 ) = 0 ! Dummy
+         OperC(1+7 ) = 0 ! Dummy
+         OperC(1+8 ) = 0 ! Dummy
+         OperC(1+9 ) = 0 ! Dummy
+         OperC(1+10) = 0 ! Dummy
+         OperC(1+11) = 0 ! Dummy
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(EMFInt,EMFMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+      End If    ! EMFR
+************************************************************************
+************************************************************************
+*9)                                                                    *
+*10)                                                                   *
+*                                                                      *
+*     Electric field integrals.                                        *
+*     Electric field gradient integrals.                               *
+*                                                                      *
+************************************************************************
+************************************************************************
+      ixyz=1
+      iSymX = 2**IrrFnc(ixyz)
+      ixyz=2
+      iSymY = 2**IrrFnc(ixyz)
+      ixyz=4
+      iSymZ = 2**IrrFnc(ixyz)
+      ixyz=3
+      iSymXY = 2**IrrFnc(ixyz)
+      ixyz=5
+      iSymXZ = 2**IrrFnc(ixyz)
+      ixyz=6
+      iSymYZ = 2**IrrFnc(ixyz)
+      ixyz=7
+      iSyXYZ = 2**IrrFnc(ixyz)
+*
+      PLabel=' '
+      rHrmt=One
+      Do nOrdOp = 0, nOrdEF
+*
+         nComp = (nOrdOp+1)*(nOrdOp+2)/2
+*
+         Call Allocate_Auxiliary()
+*
+      Do iEF = 1, nEF
+*
+*        Note that this parsing is a bit different here!
+*
+         Write (Label,'(A,I1,I5)') 'EF',nOrdOp,iEF
+         Call dcopy_(3,Work(ipEF+(iEF-1)*3),1,Ccoor,1)
+*
+         iSymR(0) = 1
+         If (Ccoor(1).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymX)
+         If (Ccoor(2).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymY)
+         If (Ccoor(3).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymXY)
+         If (Ccoor(1).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymXZ)
+         If (Ccoor(2).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymYZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero .and.
+     &       Ccoor(3).ne.Zero) iSymR(0) = iOr(iSymR(0),iSyXYZ)
+*
+         ixyz=1
+         iSym=2**IrrFnc(ixyz)
+         If (Ccoor(1).ne.Zero ) iSym = iOr(iSym,1)
+         iSymR(1)=iSym
+*
+         ixyz=2
+         iSym=2**IrrFnc(ixyz)
+         If (Ccoor(2).ne.Zero ) iSym = iOr(iSym,1)
+         iSymR(2)=iSym
+*
+         ixyz=4
+         iSym=2**IrrFnc(ixyz)
+         If (Ccoor(3).ne.Zero ) iSym = iOr(iSym,1)
+         iSymR(3)=iSym
+*
+         iComp=0
+         Do ix = nOrdOp, 0, -1
+            Do iy = nOrdOp-ix, 0, -1
+               iz=nOrdOp-ix-iy
+               iComp = iComp + 1
+*
+               iSymX=1
+               If (Mod(ix,2).ne.0) iSymX=iSymR(1)
+               iSymCX=MltLbl(iSymR(0),iSymX,nIrrep)
+               iSymY=1
+               If (Mod(iy,2).ne.0) iSymY=iSymR(2)
+               iSymCXY=MltLbl(iSymCX,iSymY,nIrrep)
+               iSymZ=1
+               If (Mod(iz,2).ne.0) iSymZ=iSymR(3)
+*
+               OperI(1+(iComp-1)) = MltLbl(iSymCXY,iSymZ,nIrrep)
+               OperC(1+(iComp-1)) = Mod(ix,2)*iChBas(2)
+     &                              + Mod(iy,2)*iChBas(3)
+     &                              + Mod(iz,2)*iChBas(4)
+*
+               Call dcopy_(3,Ccoor,1,CoorO(1+(iComp-1)*3),1)
+            End Do
+         End Do
+*
+         Call EFNuc(CoorO,Chrg,Centr,kCentr,
+     &               Nuc,nOrdOp)
+         Call OneEl(EFInt,EFMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        For picture-change corrected property integrals.
+*
+         If (DKroll.and.Primitive_Pass) Then
+            Write (Label,'(A,I1,I5)') 'PP',nOrdOp,iEF
+            PLabel='EFInt '
+            Call FZero(Nuc,nComp)
+            Call OneEl(PXPInt,PXPMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp+2,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      End Do
+         Call Deallocate_Auxiliary()
+*
+* For a properties calculation, read the EF values saved in a temp file
+* and write the sum through Add_Info
+*
+         If (PrPrt.and.nEF.gt.0) Then
+           Call mma_allocate(PtEl,nComp,label='PtEl')
+           Call mma_allocate(PtNuc,nComp,label='PtNuc')
+           Call mma_allocate(SumEl,nComp,label='SumEl')
+           Call mma_allocate(SumNuc,nComp,label='SumNuc')
+           Call FZero(SumEl,nComp)
+           Call FZero(SumNuc,nComp)
+*          Read and sum the values
+           LuTmp=10
+           Call DaName(LuTmp,'TMPPRP')
+           iDisk=0
+           Do iEf=1,nEF
+             Call dDaFile(LuTmp,2,PtEl,nComp,iDisk)
+             Call dDaFile(LuTmp,2,PtNuc,nComp,iDisk)
+             Call DaXpY_(nComp,One,PtEl,1,SumEl,1)
+             Call DaXpY_(nComp,One,PtNuc,1,SumNuc,1)
+           End Do
+           Call DaClos(LuTmp)
+*          set the tolerance according to the total number of centers
+*          (assuming error scales with sqrt(nEF))
+           iTol=5
+           iTol=iTol-NInt(Half*Log10(Dble(nEF)))
+           Write (label,'(a,i1,a)') 'EF',nOrdOp,'   el'
+           Call Add_Info(label,SumEl,nComp,iTol)
+           Write (label,'(a,i1,a)') 'EF',nOrdOp,'  nuc'
+           Call Add_Info(label,SumNuc,nComp,iTol)
+           Call mma_deallocate(PtEl)
+           Call mma_deallocate(PtNuc)
+           Call mma_deallocate(SumEl)
+           Call mma_deallocate(SumNuc)
+         End If
+*
+      End Do
+************************************************************************
+************************************************************************
+*12)                                                                   *
+*                                                                      *
+*     Orbital angular momentum integrals.                              *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=-One
+      If (lOAM.and..Not.Primitive_Pass) Then
+         Label='AngMom  '
+         nComp = 3
+         nOrdOp = 2
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Work(ipOAM),1,CoorO(1  ),1)
+         Call dcopy_(3,Work(ipOAM),1,CoorO(1+3),1)
+         Call dcopy_(3,Work(ipOAM),1,CoorO(1+6),1)
+         Call dcopy_(3,Work(ipOAM),1,Ccoor,1)
+         ixyz=1
+         iSymX = 2**IrrFnc(ixyz)
+         ixyz=2
+         iSymY = 2**IrrFnc(ixyz)
+         ixyz=4
+         iSymZ = 2**IrrFnc(ixyz)
+         iSymCx = iSymX
+         If (Ccoor(1).ne.Zero) iSymCx = iOr(iSymCx,1)
+         iSymCy = iSymY
+         If (Ccoor(2).ne.Zero) iSymCy = iOr(iSymCy,1)
+         iSymCz = iSymZ
+         If (Ccoor(3).ne.Zero) iSymCz = iOr(iSymCz,1)
+*
+         iSymLx = iOr(MltLbl(iSymCy,iSymZ,nIrrep),
+     &                MltLbl(iSymCz,iSymY,nIrrep))
+         iChOx = iChBas(3) + iChBas(4)
+         OperI(1  ) = iSymLx
+         OperC(1  ) = iChOx
+         iSymLy = iOr(MltLbl(iSymCz,iSymX,nIrrep),
+     &                MltLbl(iSymCx,iSymZ,nIrrep))
+         iChOy = iChBas(4) + iChBas(2)
+         OperI(1+1) = iSymLy
+         OperC(1+1) = iChOy
+         iSymLz = iOr(MltLbl(iSymCx,iSymY,nIrrep),
+     &                MltLbl(iSymCy,iSymX,nIrrep))
+         iChOz = iChBas(2) + iChBas(3)
+         OperI(1+2) = iSymLz
+         OperC(1+2) = iChOz
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(OAMInt,OAMMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+      End If   ! lOAM
+************************************************************************
+************************************************************************
+*12b)                                                                  *
+*                                                                      *
+*     Orbital Magnetic Quadrupole integrals.                           *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=-One
+      If (lOMQ.and..Not.Primitive_Pass) Then
+         Label='OMQ     '
+         nComp = 9
+         nOrdOp = 3
+         Call Allocate_Auxiliary()
+*
+         Call dcopy_(nComp,Work(ipOMQ  ),0,CoorO(1  ),3) ! Change from 3 to ncomp?
+         Call dcopy_(nComp,Work(ipOMQ+1),0,CoorO(1+1),3)
+         Call dcopy_(nComp,Work(ipOMQ+2),0,CoorO(1+2),3)
+         Call dCopy_(3,Work(ipOMQ),1,Ccoor,1) ! Should then not all be copied?
+*
+         ixyz=1
+         iSymX = 2**IrrFnc(ixyz)
+         ixyz=2
+         iSymY = 2**IrrFnc(ixyz)
+         ixyz=4
+         iSymZ = 2**IrrFnc(ixyz)
+         iSymCx = iSymX
+         If (Ccoor(1).ne.Zero) iSymCx = iOr(iSymCx,1)
+         iSymCy = iSymY
+         If (Ccoor(2).ne.Zero) iSymCy = iOr(iSymCy,1)
+         iSymCz = iSymZ
+         If (Ccoor(3).ne.Zero) iSymCz = iOr(iSymCz,1)
+*
+         iSymLx = iOr(MltLbl(iSymCy,iSymZ,nIrrep),
+     &                MltLbl(iSymCz,iSymY,nIrrep))
+         iSymLy = iOr(MltLbl(iSymCz,iSymX,nIrrep),
+     &                MltLbl(iSymCx,iSymZ,nIrrep))
+         iSymLz = iOr(MltLbl(iSymCx,iSymY,nIrrep),
+     &                MltLbl(iSymCy,iSymX,nIrrep))
+*
+* Calculates M_ij = r_j*L_i + L_i*r_j = 2*r_j*L_i + i hbar E_ijk r_k
+* Since the i hbar is included outside we could do
+* M_ij = r_j*L_i + L_i*r_j = 2*r_j*L_i + E_ijk r_k
+* We use all nine components even if we only need 6 of these later.
+*
+* Mxx
+         iSymxLx = MltLbl(iSymCx,iSymLx,nIrrep)
+         iChOxx = iChBas(15)
+         OperI(1  ) = iSymxLx
+         OperC(1  ) = iChOxx
+* Mxy
+         iSymxLy = iSymCz
+         iChOxy = iChBas(4)
+         OperI(1+1) = iSymxLy
+         OperC(1+1) = iChOxy
+* Mxz
+         iSymxLz = iSymCy
+         iChOxz = iChBas(3)
+         OperI(1+2) = iSymxLz
+         OperC(1+2) = iChOxz
+* Myx
+         iSymyLx = iSymCz
+         iChOyx = iChBas(4)
+         OperI(1+3) = iSymyLx
+         OperC(1+3) = iChOyx
+* Myy
+         iSymyLy = MltLbl(iSymCy,iSymLy,nIrrep)
+         iChOyy = iChBas(15)
+         OperI(1+4) = iSymyLy
+         OperC(1+4) = iChOyy
+* Myz
+         iSymyLz = iSymCx
+         iChOyz = iChBas(4)
+         OperI(1+5) = iSymyLz
+         OperC(1+5) = iChOyz
+* Mzx
+         iSymzLx = iSymCy
+         iChOzx = iChBas(3)
+         OperI(1+6) = iSymzLx
+         OperC(1+6) = iChOzx
+* Mzy
+         iSymzLy = iSymCx
+         iChOzy = iChBas(4)
+         OperI(1+7) = iSymzLy
+         OperC(1+7) = iChOzy
+* Mzz
+         iSymzLz = MltLbl(iSymCz,iSymLz,nIrrep)
+         iChOzz = iChBas(15)
+         OperI(1+8) = iSymzLz
+         OperC(1+8) = iChOzz
+*
+         Call DCopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(OMQInt,OMQMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+      End If   ! lOMQ
+************************************************************************
+************************************************************************
+*13)                                                                   *
+*                                                                      *
+*                                                                      *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (DKroll.and.Primitive_Pass) then
+         rHrmt=One
+         Label='pVp     '
+         PLabel='NAInt '
+         nOrdOp=2
+         nComp = 1
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Zero,0,CoorO,1)
+         OperI(1  ) = 1
+         OperC(1  ) = iChBas(1)
+
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(PXPInt,PXPMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+
+         Call Deallocate_Auxiliary()
+*
+         If (BSS) Then
+            rHrmt=-One
+            nOrdOp = 1
+            nComp = 3
+            Call Allocate_Auxiliary()
+*
+            Call dcopy_(3*nComp,Zero,0,CoorO,1)
+            Call dcopy_(3,Zero,0,Nuc,1)
+*
+            ixyz=1
+            OperI(1  ) = 2**IrrFnc(ixyz)
+            OperC(1  ) = iChBas(2)
+            ixyz=2
+            OperI(1+1) = 2**IrrFnc(ixyz)
+            OperC(1+1) = iChBas(3)
+            ixyz=4
+            OperI(1+2) = 2**IrrFnc(ixyz)
+            OperC(1+2) = iChBas(4)
+*
+            Label='pV      '
+            PLabel='NAInt '
+            Call OneEl(PXInt,PXMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+*
+            Label='Vp      '
+            Call OneEl(VPInt,VPMem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+*
+            Call Deallocate_Auxiliary()
+         End If    ! BSSInt
+      End If
+************************************************************************
+************************************************************************
+*14)                                                                   *
+*                                                                      *
+*     Diamagnetic shielding integrals.                                 *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+*
+      mDMS=nDMS
+      If (Primitive_Pass) mDMS=0
+*
+      Do 1500 iDMS = 1, mDMS
+         Write (Label,'(A,I2,I2)') 'DMS ',1,iDMS
+         nComp = 9
+         nOrdOp=2
+         Call dcopy_(3,Work(ipDMS+(iDMS-1)*3),1,Ccoor,1)
+         Call Allocate_Auxiliary()
+         iSymC = 1
+         If (Ccoor(1).ne.Zero) iSymC = iOr(iSymC,iSymX)
+         If (Ccoor(2).ne.Zero) iSymC = iOr(iSymC,iSymY)
+         If (Ccoor(3).ne.Zero) iSymC = iOr(iSymC,iSymZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero)
+     &      iSymC = iOr(iSymC,iSymXY)
+         If (Ccoor(1).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymC = iOr(iSymC,iSymXZ)
+         If (Ccoor(2).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymC = iOr(iSymC,iSymYZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero .and.
+     &       Ccoor(3).ne.Zero) iSymC = iOr(iSymC,iSyXYZ)
+*
+         iComp = 0
+         iC = 0
+         Do 1510 ix = 1, 0, -1
+         Do 1510 iy = 1-ix, 0, -1
+            iz=1-ix-iy
+            iC = iC + 1
+            iChO1 = iChBas(iC+1)
+            ixyz=0
+            If (Mod(ix,2).ne.0) ixyz=iOr(ixyz,1)
+            If (Mod(iy,2).ne.0) ixyz=iOr(ixyz,2)
+            If (Mod(iz,2).ne.0) ixyz=iOr(ixyz,4)
+            iSym = 2**IrrFnc(ixyz)
+            If (Ccoor(iC).ne.Zero) iSym = iOr(iSym,1)
+            iD = 0
+            Do 1511 jx = 1, 0, -1
+            Do 1511 jy = 1-jx, 0, -1
+               jz=1-jx-jy
+               iD = iD + 1
+               iChO2 = iChBas(iD+1)
+               jxyz=0
+               If (Mod(jx,2).ne.0) jxyz=iOr(jxyz,1)
+               If (Mod(jy,2).ne.0) jxyz=iOr(jxyz,2)
+               If (Mod(jz,2).ne.0) jxyz=iOr(jxyz,4)
+               iSymD = 2**IrrFnc(jxyz)
+               If (Dxyz(iD).ne.Zero) iSymD = iOr(iSymD,1)
+               If (iC.eq.iD) Then
+                  i2 = iD + 1
+                  If (i2.gt.3) i2 = i2 - 3
+                  i3 = iD + 2
+                  If (i3.gt.3) i3 = i3 - 3
+                  iChO = iAnd(iChBas(i2+1),iChBas(i3+1))
+               Else
+                  iChO = iOr(iChO1,iChO2)
+               End If
+               OperI(1+iComp) = MltLbl(iSymD,MltLbl(iSym,iSymC,
+     &                            nIrrep),nIrrep)
+               OperC(1+iComp) = iChO
+               Call dcopy_(3,Ccoor,1,CoorO(1+iComp*3),1)
+               iComp = iComp + 1
+ 1511       Continue
+ 1510    Continue
+         Call dcopy_(3,Dxyz,1,CoorO(1+3),1)
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(DMSInt,DMSMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+1500  Continue
+************************************************************************
+************************************************************************
+*15)                                                                   *
+*                                                                      *
+*     Nuclear attraction integrals for finite centers.                 *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+      Label='Center  '
+************************************************************************
+************************************************************************
+*16)                                                                   *
+*                                                                      *
+*     Spherical well integrals.                                        *
+*                                                                      *
+************************************************************************
+************************************************************************
+      PLabel=' '
+      rHrmt=One
+      If (.Not.Prprt.and..Not.Primitive_Pass) Then
+         nComp=1
+         iWel = 0
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Zero,0,CoorO,1)
+         OperI(1) = 1
+         OperC(1) = iChBas(1)
+         Do 1600 iWel = 1, nWel
+            r0   = Work(ipWel+(iWel-1)*3  )
+            ExpB = Work(ipWel+(iWel-1)*3+1)
+            Write (Label,'(A,I4)') 'Well',iWel
+            Call OneEl(WelInt,WelMem,Label,ipList,OperI,nComp,
+     &                 CoorO,iWel,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+ 1600    Continue
+         Call Deallocate_Auxiliary()
+      End If  ! .Not.Prprt
+************************************************************************
+************************************************************************
+*5)                                                                    *
+*                                                                      *
+*     One-electron Hamiltonian integrals.                              *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (.Not.Prprt.and..Not.Primitive_Pass) Then
+         Call mma_allocate(KnE_Int,n2Tri(1)+4,label='KnE_Int')
+         Call mma_allocate(NA_Int,n2Tri(1)+4,label='NA_Int')
+#ifdef _FDE_
+         ! Embedding
+         if (embpot) Call mma_allocate(Emb_Int,n2Tri(1)+4,
+     &                                 label='Emb_Int')
+#endif
+         iOpt = 0
+         iRC = -1
+         Label='Kinetic '
+         Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+         If (iRC.ne.0) then
+            Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+            Call Quit(_RC_IO_ERROR_READ_)
+         End If
+         Label='Attract '
+         iRC = -1
+         Call RdOne(iRC,iOpt,Label,1,NA_Int,lOper)
+         If (iRC.ne.0) then
+            Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+            Call Quit(_RC_IO_ERROR_READ_)
+         End If
+         Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+#ifdef _FDE_
+         ! Embedding
+         if (embpot) then
+          if (embPotInBasis) then
+!           write(*,*) "ENTER"
+           ! If the potential is given in basis set representation it
+           ! has not been calculated with a OneEl call and is just read
+           ! from file here.
+           iunit = isFreeUnit(1)
+           call molcas_open(iunit, embPotPath)
+           do iEmb=1, n2Tri(1)
+            read(iunit,*) Emb_Int(iEmb)
+!            write(*,*) iEmb-1, ": ", Emb_Int(iEmb)
+           end do
+           close(iunit)
+          else
+           Label='embpot  '
+           iRC=-1
+           Call RdOne(iRC,iOpt,Label,1,Emb_Int,lOper)
+           If (iRC.ne.0) then
+              Call WarningMessage(2,
+     &                    'Drv1El: Error reading ONEINT;'
+     &                  //'Label='//Label)
+              Call Quit(_RC_IO_ERROR_READ_)
+           End If
+          end if
+          Call DaXpY_(n2Tri(1)+4,One,Emb_Int,1,NA_Int,1)
+         end if
+#endif
+*
+*--------Add contribution from ECP
+*
+         If (lECPnp) Then
+            Label='PrjInt  '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+            Label='M1Int   '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+            Label='M2Int   '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+            Label='SROInt  '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+         End If   ! lECPnp
+*
+*--------Add contributions from the Pseudo Potential
+*
+         If (lPP) Then
+            Label='PPInt   '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+         End If
+*
+*--------Add contributions from the external field
+*
+         If (lXF) Then
+            Label='XFdInt  '
+            iRC = -1
+            Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+            If (iRC.ne.0) then
+               Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+               Call Quit(_RC_IO_ERROR_READ_)
+            End If
+            Call DaXpY_(n2Tri(1)+4,One,KnE_Int,1,NA_Int,1)
+         End If ! lXF
+*
+*--------Add contributions from Spherical wells
+*
+         If (nWel.ne.0) Then
+            Do iWel = 1, nWel
+               Fact=Work(ipWel-1+(iWel-1)*3+3)
+               Write (Label,'(A,I4)') 'Well',iWel
+               iRC = -1
+               Call RdOne(iRC,iOpt,Label,1,KnE_Int,lOper)
+               If (iRC.ne.0) then
+                  Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+                  Call Quit(_RC_IO_ERROR_READ_)
+               End If
+               Call DaXpY_(n2Tri(1)+4,Fact,KnE_Int,1,NA_Int,1)
+            End Do
+         End If  ! nWel.ne.0
+*
+         Label='OneHam  '
+         If (iPrint.ge.10) Call PrMtrx(Label,lOper,1,1,NA_Int)
+         iRC = -1
+         Call WrOne(iRC,iOpt,Label,1,NA_Int,lOper)
+         If (iRC.ne.0) then
+            Call WarningMessage(2,
+     &                  'Drv1El: Error writing ONEINT;'
+     &                //'Label='//Label)
+            Call Quit(_RC_IO_ERROR_WRITE_)
+         End If
+
+#ifdef _FDE_
+         ! Embedding
+         if (embpot) then
+          Label='embpot  '
+          iRC = -1
+          Call WrOne(iRC,iOpt,Label,1,Work(ipEmb),lOper)
+          If (iRC.ne.0) then
+             Call WarningMessage(2,
+     &                   'Drv1El: Error writing ONEINT;'
+     &                 //'Label='//Label)
+             Call Quit(_RC_IO_ERROR_WRITE_)
+          End If
+         end if
+#endif
+*
+         Label='OneHam 0'
+         iRC = -1
+         Call WrOne(iRC,iOpt,Label,1,NA_Int,lOper)
+         If (iRC.ne.0) then
+            Call WarningMessage(2,
+     &                  'Drv1El: Error writing ONEINT;'
+     &                //'Label='//Label)
+            Call Quit(_RC_IO_ERROR_WRITE_)
+         End If
+         Call mma_deallocate(NA_Int)
+         Call mma_deallocate(KnE_Int)
+
+#ifdef _FDE_
+         ! Embedding
+         if (embPot) Call mma_deallocate(Emb_Int)
+#endif
+      End If
+************************************************************************
+************************************************************************
+*17)                                                                   *
+*                                                                      *
+*     Angular momentum products (PAM)                                  *
+*                                                                      *
+************************************************************************
+************************************************************************
+* Hermitized products of angular momentum integrals
+* Component(1) is Lx*Lx
+* Component(2) is (Lx*Ly+Ly*Lx)/2, etc.
+* Coded P-A Malmqvist, Garching, Nov 1996
+      PLabel=' '
+      rHrmt=-One
+      If (lAMP.and..Not.Primitive_Pass) Then
+         Label='AMProd  '
+         nComp = 6
+         nOrdOp = 2
+         Call Allocate_Auxiliary()
+         Call dcopy_(nComp,Work(ipAMP  ),0,CoorO(1  ),3)
+         Call dcopy_(nComp,Work(ipAMP+1),0,CoorO(1+1),3)
+         Call dcopy_(nComp,Work(ipAMP+2),0,CoorO(1+2),3)
+         Call dcopy_(3,Work(ipAMP),1,Ccoor,1)
+C Symmetry labels iSymX  for operator d/dx, etc.
+C Symmetry labels iSymLx for operator Lx, etc.
+C Characters iChOx for operator Lx, etc.
+         ixyz=1
+         iSymX = 2**IrrFnc(ixyz)
+         ixyz=2
+         iSymY = 2**IrrFnc(ixyz)
+         ixyz=4
+         iSymZ = 2**IrrFnc(ixyz)
+         iSymCx = iSymX
+         If (Ccoor(1).ne.Zero) iSymCx = iOr(iSymCx,1)
+         iSymCy = iSymY
+         If (Ccoor(2).ne.Zero) iSymCy = iOr(iSymCy,1)
+         iSymCz = iSymZ
+         If (Ccoor(3).ne.Zero) iSymCz = iOr(iSymCz,1)
+         iSymLx = iOr(MltLbl(iSymCy,iSymZ,nIrrep),
+     &                MltLbl(iSymCz,iSymY,nIrrep))
+         iChOx = iChBas(3) + iChBas(4)
+         iSymLy = iOr(MltLbl(iSymCz,iSymX,nIrrep),
+     &                MltLbl(iSymCx,iSymZ,nIrrep))
+         iChOy = iChBas(4) + iChBas(2)
+         iSymLz = iOr(MltLbl(iSymCx,iSymY,nIrrep),
+     &                MltLbl(iSymCy,iSymX,nIrrep))
+         iChOz = iChBas(2) + iChBas(3)
+
+C Symmetry labels and characters of products. Let G be the full
+C  molecular point group, and Gsub=subgroup of G=stabilizer of
+C gauge origin. The totally symmetric irrep of Gsub can be
+C decomposed into irreps of G.
+C Then symmetry label=packed array of bits, one for each irrep
+C of G. The bit is set, if that irrep is included in the
+C decomposition of the totally symmetric irrep of Gsub.
+         OperI(1  )=MltLbl(iSymLx,iSymLx,nIrrep)
+         OperI(1+1)=MltLbl(iSymLx,iSymLy,nIrrep)
+         OperI(1+2)=MltLbl(iSymLx,iSymLz,nIrrep)
+         OperI(1+3)=MltLbl(iSymLy,iSymLy,nIrrep)
+         OperI(1+4)=MltLbl(iSymLy,iSymLz,nIrrep)
+         OperI(1+5)=MltLbl(iSymLz,iSymLz,nIrrep)
+         OperC(1  )=0
+         OperC(1+1)=iEOr(iChOx,iChOy)
+         OperC(1+2)=iEOr(iChOx,iChOz)
+         OperC(1+3)=0
+         OperC(1+4)=iEOr(iChOy,iChOz)
+         OperC(1+5)=0
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(AMPInt,AMPMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+      End If
+************************************************************************
+************************************************************************
+*17)                                                                   *
+*                                                                      *
+*     Contact term integrals                                           *
+*                                                                      *
+************************************************************************
+************************************************************************
+      ixyz=1
+      iSymX = 2**IrrFnc(ixyz)
+      ixyz=2
+      iSymY = 2**IrrFnc(ixyz)
+      ixyz=4
+      iSymZ = 2**IrrFnc(ixyz)
+      ixyz=3
+      iSymXY = 2**IrrFnc(ixyz)
+      ixyz=5
+      iSymXZ = 2**IrrFnc(ixyz)
+      ixyz=6
+      iSymYZ = 2**IrrFnc(ixyz)
+      ixyz=7
+      iSyXYZ = 2**IrrFnc(ixyz)
+      PLabel=' '
+      rHrmt=One
+*
+      mCnt=0
+      If (nOrdEF.eq.2) mCnt=nEF
+*
+      nComp = 1
+      nOrdOp = 1
+      Do iCnt = 1, mCnt
+         Write (Label,'(A,I5)') 'Cnt',iCnt
+         Call dcopy_(3,Work(ipEF+(iCnt-1)*3),1,Ccoor,1)
+         Call Allocate_Auxiliary()
+*
+         iSymR(0) = 1
+         If (Ccoor(1).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymX)
+         If (Ccoor(2).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymY)
+         If (Ccoor(3).ne.Zero) iSymR(0) = iOr(iSymR(0),iSymZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymXY)
+         If (Ccoor(1).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymXZ)
+         If (Ccoor(2).ne.Zero .and. Ccoor(3).ne.Zero)
+     &      iSymR(0) = iOr(iSymR(0),iSymYZ)
+         If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero .and.
+     &       Ccoor(3).ne.Zero) iSymR(0) = iOr(iSymR(0),iSyXYZ)
+*
+         OperI(1) = iSymR(0)
+         OperC(1) = 0
+*
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(CntInt,CntMem,Label,ipList,OperI,nComp,
+     &              Ccoor,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*        For picture-change corrected integrals.
+*
+         If (DKroll.and.Primitive_Pass) Then
+            Write (Label,'(A,I2)') 'pCp   ', iCnt
+            PLabel='CntInt'
+            Call FZero(Nuc,nComp)
+            Call OneEl(PXPInt,PXPMem,Label,ipList,OperI,nComp,
+     &                 CCoor,nOrdOp+2,Nuc,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+         End If
+*
+         Call Deallocate_Auxiliary()
+      End Do
+*
+* For a properties calculation, read the CNT values saved in a temp file
+* and write the sum through Add_Info
+*
+      If (PrPrt.and.mCnt.gt.0) Then
+        SumEl=Zero
+        SumNuc=Zero
+*       Read and sum the values
+        LuTmp=10
+        Call DaName(LuTmp,'TMPPRP')
+        iDisk=0
+        Do iCnt=1,mCnt
+          Call dDaFile(LuTmp,2,PtEl,1,iDisk)
+          Call dDaFile(LuTmp,2,PtNuc,1,iDisk)
+          SumEl=SumEl+PtEl
+          SumNuc=SumNuc+PtNuc
+        End Do
+        Call DaClos(LuTmp)
+*       set the tolerance according to the total number of centers
+*       (assuming error scales with sqrt(mCnt))
+        iTol=5
+        iTol=iTol-NInt(Half*Log10(Dble(mCnt)))
+        Write (label,'(a,a)') 'CNT','   el'
+        Call Add_Info(label,SumEl,1,iTol)
+        Write (label,'(a,a)') 'CNT','  nuc'
+        Call Add_Info(label,SumNuc,1,iTol)
+      End If
+*
+************************************************************************
+************************************************************************
+*18)                                                                   *
+*     Gradient of overlap integrals with respect to the magnetic field *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (GIAO.and..Not.Primitive_Pass) Then
+      PLabel=' '
+      rHrmt=-One
+      nB=3
+      iLow = 0
+      mMltpl=0 ! Do only overlap.
+C     mMltpl=-1 ! Do only overlap.
+      Do iMltpl = iLow, mMltpl
+         Write (Label,'(A,I2)') 'dMP/dB', iMltpl
+         mComp = (iMltpl+1)*(iMltpl+2)/2
+         nComp = mComp * nB
+         Call DCopy_(3,Coor_MpM(1,iMltpl+1),1,Ccoor,1)
+         Call Allocate_Auxiliary()
+*
+         iComp=0
+         Do ix = iMltpl, 0, -1
+*
+*---------- Pick up which irrep each of the cartesian components of
+*           the operator belongs to. If the operator is associated
+*           with a center other than origin add the total symmetric
+*           irrep.
+*
+            If (Mod(ix,2).eq.0) Then
+               iSymX=1
+            Else
+               ixyz=1
+               iSymX=2**IrrFnc(ixyz)
+               If (Ccoor(1).ne.Zero) iSymX = iOr(iSymX,1)
+            End If
+            Do iy = iMltpl-ix, 0, -1
+               If (Mod(iy,2).eq.0) Then
+                  iSymY=1
+               Else
+                  ixyz=2
+                  iSymY=2**IrrFnc(ixyz)
+                  If (Ccoor(2).ne.Zero) iSymY = iOr(iSymY,1)
+               End If
+               iz = iMltpl-ix-iy
+               If (Mod(iz,2).eq.0) Then
+                  iSymZ=1
+               Else
+                  ixyz=4
+                  iSymZ=2**IrrFnc(ixyz)
+                  If (Ccoor(3).ne.Zero) iSymZ = iOr(iSymZ,1)
+               End If
+*
+*------------- Multiply cartesian components to generate which irreps
+*              the current element of the multipole moment operator
+*              belong to. The lowest significant bit if set indicate that
+*              a particular irrep is included.
+*
+               iTemp = MltLbl(iSymX,MltLbl(iSymY,iSymZ,nIrrep),nIrrep)
+*
+               iChO = Mod(ix,2)*iChBas(2)
+     &              + Mod(iy,2)*iChBas(3)
+     &              + Mod(iz,2)*iChBas(4)
+*
+*------------- Now combine with the character of the first derivative
+*              with respect to the magnetic field.
+*
+               iSymRx=2**IrrFnc(1)
+               iSymRy=2**IrrFnc(2)
+               iSymRz=2**IrrFnc(4)
+*
+               iB = 1
+               iChOx = Mod(ix  ,2)*iChBas(2)
+     &               + Mod(iy+1,2)*iChBas(3)
+     &               + Mod(iz+1,2)*iChBas(4)
+               OperC(1+(iB-1)*mComp+iComp) = iChOx
+               iSymBx = MltLbl(iSymRy,iSymRz,nIrrep)
+               OperI(1+(iB-1)*mComp+iComp) =
+     &            MltLbl(iTemp,iSymBx,nIrrep)
+               Call DCopy_(3,Coor_MPM(1,iMltpl+1),1,
+     &                      CoorO(1+((iB-1)*mComp+iComp)*3),1)
+*
+               iB = 2
+               iChOy = Mod(ix+1,2)*iChBas(2)
+     &               + Mod(iy  ,2)*iChBas(3)
+     &               + Mod(iz+1,2)*iChBas(4)
+               OperC(1+(iB-1)*mComp+iComp) = iChOy
+               iSymBy = MltLbl(iSymRz,iSymRx,nIrrep)
+               OperI(1+(iB-1)*mComp+iComp) =
+     &            MltLbl(iTemp,iSymBy,nIrrep)
+               Call DCopy_(3,Coor_MPM(1,iMltpl+1),1,
+     &                      CoorO(1+((iB-1)*mComp+iComp)*3),1)
+*
+               iB = 3
+               iChOz = Mod(ix+1,2)*iChBas(2)
+     &               + Mod(iy+1,2)*iChBas(3)
+     &               + Mod(iz  ,2)*iChBas(4)
+               OperC(1+(iB-1)*mComp+iComp) = iChOz
+               iSymBz = MltLbl(iSymRx,iSymRy,nIrrep)
+               OperI(1+(iB-1)*mComp+iComp) =
+     &            MltLbl(iTemp,iSymBz,nIrrep)
+               Call DCopy_(3,Coor_MPM(1,iMltpl+1),1,
+     &                      CoorO(1+((iB-1)*mComp+iComp)*3),1)
+*
+               iComp = iComp + 1
+            End Do
+         End Do
+*
+*        Zero nuclear contribution.
+         Call dcopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(MltInt_GIAO,MltMem_GIAO,
+     &              Label,ipList,OperI,nComp,
+     &              CoorO,iMltpl,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+*
+      End Do
+*
+      End If
+************************************************************************
+************************************************************************
+*19)                                                                   *
+*     Atomic mean field integrals for spin-orbit calculations          *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (lAMFI.and..Not.Prprt.and..Not.Primitive_Pass) Then
+         PLabel=' '
+         rHrmt=-One
+         Label='AMFI    '
+         nComp = 3
+         Call Allocate_Auxiliary()
+         OperI(1  )=2**IrrFnc(6)
+         OperC(1  )=iChBas(7)
+         OperI(1+1)=2**IrrFnc(5)
+         OperC(1+1)=iChBas(6)
+         OperI(1+2)=2**IrrFnc(3)
+         OperC(1+2)=iChBas(4)
+
+* BP - Turn off AMFI integrals for certain atom types
+*      as requested by the PAMF keyword
+c         write(6,*) "nPAMFI:", nPAMFI
+c         write(6,*) "iPAMFI:", iPAMFI(1:nPAMFI)
+
+         Do iAtm=1,nCnttp
+           iAtmNr2(iAtm) = iAtmNr(iAtm)
+           Charge2(iAtm) = Charge(iAtm)
+
+c           write(6,*) "iAtmNr2(iAtm)",iAtm, iAtmNr2(iAtm)
+c           write(6,*) "Charge(iAtm)", iAtm, Charge(iAtm)
+
+           do iPAM=1,nPAMFI
+             if(iAtmNr(iAtm).EQ.iPAMFI(iPAM)) then
+               write(6,*) "Disabling AMFI for atom type ",iAtmNr(iAtm)
+               iAtmNr2(iAtm) = 0
+               Charge2(iAtm) = 0.0d0
+             end if
+           end do
+         End do
+
+         Call Gen_RelPointers(-(Info-1))
+         Call Drv_AMFI(Label,ipList,OperI,nComp,rHrmt,
+     &                 OperC, iAtmNr2, Charge2,DInf,nDInf)
+         Call Gen_RelPointers(Info-1)
+
+         Call Deallocate_Auxiliary()
+      End If
+************************************************************************
+************************************************************************
+*KAMAL)                                                                *
+*              GEN1INT                                                 *
+*                                                                      *
+*                                                                      *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (lPSOI.and..Not.Prprt.and..Not.Primitive_Pass) Then
+         PLabel=' '
+         rHrmt=-One
+         nComp = 3
+         Call Get_nAtoms_All(nAtoms)
+         Do iCnt=1, nAtoms
+         Write (Label,'(A,I2)') 'PSOI  ', iCnt
+         nPSOI=iCnt
+         nOrdOp = 1
+         Call Allocate_Auxiliary()
+
+         iComp=0
+         do iComp= 1,nComp
+c FIXME ipPSO is uninitialized
+c        Call DCopy_(3,Work(ipPSO),1,CoorO(1+(iComp-1)*3),1)
+         Call SysAbendMsg('Drv1El',
+     &        'Faulty code (undefined Work index).',
+     &        'Please correct it or contact the developer.')
+         enddo
+
+         ixyz=1
+         iSymX = 2**IrrFnc(ixyz)
+         ixyz=2
+         iSymY = 2**IrrFnc(ixyz)
+         ixyz=4
+         iSymZ = 2**IrrFnc(ixyz)
+         iSymCx = iSymX
+         If (Ccoor(1).ne.Zero) iSymCx = iOr(iSymCx,1)
+         iSymCy = iSymY
+         If (Ccoor(2).ne.Zero) iSymCy = iOr(iSymCy,1)
+         iSymCz = iSymZ
+         If (Ccoor(3).ne.Zero) iSymCz = iOr(iSymCz,1)
+*
+         iSymLx = iOr(MltLbl(iSymCy,iSymZ,nIrrep),
+     &                MltLbl(iSymCz,iSymY,nIrrep))
+         iChOx = iChBas(3) + iChBas(4)
+         OperI(1  ) = iSymLx
+         OperC(1  ) = iChOx
+         iSymLy = iOr(MltLbl(iSymCz,iSymX,nIrrep),
+     &                MltLbl(iSymCx,iSymZ,nIrrep))
+         iChOy = iChBas(4) + iChBas(2)
+         OperI(1+1) = iSymLy
+         OperC(1+1) = iChOy
+         iSymLz = iOr(MltLbl(iSymCx,iSymY,nIrrep),
+     &                MltLbl(iSymCy,iSymX,nIrrep))
+         iChOz = iChBas(2) + iChBas(3)
+         OperI(1+2) = iSymLz
+         OperC(1+2) = iChOz
+
+*        Zero nuclear contribution
+         Call DCopy_(nComp,Zero,0,Nuc,1)
+         Call OneEl(PSOInt,PSOMem,Label,ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+         enddo
+!1555      Continue
+          !Call PrMtrx(Label,lOper,nComp,ip)
+       End If   ! lOAM
+************************************************************************
+************************************************************************
+*20)                                                                   *
+*     The gradient of the kinetic energy and the nuclear attraction    *
+*     energy with respect to the magnetic field.                       *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (GIAO.and..Not.Primitive_Pass) Then
+         PLabel=' '
+         rHrmt=-One
+         nOrdOp = 0
+         nComp = 3
+         Call Allocate_Auxiliary()
+         Call dcopy_(3*nComp,Zero,0,CoorO,1)
+         ixyz=1
+         OperI(1  ) = 2**IrrFnc(ixyz)
+         OperC(1  ) = iChBas(2)
+         ixyz=2
+         OperI(1+1) = 2**IrrFnc(ixyz)
+         OperC(1+1) = iChBas(3)
+         ixyz=4
+         OperI(1+2) = 2**IrrFnc(ixyz)
+         OperC(1+2) = iChBas(4)
+*
+         Call dcopy_(3,Zero,0,Nuc,1)
+*
+         Label='dT/dB   '
+         Call OneEl(KneInt_GIAO,KneMem_GIAO,Label,
+     &              ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         nOrdOp = 1
+         Label='dV/dB   '
+         Call OneEl( NAInt_GIAO, NAMem_GIAO,Label,
+     &              ipList,OperI,nComp,
+     &              CoorO,nOrdOp,Nuc,rHrmt,OperC,
+     &              dum,1,dum,idum,0,0,
+     &              dum,1,0)
+*
+         Call Deallocate_Auxiliary()
+*
+*        Differentiate the generalized kinetic energy operator with respect
+*        to the magnetic moment at the centers.
+*
+         nOrdOp = 1
+         nComp = 3
+         ixyz=1
+         iSymX = 2**IrrFnc(ixyz)
+         ixyz=2
+         iSymY = 2**IrrFnc(ixyz)
+         ixyz=4
+         iSymZ = 2**IrrFnc(ixyz)
+         ixyz=3
+         iSymXY = 2**IrrFnc(ixyz)
+         ixyz=5
+         iSymXZ = 2**IrrFnc(ixyz)
+         ixyz=6
+         iSymYZ = 2**IrrFnc(ixyz)
+         ixyz=7
+         iSyXYZ = 2**IrrFnc(ixyz)
+*
+         iEF = 0
+         Do  iCnttp = 1, nCnttp
+            Do iCnt = 1, nCntr(iCnttp)
+               iEF=iEF+1
+               Write (Label,'(A,I2)') 'dT/dmu',iEF
+               Call dcopy_(3,Work(ipCntr(iCnttp)+(iCnt-1)*3),1,Ccoor,1)
+               Call Allocate_Auxiliary()
+               iSymC = 1
+               If (Ccoor(1).ne.Zero) iSymC = iOr(iSymC,iSymX)
+               If (Ccoor(2).ne.Zero) iSymC = iOr(iSymC,iSymY)
+               If (Ccoor(3).ne.Zero) iSymC = iOr(iSymC,iSymZ)
+               If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero)
+     &            iSymC = iOr(iSymC,iSymXY)
+               If (Ccoor(1).ne.Zero .and. Ccoor(3).ne.Zero)
+     &            iSymC = iOr(iSymC,iSymXZ)
+               If (Ccoor(2).ne.Zero .and. Ccoor(3).ne.Zero)
+     &            iSymC = iOr(iSymC,iSymYZ)
+               If (Ccoor(1).ne.Zero .and. Ccoor(2).ne.Zero .and.
+     &             Ccoor(3).ne.Zero) iSymC = iOr(iSymC,iSyXYZ)
+*
+               iComp=0
+               Do ix = nOrdOp, 0, -1
+                  Do iy = nOrdOp-ix, 0, -1
+                     iComp = iComp + 1
+                     iz = nOrdOp-ix-iy
+                     ixyz=0
+                     If (Mod(ix,2).ne.0) ixyz=iOr(ixyz,1)
+                     If (Mod(iy,2).ne.0) ixyz=iOr(ixyz,2)
+                     If (Mod(iz,2).ne.0) ixyz=iOr(ixyz,4)
+                     iSym = 2**IrrFnc(ixyz)
+                     If (Ccoor(iComp).ne.Zero ) iSym = iOr(iSym,1)
+                     OperI(1+(iComp-1)) = MltLbl(iSymC,iSym,nIrrep)
+                     OperC(1+(iComp-1)) = iChBas(iComp+1)
+                     Call dcopy_(3,Ccoor,1,CoorO(1+(iComp-1)*3),1)
+                  End Do
+               End Do
+*
+*              Call EFNuc(CoorO,Chrg,Centr,kCentr,
+*    &                    Nuc,nOrdOp)
+*
+
+               Call OneEl(dTdmu_Int,dTdmu_Mem,Label,ipList,
+     &                    OperI,nComp,
+     &                    CoorO,nOrdOp,Nuc,rHrmt,
+     &                    OperC,dum,1,dum,idum,0,0,
+     &                    dum,1,0)
+*
+               Call Deallocate_Auxiliary()
+            End Do
+         End Do
+      End If
+************************************************************************
+************************************************************************
+*                                                                      *
+* 21) Atomic Fock matrix                                               *
+*                                                                      *
+************************************************************************
+************************************************************************
+      Call Gen_RelPointers(-(Info-1))
+      PLabel=' '
+      rHrmt=One
+      nComp=1
+      nOrdOp = 0
+      If (.Not.Prprt.and..Not.Primitive_Pass.and.Do_FckInt) Then
+         Call Allocate_Auxiliary()
+         Call dcopy_(3,Zero,0,CoorO,1)
+         OperI(1) = 1
+         OperC(1) = iChBas(1)
+*
+         Label='FckInt  '
+         Call Drv_Fck(Label,ipList,OperI,nComp,
+     &                CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                dum,1,dum,idum,0,0,
+     &                dum,1,0,DInf,nDInf)
+*
+         Call Deallocate_Auxiliary()
+      End If
+      Call Gen_RelPointers(Info-1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*
+*     Deallocate memory for property calculation.
+*
+      If (Prprt) Then
+         If (Short) then
+            Call mma_deallocate(Den)
+         Else
+            Call mma_deallocate(Vec)
+            Call mma_deallocate(Occ)
+         End If
+         Call CollapseOutput(0,'   Molecular properties:')
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Is this the second pass in a relativistic calculation?
+*     In that case: close ONEINT, open ONEREL, read the pVp
+*     integrals, close ONEREL, re-open ONEINT, calculate the
+*     DK integrals in the contracted basis set, transform and
+*     replace the one-electron integrals on ONEINT.
+*
+      If (DKroll.and..Not.Primitive_Pass) then
+      If (BSS) Then
+            Call BSSint
+         Else
+            Call DKRelInt_DP
+         End If
+      End If
+************************************************************************
+************************************************************************
+*20)                                                                   *
+*     Produce information for the NEMO interface.                      *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If (NEMO) Then
+         If (Primitive_Pass) Then
+*
+*           Compute p-matrix and put it temporarily on ONEREL.
+            PLabel=' '
+            rHrmt=One
+            nComp=3
+            nOrdOp = 0
+            Call Allocate_Auxiliary()
+            Do iComp = 1, nComp
+               Call dcopy_(3,Zero,0,CoorO(1+(iComp-1)*3),1)
+               OperI(1+(iComp-1)) = 1
+               OperC(1+(iComp-1)) = iChBas(1)
+            End Do
+*
+            Label='P_matrix'
+            Call OneEl(P_Int,P_Mem,Label,ipList,OperI,nComp,
+     &                 CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &                 dum,1,dum,idum,0,0,
+     &                 dum,1,0)
+            Call Deallocate_Auxiliary()
+         Else
+*
+*-----------Assemble transformation matrix between the contracted and
+*           the primitive basis.
+*
+            Call NEMO_Opt1()
+*
+         End If
+      End If
+************************************************************************
+************************************************************************
+*21)                                                                   *
+*     Fragment AIEMP integrals: projection and 2-electron interaction  *
+*                               integrals contracted with the          *
+*                               fragment's density matrices            *
+*                                                                      *
+************************************************************************
+************************************************************************
+      If(lFAIEMP.and..not.Primitive_Pass) Then
+* projection integrals
+        PLabel=' '
+        rHrmt=One
+        nComp=1
+        nOrdOp = 0
+        Call Allocate_Auxiliary()
+        Call dcopy_(3,Zero,0,CoorO,1)
+        OperI(1) = 1
+        OperC(1) = iChBas(1)
+        Label='FragProj'
+        Call OneEl(FragPInt,FragPMem,Label,ipList,OperI,nComp,
+     &             CoorO,nOrdOp,Zero,rHrmt,OperC,
+     &             dum,1,dum,idum,0,0,
+     &             dum,1,0)
+        Call Deallocate_Auxiliary()
+* add the results to the one-electron hamiltonian
+        iOpt = 0
+        iRC = -1
+        Call mma_allocate(FragP,n2Tri(1)+4,label='FragP')
+        Call RdOne(iRC,iOpt,Label,1,FragP,lOper)
+        If (iRC.ne.0) Then
+           Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+           Call Quit(_RC_IO_ERROR_READ_)
+        End If
+        Label = 'OneHam  '
+        iRC = -1
+        Call mma_allocate(OneHam,n2Tri(1)+4,label='OneHam')
+        Call RdOne(iRC,iOpt,Label,1,OneHam,lOper)
+        If (iRC.ne.0) Then
+           Call WarningMessage(2,
+     &                  'Drv1El: Error reading ONEINT;'
+     &                //'Label='//Label)
+           Call Quit(_RC_IO_ERROR_READ_)
+        End If
+        Call DaXpY_(n2Tri(1)+4,One,FragP,1,OneHam,1)
+        iRC = -1
+        Call WrOne(iRC,iOpt,Label,1,OneHam,lOper)
+        If (iRC.ne.0) Then
+           Call WarningMessage(2,
+     &                  'Drv1El: Error writing ONEINT;'
+     &                //'Label='//Label)
+           Call Quit(_RC_IO_ERROR_WRITE_)
+        End If
+        iRC = -1
+        Label = 'OneHam 0'
+        Call WrOne(iRC,iOpt,Label,1,OneHam,lOper)
+        If (iRC.ne.0) Then
+           Call WarningMessage(2,
+     &                  'Drv1El: Error writing ONEINT;'
+     &                //'Label='//Label)
+           Call Quit(_RC_IO_ERROR_WRITE_)
+        End If
+        Call mma_deallocate(FragP)
+        Call mma_deallocate(OneHam)
+* 2-electron interaction integrals (are added to the one-electron
+* hamiltonian locally)
+        Call Drv2El_FAIEMP()
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Free_iSD()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Call qExit('Drv1El')
+      Return
+*
+      Contains
+      Subroutine Allocate_Auxiliary()
+      Implicit None
+*
+      Call mma_Allocate(ipList,nComp,label='ipList')
+      Call mma_Allocate(OperI,nComp,label='OperI')
+      Call mma_Allocate(OperC,nComp,label='OperC')
+      Call mma_Allocate(CoorO,3*nComp,label='CoorO')
+      Call mma_Allocate(Nuc,nComp,label='Nuc')
+*
+      Return
+      End Subroutine Allocate_Auxiliary
+      Subroutine Deallocate_Auxiliary()
+      Implicit None
+*
+      Call mma_Deallocate(OperC)
+      Call mma_Deallocate(OperI)
+      Call mma_Deallocate(ipList)
+      Call mma_Deallocate(CoorO)
+      Call mma_Deallocate(Nuc)
+*
+      Return
+      End Subroutine Deallocate_Auxiliary
+*
+      End Subroutine Drv1el
diff --git a/src/seward_util/drv2el.f b/src/seward_util/drv2el.f
new file mode 100644
index 0000000..003aa35
--- /dev/null
+++ b/src/seward_util/drv2el.f
@@ -0,0 +1,250 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1990,1991,1993,1998, Roland Lindh                      *
+*               1990, IBM                                              *
+************************************************************************
+      SubRoutine Drv2El(Integral_WrOut,ThrAO)
+************************************************************************
+*                                                                      *
+*  Object: driver for two-electron integrals.                          *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              Timing                                                  *
+*              Setup_Ints                                              *
+*              Eval_Ints                                               *
+*              Term_Ints                                               *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, IBM Almaden Research Center, San Jose, CA  *
+*             March '90                                                *
+*                                                                      *
+*             Modified for k2 loop. August '91                         *
+*             Modified to minimize overhead for calculations with      *
+*             small basis sets and large molecules. Sept. '93          *
+*             Modified driver. Jan. '98                                *
+************************************************************************
+      use iSD_data
+      Implicit Real*8 (A-H,O-Z)
+      External Integral_WrOut, Rsv_GTList
+#include "itmax.fh"
+#include "info.fh"
+#include "lundio.fh"
+#include "print.fh"
+#include "real.fh"
+#include "stdalloc.fh"
+      Parameter(nTInt=1,mDens=1)
+      Real*8 Dens(mDens), Fock(mDens), TInt(nTInt)
+      Integer iTOffs(8,8,8),
+     &        nShi(8), nShj(8), nShk(8), nShl(8)
+      Logical Verbose, Indexation, FreeK2,
+     &        W2Disc, PreSch, DoIntegrals, DoFock, DoGrad,
+     &        FckNoClmb, FckNoExch, Rsv_GTList, Triangular
+      Character*72 SLine
+      Real*8, Dimension(:,:), Allocatable :: TMax
+      Integer, Dimension(:,:), Allocatable :: Pair_Index
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout = 9
+      iPrint = nPrint(iRout)
+      Call QEnter('Drv2El')
+      SLine='Computing 2-electron integrals'
+      Call StatusLine(' Seward:',SLine)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      nInd=1
+      ExFac=One
+      Nr_Dens=1
+      DoIntegrals=.True.
+      DoFock=.False.
+      DoGrad=.False.
+      FckNoClmb=.False.
+      FckNoExch=.False.
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Set_Basis_Mode('Valence')
+      Call Setup_iSD()
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Initialize for 2-electron integral evaluation. Do not generate
+*     tables for indexation.
+*
+      Indexation = .False.
+      Call Setup_Ints(nSkal,Indexation,ThrAO,DoFock,DoGrad)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Thize=Zero               ! Not used for conventional integrals
+      PreSch=.True.            ! Not used for conventional integrals
+      Disc_Mx=Zero             ! Not used for conventional integrals
+*
+      Disc=Zero
+      Dix_Mx=Zero
+      TskHi=Zero
+      TskLw=Zero
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---  Compute entities for prescreening at shell level
+*
+      Call mma_allocate(TMax,nSkal,nSkal)
+      Call Shell_MxSchwz(nSkal,TMax)
+      TMax_all=Zero
+      Do iS = 1, nSkal
+         Do jS = 1, iS
+            TMax_all=Max(TMax_all,TMax(iS,jS))
+         End Do
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Create list of non-vanishing pairs
+*
+      Call mma_allocate(Pair_Index,2,nSkal*(nSkal+1)/2)
+      nij=0
+      Do iS = 1, nSkal
+         Do jS = 1, iS
+            If (TMax_All*TMax(iS,jS).ge.CutInt) Then
+               nij = nij + 1
+               Pair_Index(1,nij)=iS
+               Pair_Index(2,nij)=jS
+            End If
+         End Do
+      End Do
+      P_Eff=DBLE(nij)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Triangular=.True.
+      Call Alloc_TList(Triangular,P_Eff)
+      Call Init_TList(Triangular,P_Eff)
+      Call Init_PPList
+      Call Init_GTList
+      iOpt=0
+*
+      PP_Eff=P_Eff**2
+      PP_Eff_delta=0.10D0*PP_Eff
+      PP_Count=Zero
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call CWTime(TCpu1,TWall1)
+*
+*     big loop over individual tasks distributed over individual nodes
+*
+ 10   Continue
+*     make reservations of a tesk in global task list and get task range
+*     in return. Function will be false if no more tasks to execute.
+      If (.Not.Rsv_GTlist(TskLw,TskHi,iOpt,W2Disc)) Go To 11
+      W2Disc=.False.
+*
+*     Now do a quadruple loop over shells
+*
+      ijS = Int((One+sqrt(Eight*TskLw-Three))/Two)
+      iS = Pair_Index(1,ijS)
+      jS = Pair_Index(2,ijS)
+      klS = Int(TskLw-DBLE(ijS)*(DBLE(ijS)-One)/Two)
+      kS = Pair_Index(1,klS)
+      lS = Pair_Index(2,klS)
+      Count=TskLw
+*
+      If (Count-TskHi.gt.1.0D-10) Go To 12
+ 13   Continue
+*
+*     Logic to avoid computing integrals in a mixed muonic and
+*     electronic basis.
+*
+      iCnttp=iSD(13,iS)
+      jCnttp=iSD(13,jS)
+      If (fmass(iCnttp).ne.fmass(jCnttp)) Go To 14
+      kCnttp=iSD(13,kS)
+      lCnttp=iSD(13,lS)
+      If (fmass(kCnttp).ne.fmass(lCnttp)) Go To 14
+*
+      S_Eff=DBLE(ijS)
+      T_Eff=DBLE(klS)
+      ST_Eff=S_Eff*(S_Eff-One)/2D0 + T_Eff
+      If (ST_Eff.ge.PP_Count) Then
+         Write (SLine,'(A,F5.2,A)') 'Computing 2-electron integrals,',
+     &        ST_Eff/PP_Eff*100d0,'% done so far.'
+         Call StatusLine(' Seward:',SLine)
+         PP_Count = PP_Count + PP_Eff_delta
+      End If
+*
+*
+         Aint=TMax(iS,jS)*TMax(kS,lS)
+         If (AInt.lt.CutInt) Go To 14
+         Call Eval_Ints_New_
+     &                  (iS,jS,kS,lS,TInt,nTInt,
+     &                   iTOffs,nShi,nShj,nShk,nShl,
+     &                   nShOffi,nShOffj,nShOffk,nShOffl,
+     &                   Integral_WrOut,
+* the following are dummy arguments
+     &                   Dens,Fock,mDens,ExFac,Nr_Dens,
+     &                   Ind,nInd,FckNoClmb,FckNoExch,
+     &                   Thize,W2Disc,PreSch,Dix_Mx,Disc,
+     &                   Count,DoIntegrals,DoFock)
+ 14      Continue
+         Count=Count+One
+         If (Count-TskHi.gt.1.0D-10) Go To 12
+         klS = klS + 1
+         If (klS.gt.ijS) Then
+            ijS = ijS + 1
+            klS = 1
+         End If
+         iS = Pair_Index(1,ijS)
+         jS = Pair_Index(2,ijS)
+         kS = Pair_Index(1,klS)
+         lS = Pair_Index(2,klS)
+         Go To 13
+*
+*     Task endpoint
+ 12   Continue
+*
+*     Use a time slot to save the number of tasks and shell
+*     quadrupltes process by an individual node
+      Call SavStat(1,One,'+')
+      Call SavStat(2,TskHi-TskLw+One,'+')
+      Go To 10
+ 11   Continue
+*     End of big task loop
+      Call CWTime(TCpu2,TWall2)
+      Call SavTim(1,TCpu2-TCpu1,TWall2-TWall1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*                         E P I L O G U E                              *
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Free_GTList
+      Call Free_PPList
+      Call Free_TList
+*
+      Call mma_deallocate(Pair_Index)
+      Call mma_deallocate(TMax)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Terminate integral environment.
+*
+      Verbose = .False.
+      FreeK2=.True.
+      Call Term_Ints(Verbose,FreeK2)
+      Call Free_iSD()
+      Call QExit('Drv2El')
+      Return
+      End
diff --git a/src/seward_util/drv_fck.f b/src/seward_util/drv_fck.f
new file mode 100644
index 0000000..83cd27a
--- /dev/null
+++ b/src/seward_util/drv_fck.f
@@ -0,0 +1,509 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1990,1991,1993,1999, Roland Lindh                      *
+*               1990, IBM                                              *
+************************************************************************
+      SubRoutine Drv_Fck(Label,ip,lOper,nComp,CCoor,
+     &                   nOrdOp,rNuc,rHrmt,iChO,
+     &                   opmol,ipad,opnuc,iopadr,idirect,isyop,
+     &                   PtChrg,nGrid,iAddPot,DInf,nDInf)
+      Implicit Real*8 (A-H,O-Z)
+#include "itmax.fh"
+#include "info.fh"
+#include "stdalloc.fh"
+#include "print.fh"
+#include "real.fh"
+#include "warnings.fh"
+      Real*8 DInf(nDInf)
+      Character Label*8
+      Real*8 CCoor(3,nComp), rNuc(nComp), PtChrg(nGrid)
+      Integer ip(nComp), lOper(nComp), iChO(nComp), iStabO(0:7)
+      Real*8, Dimension(:), Allocatable :: Int1El
+      Integer iTwoj(0:7)
+      Data iTwoj/1,2,4,8,16,32,64,128/
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout = 112
+      iPrint = nPrint(iRout)
+      Call qEnter('Drv_Fck')
+      If (iPrint.ge.19) Then
+         Write (6,*) ' In OneEl: Label', Label
+         Write (6,*) ' In OneEl: nComp'
+         Write (6,'(1X,8I5)') nComp
+         Write (6,*) ' In OneEl: lOper'
+         Write (6,'(1X,8I5)') lOper
+         Write (6,*) ' In OneEl: n2Tri'
+         Do iComp = 1, nComp
+            ip(iComp) = n2Tri(lOper(iComp))
+         End Do
+         Write (6,'(1X,8I5)') (ip(iComp),iComp=1,nComp)
+         Call RecPrt(' CCoor',' ',CCoor,3,nComp)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Compute the number of blocks from each component of the operator
+*     and the irreps it will span.
+*
+      nIC = 0
+      llOper = 0
+      Do iComp = 1, nComp
+         llOper = iOr(llOper,lOper(iComp))
+         Do iIrrep = 0, nIrrep-1
+            If (iAnd(lOper(iComp),iTwoj(iIrrep)).ne.0) nIC = nIC + 1
+         End Do
+      End Do
+      If (iPrint.ge.20) Write (6,*) ' nIC =',nIC
+      If (nIC.eq.0) Go To 999
+      Call SOS(iStabO,nStabO,llOper)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Allocate memory for symmetry adapted one electron integrals.
+*     Will just store the unique elements, i.e. low triangular blocks
+*     and lower triangular elements in the diagonal blocks.
+*
+      Call ICopy(nComp,-1,0,ip,1)
+      LenTot=0
+      Do iComp = 1, nComp
+         LenInt=n2Tri(lOper(iComp))
+         LenTot=LenTot+LenInt+4
+      End Do
+      Call mma_allocate(Int1El,LenTot)
+      ip(1)=1
+      Call DCopy_(LenTot,Zero,0,Int1El(ip(1)),1)
+      iadr=ip(1)
+      do iComp = 1, nComp
+         LenInt=n2Tri(lOper(iComp))
+         ip(icomp)=iadr
+         iadr=iadr+LenInt+4
+*        Copy center of operator to work area.
+         Call DCopy_(3,Ccoor(1,iComp),1,Int1El(ip(iComp)+LenInt),1)
+*        Copy nuclear contribution to work area.
+         Int1El(ip(iComp)+LenInt+3) = rNuc(iComp)
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Compute all SO integrals for all components of the operator.
+*
+      Call Drv_Fck_(Label,ip,Int1El,LenTot,lOper,nComp,CCoor,
+     &              nOrdOp,rHrmt,iChO,
+     &              opmol,opnuc,ipad,iopadr,idirect,isyop,
+     &              iStabO,nStabO,nIC,
+     &              PtChrg,nGrid,iAddPot,DInf,nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*                    P O S T P R O C E S S I N G                       *
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (iPrint.ge.10)    Call PrMtrx(Label,lOper,nComp,ip,Int1El)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Write integrals to disc.
+*
+      mpp_state=1
+      Do iComp = 1, nComp
+         iSmLbl = lOper(iComp)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*------- Write integrals to disc
+*
+         iOpt = 0
+         iRC = -1
+         If (Label(1:3).eq.'PAM')
+     &      Write(Label,'(A5,I3.3)') 'PAM  ',iPAMcount
+c        Write(6,*) ' oneel *',Label,'*'
+
+
+         Call WrOne(iRC,iOpt,Label,iComp,Int1El(ip(iComp)),iSmLbl)
+
+         If (Label(1:3).eq.'PAM')
+     &      Call WrOne(iRC,iOpt,Label,1,Int1El(ip(iComp)),iSmLbl)
+         iPAMcount=iPAMcount+1
+
+         If (iRC.ne.0) then
+            Call qTrace
+            Write(6,*) ' *** Error in subroutine ONEEL ***'
+            Write(6,*) '     Abend in subroutine WrOne'
+            Call Quit(_RC_IO_ERROR_WRITE_)
+         End If
+      End Do  ! iComp
+*                                                                      *
+************************************************************************
+*                                                                      *
+*---- Deallocate memory for integral
+*
+      Call mma_deallocate(Int1El)
+*                                                                      *
+************************************************************************
+*                                                                      *
+ 999  Continue
+      Call qExit('Drv_Fck')
+      Return
+      End
+      Subroutine Drv_Fck_(Label,ip,Int1El,LenTot,lOper,nComp,CCoor,
+     &                    nOrdOp,rHrmt,iChO,
+     &                    opmol,opnuc,ipad,iopadr,idirect,isyop,
+     &                    iStabO,nStabO,nIC,
+     &                    PtChrg,nGrid,iAddPot,DInf,nDInf)
+************************************************************************
+*                                                                      *
+* Object: to compute the one-electron integrals. The method employed at*
+*         this point is not necessarily the fastest. However, the total*
+*         time for the computation of integrals will depend on the time*
+*         spent in computing the two-electron integrals.               *
+*         The memory at this point is assumed to be large enough to do *
+*         the computation in core.                                     *
+*         The data is structured with respect to four indices, two (my *
+*         ny or i j) refer to primitives or basis functions and two (a *
+*         b) refer to the components of the cartesian or spherical     *
+*         harmonic gaussians.                                          *
+*                                                                      *
+* Called from: Drv1El                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              RecPrt                                                  *
+*              ICopy                                                   *
+*              DCopy    (ESSL)                                         *
+*              KrnlMm                                                  *
+*              ZXia                                                    *
+*              MemSO1                                                  *
+*              DCR                                                     *
+*              Inter                                                   *
+*              SetUp1                                                  *
+*              Kernel                                                  *
+*              DGeTMO   (ESSL)                                         *
+*              CarSph                                                  *
+*              SymAd1                                                  *
+*              DScal    (ESSL)                                         *
+*              SOSctt                                                  *
+*              PrMtrx                                                  *
+*              XProp                                                   *
+*              WrOne                                                   *
+*              ErrOne                                                  *
+*              Prop                                                    *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, IBM Almaden Research Center, San Jose, CA  *
+*             January '90                                              *
+*             Modified for Hermite-Gauss quadrature November '90       *
+*             Modified for Rys quadrature November '90                 *
+*             Modified for multipole moments November '90              *
+*                                                                      *
+*             Modified for general kernel routines January  91         *
+*             Modified for nonsymmetrical operators February  91       *
+*             Modified for better symmetry treatement October  93      *
+*             Modified loop structure April 99                         *
+************************************************************************
+      use Real_Spherical
+      use iSD_data
+      Implicit Real*8 (A-H,O-Z)
+#include "itmax.fh"
+#include "info.fh"
+#include "real.fh"
+#include "rmat_option.fh"
+#include "stdalloc.fh"
+#include "angtp.fh"
+#include "lundio.fh"
+#include "print.fh"
+#include "nsd.fh"
+#include "setup.fh"
+      Real*8 DInf(nDInf)
+      Real*8 A(3), B(3), RB(3), CCoor(3,nComp), PtChrg(nGrid)
+      Character ChOper(0:7)*3, Label*8
+      Integer nOp(2), ip(nComp), lOper(nComp), iChO(nComp),
+     &        iDCRR(0:7), iDCRT(0:7), iStabM(0:7), iStabO(0:7)
+      Integer iTwoj(0:7)
+      Real*8, Dimension(:), Allocatable :: Zeta, ZI, SO, Fnl
+      Real*8 Int1El(LenTot)
+      Data iTwoj/1,2,4,8,16,32,64,128/
+      Data ChOper/'E  ','x  ','y  ','xy ','z  ','xz ','yz ','xyz'/
+*
+*     Statement functions
+      nElem(ixyz) = (ixyz+1)*(ixyz+2)/2
+*
+      iRout = 112
+      iPrint = nPrint(iRout)
+*     iPrint = 99
+      Call qEnter('Drv_Fck_')
+*
+*-----Auxiliary memory allocation.
+*
+      Call mma_allocate(Zeta,m2Max)
+      Call mma_allocate(ZI,m2Max)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Nr_Shells(nSkal)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Double loop over shells. These loops decide the integral type
+*
+      Do iS = 1, nSkal
+         iShll  = iSD( 0,iS)
+         iAng   = iSD( 1,iS)
+         iCmp   = iSD( 2,iS)
+         iBas   = iSD( 3,iS)
+         iCff   = iSD( 4,iS)
+         iPrim  = iSD( 5,iS)
+         iExp   = iSD( 6,iS)
+         iAO    = iSD( 7,iS)
+         ixyz   = iSD( 8,iS)
+         mdci   = iSD(10,iS)
+         iShell = iSD(11,iS)
+         iCnttp = iSD(13,iS)
+         call dcopy_(3,DInf(ixyz),1,A,1)
+         Do jS = iS, iS
+            jShll  = iSD( 0,jS)
+            jAng   = iSD( 1,jS)
+            jCmp   = iSD( 2,jS)
+            jBas   = iSD( 3,jS)
+            jCff   = iSD( 4,jS)
+            jPrim  = iSD( 5,jS)
+            jExp   = iSD( 6,jS)
+            jAO    = iSD( 7,jS)
+            jxyz   = iSD( 8,jS)
+            mdcj   = iSD(10,jS)
+            jShell = iSD(11,jS)
+            jCnttp = iSD(13,jS)
+*
+            call dcopy_(3,DInf(jxyz),1,B,1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Allocate memory for SO integrals that will be generated by
+*           this batch of AO integrals.
+*
+            nSO=0
+            Do iComp = 1, nComp
+               iSmLbl=lOper(iComp)
+               nSO=nSO+MemSO1(iSmLbl,iCmp,jCmp,iShell,jShell)
+            End Do
+            If (iPrint.ge.29) Write (6,*) ' nSO=',nSO
+            If (nSO.eq.0) Go To 131
+            Call mma_allocate(SO,nSO*iBas*jBas)
+            Call DCopy_(nSO*iBas*jBas,Zero,0,SO,1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+            If (iPrint.ge.19) Write (6,'(A,A,A,A,A)')
+     &        ' ***** (',AngTp(iAng),',',AngTp(jAng),') *****'
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Allocate memory for the final integrals all in the
+*           primitive basis.
+            lFinal = nIC * MaxPrm(iAng) * MaxPrm(jAng) *
+     &               nElem(iAng)*nElem(jAng)
+            Call mma_allocate(Fnl,lFinal)
+            Call dCopy_(lFinal,Zero,0,Fnl,1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           At this point we can compute Zeta.
+*           This is now computed in the ij or ji order.
+*
+            Call ZXia(Zeta,ZI,iPrim,jPrim,DInf(iExp),DInf(jExp))
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Find the DCR for A and B
+*
+            Call DCR(LmbdR,iOper,nIrrep,jStab(0,mdci),
+     &               nStab(mdci),jStab(0,mdcj),
+     &               nStab(mdcj),iDCRR,nDCRR)
+*
+*           Find the stabilizer for A and B
+*
+            Call Inter(jStab(0,mdci),nStab(mdci),
+     &                 jStab(0,mdcj),nStab(mdcj),
+     &                 iStabM,nStabM)
+*
+            Call DCR(LambdT,iOper,nIrrep,iStabM,nStabM,iStabO,nStabO,
+     &               iDCRT,nDCRT)
+*
+            If (iPrint.ge.19) Then
+               Write (6,*)
+               Write (6,*) ' g      =',nIrrep
+               Write (6,*) ' u      =',nStab(mdci)
+               Write (6,'(9A)') '(U)=',(ChOper(jStab(ii,mdci)),
+     &               ii = 0, nStab(mdci)-1)
+               Write (6,*) ' v      =',nStab(mdcj)
+               Write (6,'(9A)') '(V)=',(ChOper(jStab(ii,mdcj)),
+     &               ii = 0, nStab(mdcj)-1)
+               Write (6,*) ' LambdaR=',LmbdR
+               Write (6,*) ' r      =',nDCRR
+               Write (6,'(9A)') '(R)=',(ChOper(iDCRR(ii)),
+     &               ii = 0, nDCRR-1)
+               Write (6,*) ' m      =',nStabM
+               Write (6,'(9A)') '(M)=',(ChOper(iStabM(ii)),
+     &               ii = 0, nStabM-1)
+            End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Compute normalization factor
+*
+            iuv = nStab(mdci)*nStab(mdcj)
+            If (MolWgh.eq.1) Then
+               Fact = DBLE(nStabO) / DBLE(LambdT)
+            Else If (MolWgh.eq.0) Then
+               Fact = DBLE(iuv*nStabO) / DBLE(nIrrep**2 * LambdT)
+            Else
+               Fact = Sqrt(DBLE(iuv))*DBLE(nStabO)/
+     &                DBLE(nirrep*LambdT)
+            End If
+            Fact = One / Fact
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Loops over symmetry operations acting on the basis.
+*
+            nOp(1) = NrOpr(0,iOper,nIrrep)
+*           Do lDCRR = 0, nDCRR-1
+            Do lDCRR = 0, 0
+             RB(1) = DBLE(iPhase(1,iDCRR(lDCRR)))*B(1)
+             RB(2) = DBLE(iPhase(2,iDCRR(lDCRR)))*B(2)
+             RB(3) = DBLE(iPhase(3,iDCRR(lDCRR)))*B(3)
+             nOp(2) = NrOpr(iDCRR(lDCRR),iOper,nIrrep)
+             If (iPrint.ge.49) Write (6,'(A,3F6.2,2X,3F6.2)') '*',
+     &             (A(i),i=1,3),(RB(i),i=1,3)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*            Pick up epsilon from memory
+*
+            Call FZero(Fnl,iBas*jBas*iCmp*jCmp*nIC)
+            ip_Eorb=ipFockOp(iShll)
+            Do iB = 1, iBas
+               Do jB = 1, iBas
+                  ijB=(jB-1)*iBas+iB
+                  Do iC = 1, iCmp
+                     ijC=(iC-1)*iCmp+iC
+                     iFrom=ip_Eorb-1 + (jB-1)*iBas+iB
+                     iTo= + (ijC-1)*iBas**2+ijB
+#ifdef _DEBUG_
+                     Write (6,*) 'ijB,ijC=',ijB,ijC
+                     Write (6,*) 'Fnl(iTo),DInf(iFrom)=',
+     &                            Fnl(iTo),DInf(iFrom)
+#endif
+                     Fnl(iTo)=DInf(iFrom)
+                  End Do
+               End Do
+            End Do
+#ifdef _DEBUG_
+            Call RecPrt('EOrb',' ',DInf(ip_EOrb),iBas,1)
+            Call RecPrt('EOrb',' ',DInf(ip_EOrb),iBas,iBas)
+            Call RecPrt('FckInt',' ',Fnl,iBas*jBas,iCmp*jCmp*nIC)
+#endif
+*                                                                      *
+************************************************************************
+*                                                                      *
+*            At this point accumulate the batch of integrals onto the
+*            final symmetry adapted integrals.
+*
+             If (iPrint.ge.99) Then
+                Call RecPrt (' Accumulated SO integrals, so far...',
+     &                               ' ',SO,iBas*jBas,nSO)
+             End If
+*
+*------------Symmetry adapt component by component
+*
+             iSOBlk = 1
+             iIC = 1
+             Do iComp = 1, nComp
+              iSmLbl=lOper(iComp)
+              mSO=MemSO1(iSmLbl,iCmp,jCmp,iShell,jShell)
+              If (mSO.eq.0) Then
+                 Do iIrrep = 0, nIrrep-1
+                    If (iAnd(lOper(iComp),iTwoj(iIrrep)).ne.0)
+     &                  iIC = iIC + 1
+                 End Do
+              Else
+                 Call SymAd1(iSmLbl,iAng,jAng,iCmp,jCmp,
+     &                       iShell,jShell,iShll,jShll,Fnl,
+     &                       iBas,jBas,nIC,iIC,SO(iSOBlk),mSO,nOp)
+                 iSOBlk = iSOBlk + mSO*iBas*jBas
+              End If
+             End Do
+*
+            End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Multiply with factors due to projection operators
+*
+            If (Fact.ne.One) Call DScal_(nSO*iBas*jBas,Fact,SO,1)
+            If (iPrint.ge.99) Then
+               Write (6,*) ' Scaling SO''s', Fact
+               Call RecPrt(' Accumulated SO integrals',' ',
+     &                     SO,iBas*jBas,nSO)
+            End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*           Scatter the SO's on to the non-zero blocks of the
+*           lower triangle.
+*
+            iSOBlk = 1
+            Do iComp = 1, nComp
+              iSmLbl=lOper(iComp)
+              If (n2Tri(iSmLbl).ne.0) Then
+                 mSO=MemSO1(iSmLbl,iCmp,jCmp,iShell,jShell)
+              Else
+                 mSO=0
+              End If
+              If (mSO.ne.0) Then
+                 Call SOSctt(SO(iSOBlk),iBas,jBas,mSO,Int1El(ip(iComp)),
+     &                       n2Tri(iSmLbl),iSmLbl,iCmp,jCmp,iShell,
+     &                       jShell,iAO,jAO,nComp,Label,lOper,rHrmt)
+                 iSOBlk = iSOBlk + mSO*iBas*jBas
+              End If
+            End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+            Call mma_deallocate(Fnl)
+            Call mma_deallocate(SO)
+*                                                                      *
+************************************************************************
+*                                                                      *
+ 131        Continue
+         End Do
+      End Do
+*
+      Call mma_deallocate(ZI)
+      Call mma_deallocate(Zeta)
+*
+      Call qExit('Drv_Fck_')
+      Return
+c Avoid unused argument warnings
+      If (.False.) Then
+         Call Unused_real_array(CCoor)
+         Call Unused_integer(nOrdOp)
+         Call Unused_integer_array(iChO)
+         Call Unused_real(opmol)
+         Call Unused_real(opnuc)
+         Call Unused_integer(ipad)
+         Call Unused_integer(iopadr)
+         Call Unused_integer(idirect)
+         Call Unused_integer(isyop)
+         Call Unused_real_array(PtChrg)
+         Call Unused_integer(iAddPot)
+      End If
+      End
diff --git a/src/seward_util/frctl.f b/src/seward_util/frctl.f
new file mode 100644
index 0000000..df05785
--- /dev/null
+++ b/src/seward_util/frctl.f
@@ -0,0 +1,21 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+      Function Frctl(n)
+      Implicit real*8 (a-h,o-z)
+#include "real.fh"
+      Real*8 Frctl
+*
+      Frctl=One
+      Do 10 i = 1, n
+         Frctl = Frctl * DBLE(i)
+ 10   Continue
+      Return
+      End
diff --git a/src/seward_util/gvmode.f b/src/seward_util/gvmode.f
new file mode 100644
index 0000000..602db20
--- /dev/null
+++ b/src/seward_util/gvmode.f
@@ -0,0 +1,74 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+      Subroutine GvMode(isGvMode)
+c
+c Make a decision about GV mode, based on MOLCAS_GV variable
+c
+c if MOLCAS_GV can be set to Yes/GuessOrb or SCF
+c
+c  Return:
+c  -1 or 0 : normal run
+c   1 - use GuessOrb
+c   2 - use SCF
+c
+      character Value*256
+      isGvMode=-1
+      Value=' '
+      Call getenvf('MOLCAS_GV',Value)
+      if(Value.eq.' ') then
+         isGvMode=0
+         return
+      endif
+      if(Value(1:1).eq.'y'.or.Value(1:1).eq.'Y'.or.
+     &   Value(1:1).eq.'g'.or.Value(1:1).eq.'G') then
+      isGvMode=1
+      else
+        if(Value(1:1).eq.'s'.or.Value(1:1).eq.'S') then
+          isGvMode=2
+        else
+          Write(6,*) 'Unknown value of MOLCAS_GV'
+          isGvMode=-1
+        endif
+      endif
+      return
+      end
+c
+      Subroutine DoGvMode(isGvMode)
+      character*16 StdIn
+      if(isGvMode.eq.1) then
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Write (6,*)
+      Write (6,*) ' Seward requests the grid_it to be computed!'
+      Write (6,*)
+*
+      LuInput=11
+      LuInput=IsFreeUnit(LuInput)
+      Call StdIn_Name(StdIn)
+      Call Molcas_Open(LuInput,StdIn)
+      Write (LuInput,'(A)') ' &Grid_It &End'
+c
+c vv: temporary fix - use ASCII instead of PACK
+c      Write (LuInput,'(A)') 'Pack'
+
+      Write (LuInput,'(A)') 'ASCII'
+c VV
+      Write (LuInput,'(A)') 'Spar'
+      Write (LuInput,'(A)') 'End of Input'
+      Write (LuInput,'(A)') '>> exit 0'
+      Close(LuInput)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      endif
+      return
+      end
diff --git a/src/seward_util/input_seward.f b/src/seward_util/input_seward.f
new file mode 100644
index 0000000..18385da
--- /dev/null
+++ b/src/seward_util/input_seward.f
@@ -0,0 +1,138 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 1990,1991,1993, Roland Lindh                           *
+*               1990, IBM                                              *
+************************************************************************
+      SubRoutine Input_Seward(lOPTO,Info,DInf,nDInf)
+************************************************************************
+*                                                                      *
+*     Object: to read the input to the integral package.               *
+*                                                                      *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              RdCtl                                                   *
+*              ChTab                                                   *
+*              GeoNew                                                  *
+*              DCopy    (ESSL)                                         *
+*              SOCtl                                                   *
+*              Sphere                                                  *
+*              Nrmlz                                                   *
+*              Dstncs                                                  *
+*              Angles                                                  *
+*              Dihedr                                                  *
+*              CoW                                                     *
+*              RigRot                                                  *
+*              RdMx                                                    *
+*              DrvN0                                                   *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, IBM Almaden Research Center, San Jose, CA  *
+*             January '90                                              *
+*                                                                      *
+*             January '91 additional input for property calculations.  *
+*             October '93 split up to RdCtl and SoCtl.                 *
+************************************************************************
+      Implicit Real*8 (A-H,O-Z)
+#include "itmax.fh"
+#include "info.fh"
+#include "real.fh"
+#include "SysDef.fh"
+#include "lundio.fh"
+#include "print.fh"
+      Parameter (nMamn=MaxBfn+MaxBfn_Aux)
+      Character Mamn(nMamn)*(LENIN4)
+      Logical Show_Save, lOPTO
+      Logical Reduce_Prt
+      External Reduce_Prt
+      Save Show_Save
+      Real*8 DInf(nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout=2
+      Call qEnter('Input ')
+*                                                                      *
+************************************************************************
+*                                                                      *
+      LuWr=6
+*
+      If (Primitive_Pass) Then
+         Show_Save=Show
+      Else ! .Not.Primitive
+         Show=Show_Save
+      End If
+*                                                                      *
+************************************************************************
+************************************************************************
+*                                                                      *
+*
+*     Adjust the print level and some other parameters depending on
+*     if we are iterating or not.
+*
+*     Set Show to false if Seward is run in property mode.
+      Show=Show.and..Not.Prprt
+*
+      If ((Reduce_Prt().and.nPrint(iRout).lt.6).and..Not.Prprt) Then
+         Show=.False.
+         Do_GuessOrb=.False.
+      End If
+*
+      Show=Show.and..Not.Primitive_Pass
+      Show = Show .or. Test
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Modify storage of basis functions to be in accordance with a
+*     calculation in the primitive or contracted basis.
+*
+      Call Flip_Flop(Primitive_Pass)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Start of output, collect all output to this routine!
+*
+      Call Gen_RelPointers(-(Info-1))
+      If (Show) Call Output1_Seward(lOPTO,Info,DInf,nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*-----Generate the SO or AO basis set
+*
+      Call SOCtl_Seward(Mamn,nMamn,DInf,nDInf,Info)
+      Call Gen_RelPointers(Info-1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Test) Then
+         Call qExit('Input ')
+         Return
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Write information on the run file.
+*
+      If (Primitive_Pass) Then
+         Call Put_iArray('nBas_Prim',nBas,nIrrep)
+         Call Gen_RelPointers(-(Info-1))
+         Call Info2Runfile(DInf,nDInf)
+         Call Gen_RelPointers(Info-1)
+      End If
+      Call Put_cArray('Unique Basis Names',Mamn,(LENIN4)*nDim)
+      Call Put_iArray('nBas',nBas,nIrrep)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call qExit('Input ')
+      Return
+      End
diff --git a/src/seward_util/nemo_opt1.f b/src/seward_util/nemo_opt1.f
new file mode 100644
index 0000000..1161c02
--- /dev/null
+++ b/src/seward_util/nemo_opt1.f
@@ -0,0 +1,325 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+      Subroutine NEMO_Opt1()
+      Implicit real*8(a-h,o-z)
+#include "itmax.fh"
+#include "info.fh"
+#include "warnings.fh"
+#include "rinfo.fh"
+#include "print.fh"
+#include "real.fh"
+#include "stdalloc.fh"
+      Integer nBas_Prim(0:7), nBas_cont(0:7), lOper(3)
+      Parameter(MxMltPl=10)
+      Integer ipMP((MxMltPl+1)*(MxMltPl+2)*(MxMltPl+3)/6),
+     &        iSm((MxMltPl+1)*(MxMltPl+2)*(MxMltPl+3)/6)
+      Integer ip(3), iSml(3)
+      Character*8 Label
+      Real*8, Dimension(:), Allocatable :: P_Matrix, MP_Matrix
+*
+      iRout=77
+      iPrint=nPrint(iRout)
+      Call QEnter('NEMO_Opt1')
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Save basis set info from contracted run
+*
+      if(iprint.ge.10) write(6,*) ' In NEMO_Opt1', ncnttp
+      kCof=0
+      kAng=0
+      kExp=0
+      kC=0
+*
+*     Normalize coefficients
+*
+      do iCnttp=1,nCnttp
+*
+*-- Make a check that no cartesian d or higher have been used.
+*   The reason for this restriction is found in tr_prm_cnt.
+*   If that routine is generalized, then remove this check.
+*
+        lSh=0
+        kShStr = ipVal(iCnttp)
+        kShEnd = ipVal(iCnttp)+nVal_Shells(iCnttp)-1
+        Do kSh = kShStr, kShEnd
+          If(.not.Transf(kSh).and.lSh.ge.2) then
+            Call WarningMessage(2,'   NEMO Error')
+            Write(6,*)
+            Write(6,*)
+            Write(6,*)'Error! The NEMO keyword does not work with'
+     &//' cartesian d-functions or higher.'
+            Write(6,*)'Request spherical functions to proceed.'
+            Write(6,*)
+            Write(6,*)
+            Call Quit(_RC_INPUT_ERROR_)
+          Endif
+          lSh=lSh+1
+        Enddo
+*
+*-- End check.
+*
+        Do icnt = 1, nCntr(iCnttp)
+        kC=kC+1
+c           Do iAngr=0,nAngr(icnt)
+           Do iAngr=0,nAngr(kC)
+c              rI=iAngr+1.0d0+half
+               rI=DBLE(iAngr)+One+Half
+              kAng=kAng+1
+              Do iBas=1,nBasisr(kAng)
+                 Sum=Zero
+                 kExpi=kExp
+                 kCofi=kCof
+                 Do iExp=1,nPrimr(kAng)
+                    kExpi=kExpi+1
+                    kCofi=kCofi+1
+                    rExpi=rExp(kExpi)
+c                    write(6,'(a11,f20.8)') ' Exponents',rExpi
+                    rCofi=rCof(kCofi)
+                    kExpj=kExp
+                    kCofj=kCof
+                    Do jExp=1,nPrimr(kAng)
+                       kExpj=kExpj+1
+                       kCofj=kCofj+1
+                       rExpj=rExp(kExpj)
+                       rCofj=rCof(kCofj)
+                       Sum=Sum+rCofi*rCofj*
+     &                 (Two*sqrt(rExpi*rExpj)/(rExpi+rExpj))**rI
+                    End Do
+                 End Do
+                 rNorm=One/sqrt(Sum)
+                 if(iprint.ge.10) write(6,*) ' rNorm', kAng,rNorm
+                   Do iExp=1,nPrimr(kAng)
+                      rCof(kCof+iExp)=rCof(kCof+iExp)*rNorm
+                     if(iprint.ge.10) then
+                         write(6,'(a24,f20.6)')
+     &                   ' normalized coefficients',
+     &                   rCof(kCof+iExp)
+                     endif
+                   End Do
+                 kCof=kCof+nPrimr(kAng)
+              End Do
+              kExp=kExp+nPrimr(kAng)
+           End Do
+        End Do
+      End Do
+*
+      If (iPrint.ge.10) Then
+      i=0
+      Do L=1,nrSym
+         write(6,*) ' Irreducible representation', L
+         Do ibas=1,nrBas(L)
+            i=i+1
+            Write (6,'(20i4)') i, icent(i),lnang(i),lmag(i)
+         End Do
+      End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Close ONEINT and re-open ONEREL
+*
+      Call iCopy(8,nBas,1,nBas_Cont,1)
+*
+      nSym=nIrrep
+      iOpt=0
+      Call ClsOne(iRC,iOpt)
+      iOpt = 0
+      iRC = -1
+      Lu_One=2
+      Call OpnOne(iRC,iOpt,'ONEREL',Lu_One)
+      If (iRC.ne.0) Go To 9999
+*
+      Call OneBas('PRIM')
+      Call Get_iArray('nBas_Prim',nBas_Prim,nIrrep)
+*
+      If(iPrint.ge.10) then
+         write(6,'(a,8i5)') ' Symmetries          ', nSym
+         write(6,'(a,8i5)') ' Primitive basis fcns',
+     &                          (nBas_Prim(i),i=0,nSym-1)
+      Endif
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Read P_Matrix from ONEREL
+*
+      nComp=3
+      nLength_Tot=0
+      Do iComp = 1, nComp
+         iOpt=1
+         iRC=-1
+         Call iRdOne(iRC,iOpt,'P_matrix',iComp,Length,iSmLbl)
+         If (iRC.ne.0) Then
+            Call WarningMessage(2,'Error reading length of P-Matrix')
+            Write (6,*) 'iComp=',iComp
+            Call Abend()
+         End If
+         iSml(iComp)=iSmLbl
+         lOper(iComp)=1
+         ip(iComp)=1 + nLength_Tot
+         nLength_Tot = nLength_Tot + Length + 4
+      End Do
+*
+      Call mma_allocate(P_Matrix,nLength_Tot,label='P_Matrix')
+      Call FZero(P_Matrix,nLength_Tot)
+*
+      Do iComp = 1, nComp
+         iOpt=0
+         iRC=-1
+         iSmLbl=iSml(iComp)
+         ip(iComp) = ip(iComp)
+         Call RdOne(iRC,iOpt,'P_matrix',iComp,P_Matrix(ip(iComp)),
+     &              iSmLbl)
+         If (iRC.ne.0) Then
+            Call WarningMessage(2,'Error reading P-Matrix')
+            Write (6,*) 'iComp=',iComp
+            Call Abend()
+         End If
+      End Do
+      If (iPrint.ge.10) Call PrMtrx('P_matrix',lOper,nComp,ip,P_Matrix)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Read multipole integrals from ONEREL
+*
+      nip = 0
+      nInt_Tot = 0
+      Do iMltPl = 0, MxMltPl
+         Write (Label,'(a,i2)') 'MLTPL ',iMltPl
+         nComp = (iMltPl+1)*(iMltPl+2)/2
+         Do iComp = 1, nComp
+            iRC = -1
+            iOpt = 1
+            nInt=0
+            Call iRdOne(iRC,iOpt,Label,iComp,nInt,iSmLbl)
+            If (iRC.ne.0) Then
+               If (iComp.ne.1) Then
+                  Call WarningMessage(2,' Error reading length!')
+                  Write (6,*) ' Label=', Label,' Comp=',iComp
+                  Call Abend()
+               Else
+                  Go To 100
+               End If
+            End If
+            nip = nip + 1
+            iSm(nip)=iSmLbl
+            ipMP(nip)= 1 + nInt_Tot
+            nInt_Tot = nInt_Tot + nInt+4
+         End Do
+      End Do
+ 100  Continue
+*
+      Call mma_allocate(MP_Matrix,nInt_Tot,label='MP_Matrix')
+*
+      iip=0
+      Do iMltPl = 0, MxMltPl
+         Write (Label,'(a,i2)') 'MLTPL ',iMltPl
+         nComp = (iMltPl+1)*(iMltPl+2)/2
+         Do iComp = 1, nComp
+            iip = iip + 1
+            if (iip.gt.nip) Go To 200
+            iRC=-1
+            iOpt=0
+            ipMP(iip) = ipMP(iip)
+            iSmLbl=iSm(iip)
+            Call RdOne(iRC,iOpt,Label,iComp,MP_Matrix(ipMP(iip)),iSmLbl)
+            If (iRC.ne.0) Then
+               Call WarningMessage(2,' Error reading integrals!')
+               Write (6,*) ' Label=', Label,' Comp=',iComp
+               Call Abend()
+            End If
+         End Do
+      End Do
+ 200  Continue
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Close ONEREL and re-open ONEINT
+*
+      iOpt = 0
+      iRC = -1
+      Call ClsOne(iRC,iOpt)
+      If (iRC.ne.0) Go To 9999
+      iOpt = 0
+      iRC = -1
+      Lu_One=2
+      Call OpnOne(iRC,iOpt,'ONEINT',Lu_One)
+      If (iRC.ne.0) Go To 9999
+*
+      Call OneBas('PRIM')
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Put the transformation matrix on RUNFILE
+*
+      idbg=0
+      Call tr_prm_cnt(idbg,nBas_Cont,nBas_Prim)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Process the P-matrix
+*
+      nComp=3
+      iOpt=0
+      Do iComp = 1, nComp
+         iRC=-1
+         Call WrOne(iRC,iOpt,'P_matrix',iComp,P_Matrix(ip(iComp)),
+     &              iSml(iComp))
+         If (iRC.ne.0) Then
+            Call WarningMessage(2,'Error reading P-Matrix')
+            Write (6,*) 'iComp=',iComp
+            Call Abend()
+         End If
+      End Do
+      Call mma_deallocate(P_Matrix)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Process multipole integrals
+*
+      iip = 0
+      Do iMltPl = 0, MxMltPl
+         Write (Label,'(a,i2)') 'PLTPL ',iMltpl
+         nComp = (iMltpl+1)*(iMltpl+2)/2
+         Do iComp = 1, nComp
+            iip = iip + 1
+            If (iip.gt.nip) Go To 300
+            iRC = -1
+            iOpt = 0
+            Call WrOne(iRC,iOpt,Label,iComp,MP_Matrix(ipMP(iip)),
+     &                 iSm(iip))
+            If (iRC.ne.0) Then
+               Call WarningMessage(2,' Error writing integrals!')
+               Write (6,*) ' Label=', Label,' Comp=',iComp
+               Call Abend()
+            End If
+         End Do
+      End Do
+ 300  Continue
+      Call mma_deallocate(MP_Matrix)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     And now change it back!
+*
+      Call OneBas('CONT')
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call QExit('NEMO_Opt1')
+      Return
+*
+ 9999 Continue
+      Call WarningMessage(2,
+     &            ' *** Error in subroutine NEMO_Opt1 ***;'
+     &          //'     Abend in subroutine OpnOne or ClsOne')
+      Call Abend()
+      End
diff --git a/src/seward_util/output1_seward.f b/src/seward_util/output1_seward.f
new file mode 100644
index 0000000..4db9536
--- /dev/null
+++ b/src/seward_util/output1_seward.f
@@ -0,0 +1,545 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+*                                                                      *
+* Copyright (C) 2006, Roland Lindh                                     *
+************************************************************************
+      SubRoutine Output1_Seward(lOPTO,Info,DInf,nDInf)
+************************************************************************
+*                                                                      *
+*     Object: to write the output of seward            .               *
+*                                                                      *
+*                                                                      *
+* Called from: Seward                                                  *
+*                                                                      *
+* Calling    : QEnter                                                  *
+*              QExit                                                   *
+*                                                                      *
+*     Author: Roland Lindh, Dept Chem. Phys., Lund University, Sweden  *
+*             September '06                                            *
+************************************************************************
+      use Period
+      use GeoList
+      use EFP_Module
+      Implicit Real*8 (A-H,O-Z)
+#include "itmax.fh"
+#include "info.fh"
+#include "rinfo.fh"
+#include "real.fh"
+#include "rmat.fh"
+#include "rctfld.fh"
+#include "relmp.fh"
+#include "relae.fh"
+#include "print.fh"
+#include "gateway.fh"
+#include "localdf.fh"
+      Logical l_aCD_Thr, lOPTO
+      Real*8 DInf(nDInf)
+#include "angstr.fh"
+*                                                                      *
+************************************************************************
+*                                                                      *
+      iRout=2
+      iPrint=nPrint(iRout)
+      Call QEnter('Output1_Seward')
+      LuWr=6
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Start of output
+*
+      If (Test) Then
+         Write (LuWr,*)
+         Write (LuWr,'(15X,88A)') ('*',i=1,45)
+         Write (LuWr,'(15X,A)')
+     &   '* TEST: SEWARD will only process the input! *'
+         Write (LuWr,'(15X,88A)') ('*',i=1,45)
+         Go To 99
+      End If
+*
+      iDKH_X_Order = iRELAE/10000
+      iParam = iRELAE-1000 - iDKH_X_Order*10000
+      iDKH_H_Order = iParam/10
+      iParam = iParam - iDKH_H_Order*10
+*
+      Write (LuWr,'(15X,A)') 'SEWARD will generate:'
+      Write (LuWr,'(15X,A,I2)')
+     &        '   Multipole Moment integrals up to order ',nMltpl
+      If (.Not.Prprt) Then
+         Write (LuWr,'(15X,A)')    '   Kinetic Energy integrals'
+         If (Nuclear_Model.eq.Gaussian_Type) Then
+            Write (LuWr,'(15X,A)')  '   Nuclear Attraction integrals'
+     &                              //' (finite nuclei - Gaussian type)'
+         Else If (Nuclear_Model.eq.Point_Charge) Then
+            Write (LuWr,'(15X,A)')  '   Nuclear Attraction integrals'
+     &                              //' (point charge)'
+         Else
+            Write (LuWr,'(15X,A)')  '   Nuclear Attraction integrals'
+     &                    //' (finite nuclei -  Modified Gaussian type)'
+         End If
+         If (lECP) Then
+            If (lNoPair) Then
+               If (IRELMP.EQ.0) Then
+                  Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &               //' modified with ECP and No-Pair contributions'
+                Else If (IRELMP.EQ.1) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &         //' modified with ECP and No-Pair (DK1) contributions'
+                Else If (IRELMP.EQ.2) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &         //' modified with ECP and No-Pair (DK2) contributions'
+                Else If (IRELMP.EQ.3) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &         //' modified with ECP and No-Pair (DK3) contributions'
+                Else If (IRELMP.EQ.11) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &               //' modified with ECP and RESC contributions'
+                Else If (IRELMP.EQ.21) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &               //' modified with ECP and ZORA contributions'
+                Else If (IRELMP.EQ.22) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &               //' modified with ECP and ZORA-FP contributions'
+                Else If (IRELMP.EQ.23) Then
+                   Write (LuWr,'(15X,A)')
+     &                 '   One-Electron Hamiltonian integrals'
+     &               //' modified with ECP and IORA contributions'
+                End If
+            Else
+               Write (LuWr,'(15X,A)')
+     &                '   One-Electron Hamiltonian integrals'
+     &              //' modified with ECP contributions'
+            End If
+         Else
+            Write (LuWr,'(15X,A)')
+     &             '   One-Electron Hamiltonian integrals'
+         End If
+         If(FNMC) Then
+            Write (LuWr,'(15X,A)')
+     &             '   Finite nuclear mass correction added'
+         End If
+         If (lPAM2) Then
+               Write (LuWr,'(15X,A)')
+     &                '   Include potentials for DMFT calculation'
+         End If
+         If (lRel) Then
+            Write (LuWr,'(15X,A)')    '   Mass-Velocity integrals'
+            Write (LuWr,'(15X,A)')
+     &             '   Darwin One-Electron Contact Term integrals'
+         End If
+         If (Vlct) Write (LuWr,'(15X,A)') '   Velocity integrals'
+         If (DKroll) Then
+            If (iRELAE.lt.1000) Then
+               If (iRELAE.EQ.0) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic Douglas-Kroll integrals'
+               Else If (IRELAE.EQ.1) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic Douglas-Kroll (DK1) integrals'
+               Else If (IRELAE.EQ.2) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic Douglas-Kroll (DK2) integrals'
+               Else If (IRELAE.EQ.3) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic Douglas-Kroll (DK3) integrals'
+               Else If (IRELAE.EQ.4) Then
+                  Write (LuWr,'(15X,A)')
+     &          '   full Relativistic Douglas-Kroll (DK3) integrals'
+               Else If (IRELAE.EQ.11) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic RESC integrals'
+               Else If (IRELAE.EQ.21) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic ZORA integrals'
+               Else If (IRELAE.EQ.22) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic ZORA-FP integrals'
+               Else If (IRELAE.EQ.23) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic IORA integrals'
+               Else If (IRELAE.EQ.101) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic X2C integrals'
+               Else If (IRELAE.EQ.102) Then
+                  Write (LuWr,'(15X,A)')
+     &               '   Relativistic BSS integrals'
+               Else If (BSS) Then
+                  Write  (LuWr,'(15X,A)')
+     &                '   Relativistic Barysz-Sadlej-Snijders integrals'
+               End If
+            Else
+               If (LDKroll) Then
+                  Write (LuWr,'(17X,A)')
+     &               ' Relativistic Local-Douglas-Kroll-Hess integrals:'
+                  If (nCtrLD.eq.0) Then
+                     If (radiLD.eq.0.0d0) Then
+                        Write(LuWr,'(17X,A)')
+     &                  '   - Atomic approximation'
+                     Else
+                        Write(LuWr,'(17X,A)')
+     &                  '   - Full local approximation'
+                     End If
+                  Else
+                     Write(LuWr,'(17X,A)')
+     &               '   - Partial local approximation:'
+                     Write(LuWr,'(17X,A,10(A4))')
+     &          '     - Centers: ', (LblCnt(iCtrLD(i)),i=1,nCtrLD)
+                     Write(LuWr,'(17X,A,F6.2,A)')
+     &          '     - Cutoff radius: ', radiLD, ' Bohr'
+                 End If
+               Else
+                  Write (LuWr,'(17X,A)')
+     &               ' Relativistic Douglas-Kroll-Hess integrals:'
+               Endif
+               If (iParam.eq.1) Then
+                  Write (LuWr,'(17X,A)')
+     &                  '   - Parametrization         : OPT'
+               Else If (iParam.eq.2) Then
+                  Write (LuWr,'(17X,A)')
+     &                  '   - Parametrization         : EXP'
+               Else If (iParam.eq.3) Then
+                  Write (LuWr,'(17X,A)')
+     &                  '   - Parametrization         : SQR'
+               Else If (iParam.eq.4) Then
+                  Write (LuWr,'(17X,A)')
+     &                  '   - Parametrization         : MCW'
+               Else If (iParam.eq.5) Then
+                  Write (LuWr,'(17X,A)')
+     &                  '   - Parametrization         : CAY'
+               End If
+               Write (LuWr,'(17X,A,I2)')
+     &               '   - DKH order of Hamiltonian:',iDKH_H_order
+               Write (LuWr,'(17X,A,I2)')
+     &               '   - DKH order of Properties :',iDKH_X_order
+               Write (LuWr,'(17X,A)')
+     &               '        - multipole moment operators'
+               Write (LuWr,'(17X,A)')
+     &               '        - electric potential operators'
+               Write (LuWr,'(17X,A)')
+     &               '        - contact operators'
+            End If
+         End If
+         If (lRF) Then
+            If (PCM) Then
+               Write (LuWr,'(15X,A)')
+     &               '   Reaction Field integrals (PCM)'
+            Else If (lLangevin) Then
+               Write (LuWr,'(15X,A)')
+     &               '   Reaction Field integrals (Langevin)'
+            Else
+               Write (LuWr,'(15X,A)')
+     &               '   Reaction Field integrals (KirkWood-Onsager)'
+            End If
+         End If
+         If (lPP)Write (LuWr,'(15X,A)')
+     &                '   Pseudo Potential integrals'
+      End If
+      If (lXF) Write (LuWr,'(15X,A,I6,A)')
+     &                       '   External field from',
+     &                           nXF, ' point(s) added to the'
+     &                           //' one-electron Hamiltonian'
+      If (nEF.gt.0 .and. nOrdEF.ge.0) Write (LuWr,'(15X,A,I6,A)')
+     &                       '   Electric potential for',
+     &                           nEF, ' points'
+      If (nEF.gt.0 .and. nOrdEF.ge.1) Write (LuWr,'(15X,A,I6,A)')
+     &                       '   Electric field integrals for',
+     &                           nEF, ' points'
+      If (nEF.gt.0 .and. nOrdEF.ge.2) Write (LuWr,'(15X,A,I6,A)')
+     &            '   Electric field gradient integrals for',
+     &                           nEF, ' points'
+      If (nEF.gt.0 .and. nOrdEF.ge.2) Write (LuWr,'(15X,A,I6,A)')
+     &            '   Contact term integrals for',
+     &                           nEF, ' points'
+      If (lDMS) Write (LuWr,'(15X,A,I6,A)')
+     &            '   Diamagnetic shielding integrals for',
+     &                           nDMS, ' points'
+      If (lOAM) Write (LuWr,'(15X,A,3(F7.4,1X),A)')
+     &                       '   Orbital angular momentum around (',
+     &   (DInf(ipOAM+i),i=0,2),')'
+      If (lOMQ) Write (LuWr,'(15X,A,3(F7.4,1X),A)')
+     &                       '   Orbital magnetic quadrupole around (',
+     &   (DInf(ipOMQ+i),i=0,2),')'
+      If (lAMP) Write (LuWr,'(15X,A,3(F7.4,1X),A)')
+     & '   Products of Orbital angular momentum operators around (',
+     &   (DInf(ipAMP+i),i=0,2),')'
+      If (nWel.ne.0) Write (LuWr,'(15X,A,I4,A)')
+     &             '   Spherical well for', nWel,
+     &             ' exponent(s) added to the'
+     &           //' one-electron Hamiltonian'
+      If (lAMFI) Write (LuWr,'(15X,A)') '   Atomic mean-field integrals'
+      If (lPSOI) Write (LuWr,'(15X,A)')
+     & '   (PSO) Paramagnetic Spin-Orbit integrals'
+     &     //' calculated from Gen1Int F90 library'
+      If (DoFMM) Then
+         Write (LuWr,'(15X,A)')
+     &     '   Integral environment set up for FMM option'
+         Write (LuWr,'(15X,A,F10.5)')
+     &     '    - RPQMin: ',RPQMin
+      End If
+      If (EFP) Then
+#ifdef _EFP_
+         Write (LuWr,'(15X,A)')
+     &     '   Effective Fragment potentials added       '
+         Write (LuWr,'(15X,A,I4)')
+     &     '    - # of fragments: ',nEFP_fragments
+#else
+         Write (LuWr,'(15X,A)')
+     &     '   EFP input specified but code not enabled for the option'
+         Call Abend()
+#endif
+      End If
+      If (.Not.Onenly) Then
+         If (Cholesky) Then
+            Write (LuWr,'(15X,A)')
+     &        '   Cholesky decomposed two-electron'
+     &           //' repulsion integrals'
+           If (Cho_OneCenter) Then
+            Write (LuWr,'(17X,A,G10.2)')
+     &                 '  - 1C-CD Threshold: ',Thrshld_CD
+           Else
+            Write (LuWr,'(17X,A,G10.2)')
+     &                 '  - CD Threshold: ',Thrshld_CD
+           EndIf
+         Else If (Do_RI) Then
+            If (LocalDF) Then
+               If (LDF_Constraint.eq.-1) Then
+                  Write(LuWr,'(15X,A)')
+     &                  '   Local Density Fitting coefficients'
+               Else
+                  Write(LuWr,'(15X,A)')
+     &               '   Constrained Local Density Fitting coefficients'
+                  If (LDF_Constraint.eq.0) Then
+                     Write (LuWr,'(17X,A)')
+     &                 '  - constraint type: charge'
+                  Else
+                     Call WarningMessage(2,'Unknown constraint!')
+                     Write(6,'(A,I10)') 'LDF_Constraint=',LDF_Constraint
+                     Call LDF_Quit(-1)
+                  End If
+               End If
+               If (LDF2) Then
+                  Write (LuWr,'(17X,A,G10.2)')
+     &                 '  - two-center auxiliary functions included'
+     &                 //' (when needed); target accuracy: ',
+     &                 Thr_Accuracy
+               Else
+                  Write (LuWr,'(17X,A)')
+     &                 '  - two-center auxiliary functions not included'
+               End If
+            Else If (LDF) Then
+               Write (LuWr,'(15X,A)')
+     &               '   LDF decomposed two-electron'
+     &               //' repulsion integrals stored Cholesky style'
+               Write (LuWr,'(15X,A)') '    Concept demonstration only!'
+            Else
+               Write (LuWr,'(15X,A)')
+     &               '   RI decomposed two-electron'
+     &               //' repulsion integrals stored Cholesky style'
+            End If
+            If (iRI_Type.eq.1) Then
+               Write (LuWr,'(17X,A)')
+     &                 '  - RIJ auxiliary basis'
+            Else If (iRI_Type.eq.2) Then
+               Write (LuWr,'(17X,A)')
+     &                 '  - RIJK auxiliary basis'
+            Else If (iRI_Type.eq.3) Then
+               Write (LuWr,'(17X,A)')
+     &                 '  - RIC auxiliary basis'
+            Else If (iRI_Type.eq.5) Then
+               Write (LuWr,'(17X,A)')
+     &                 '  - External RICD auxiliary basis'
+            Else
+               If (Do_nacCD_Basis) Then
+                  Write (LuWr,'(17X,A)')
+     &                    '  - nacCD auxiliary basis'
+               Else
+                  If (Do_acCD_Basis) Then
+                     Write (LuWr,'(17X,A)')
+     &                    '  - acCD auxiliary basis'
+                  Else
+                     Write (LuWr,'(17X,A)')
+     &                       '  - aCD auxiliary basis'
+                  End If
+               End If
+               Write (LuWr,'(17X,A,G10.2)')
+     &                 '  - CD Threshold: ',Thrshld_CD
+               l_aCD_Thr=.False.
+               Do iCnttp = 1, nCnttp
+                  l_aCD_Thr=l_aCD_Thr .or. aCD_Thr(iCnttp).ne.One
+               End Do
+               If (l_aCD_Thr) Then
+                  Write (LuWr,'(17X,A)')
+     &                    '     Note that the threshold for individual'
+     &                  //' basis sets might be modified!'
+               End If
+               If (Skip_High_AC) Then
+                  Write (LuWr,'(17X,A)')
+     &                    '  - Skip high angular momentum combinations'
+               End If
+            End If
+         Else
+            Write (LuWr,'(15X,A)')
+     &        '   Two-Electron Repulsion integrals'
+         End If
+      End If
+      If (RMat_On) Then
+         Write (LuWr,*)
+         Write (LuWr,'(15X,A,A)')
+     &        '   OBSERVE that some integrals are modified to',
+     &        ' enable variational R-matrix calculations!'
+      End If
+      If (GIAO) Then
+         Write (LuWr,'(15X,A)')
+     &        '   GIAO integrals differentiated with respect to B'
+         Write (LuWr,'(15X,A)')
+     &        '     dS/dB                                        '
+         Write (LuWr,'(15X,A)')
+     &        '     dT/dB                                        '
+         Write (LuWr,'(15X,A)')
+     &        '     dV/dB                                        '
+      End If
+*
+*     Transition moment integrals for oscillator strengths of
+*     electronic transitions.
+*
+      If (EMFR) Then
+         Write (LuWr,'(15X,A)')
+     &        '   Transition moment intergrals'
+         Write (LuWr,'(15X,A,3(F7.4,1X),A)')
+     &                       '   The wavevector k: (',
+     &   (kVector(i),i=1,3),')'
+         temp=Sqrt(KVector(1)**2+KVector(2)**2+kVector(3)**2)
+         temp = (Two*Pi)/temp
+         Write (LuWr,'(15X,A,(F10.4,1X),A)')
+     &                       '   Wavelength:        ',
+     &   Temp,'a.u.'
+         Write (LuWr,'(15X,A,(F10.4,1X),A)')
+     &                       '                      ',
+     &   Temp*Angstr,'Angstrom'
+         Write (LuWr,'(15X,A,(F10.4,1X),A)')
+     &                       '                      ',
+     &   Temp*Angstr/Ten,'nm'
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+ 99   Continue
+*
+      If (nTtl.ne.0) Then
+         If (iPrint.ge.6) Then
+            Write (LuWr,*)
+            Write (LuWr,'(15X,88A)') ('*',i=1,88)
+            Write (LuWr,'(15X,88A)') '*', (' ',i=1,86), '*'
+            Do iTtl = 1, nTtl
+               Write (LuWr,'(15X,A,A,A)') '*   ',Title(iTtl),'   *'
+            End Do
+            Write (LuWr,'(15X,88A)') '*', (' ',i=1,86), '*'
+            Write (LuWr,'(15X,88A)') ('*',i=1,88)
+         Else
+            Write (LuWr,*)
+            Write (LuWr,'(A)') ' Title:'
+            Do iTtl = 1, nTtl
+               Write (LuWr,'(8X,A)') Title(iTtl)
+            End Do
+            Write (LuWr,*)
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Write (LuWr,*)
+      Write (LuWr,'(19X,A,E8.2)')
+     &      'Integrals are discarded if absolute value <: ',ThrInt
+      Write (LuWr,'(19X,A,E8.2)')
+     &      'Integral cutoff threshold is set to       <: ',CutInt
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (Run_Mode.eq.GS_Mode) Call Print_Symmetry()
+*                                                                      *
+************************************************************************
+*                                                                      *
+      If (nIrrep.gt.1) Then
+         If (MolWgh.eq.0) Then
+            Write (LuWr,*)
+            Write (LuWr,'(19X,A,A)') ' Symmetry adaptation a la',
+     &                          ' DCR.'
+            Write (LuWr,*)
+         End If
+         If (MolWgh.eq.1) Then
+            Write (LuWr,*)
+            Write (LuWr,'(19X,A,A)') ' Symmetry adaptation a la',
+     &                          ' MOLECULE.'
+            Write (LuWr,*)
+         End If
+         If (MolWgh.eq.2) Then
+            Write (LuWr,*)
+            Write (LuWr,'(19X,A)') ' Unitary symmetry adaptation'
+            Write (LuWr,*)
+         End If
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Print Cell unit information
+*
+      If (Cell_l) Then
+          Write(LuWr,'(6X,30(''-''))')
+          Write(LuWr,'(6X,A)') '* - the centers of the Unit Cell'
+          Write(LuWr,'(A)') ' '
+          Write(LuWr,'(A,3I3)') 'Spread of the unit cell:',
+     &      (ispread(i),i=1,3)
+          Write(LuWr,'(A)') ' '
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Write out basis set information
+*
+      If (Run_Mode.eq.GS_Mode) Then
+         Call Print_Basis(lOPTO,DInf,nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Write out coordinates, bond, angles and torsional angles
+*
+         If (lOPTO) then
+            Call Print_Geometry(1,DInf,nDInf)
+         else
+            Call Print_Geometry(0,DInf,nDInf)
+         EndIf
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Rigid Rotor analysis etc.
+*
+         Call RigRot(Centr,Mass,kCentr)
+*                                                                      *
+************************************************************************
+*                                                                      *
+         Call Print_Basis2(DInf,nDInf)
+*                                                                      *
+************************************************************************
+*                                                                      *
+         Call Print_OpInfo(DInf,nDInf)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call QExit('Output1_Seward')
+      Return
+      If (.False.) Call Unused_Integer(Info)
+      End
diff --git a/src/seward_util/tr_prm_cnt.f b/src/seward_util/tr_prm_cnt.f
new file mode 100644
index 0000000..26b38ad
--- /dev/null
+++ b/src/seward_util/tr_prm_cnt.f
@@ -0,0 +1,191 @@
+************************************************************************
+* This file is part of OpenMolcas.                                     *
+*                                                                      *
+* OpenMolcas is free software; you can redistribute it and/or modify   *
+* it under the terms of the GNU Lesser General Public License, v. 2.1. *
+* OpenMolcas is distributed in the hope that it will be useful, but it *
+* is provided "as is" and without any express or implied warranties.   *
+* For more details see the full text of the license in the file        *
+* LICENSE or in <http://www.gnu.org/licenses/>.                        *
+************************************************************************
+      subroutine Tr_prm_cnt(idbg,nBas_Cont,nBas_Prim)
+      implicit real*8(a-h,o-z)
+#include "itmax.fh"
+#include "info.fh"
+#include "rinfo.fh"
+#include "stdalloc.fh"
+#include "real.fh"
+      Integer icaddr(MxAO),numc(MxAO),ihelp(MxAtom,MxAng),numb(MxAO),
+     &        mcaddr(MxAO), nBas_Cont(8), nBas_Prim(0:7)
+      Logical New_Center,New_l,New_m, Old_Center, Old_l
+      Real*8, Dimension(:), Allocatable :: Tr
+*     contracted basis, atomic basis functions
+*
+*     symmetry info
+*
+*     lant(i): number of atoms in i:th symmetry bf
+*     expand the coefficient matrix into symmetry basis set
+*     auxiliary
+*     icaddr(i): adresses in coeff for a symmetry adapted function
+*
+*                                                                      *
+* THIS ROUTINE ONLY WORKS WITH SPHERICAL FUNCTIONS. NO CARTESIAN D:S!  *
+************************************************************************
+*                                                                      *
+      nSym=nIrrep
+      iPrint=0
+      If (iprint.ge.10.or.idbg.gt.0) then
+         write(idbg,*) ' in repmat', nsym
+         write(idbg,*) nSym, (nBas(i),i=0,nsym-1)
+         write(idbg,*) nSym, (nrBas(i),i=1,nsym)
+         write(idbg,*) nSym, (nBas_Prim(i),i=0,nsym-1)
+         write(idbg,*) nSym, (nBas_Cont(i),i=1,nsym)
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     set up pointer
+*
+      k=0
+      ia=0  ! center index
+      ka=0  ! shell index
+      Do iCnttp=1,nCnttp
+         Do icnt = 1, nCntr(iCnttp)
+            ia=ia+1
+            Do la=1,nAngr(ia)+1
+               ka=ka+1
+               ihelp(ia,la)=k
+               k=k+nPrimr(ka)*nBasisr(ka)
+            End Do
+         End Do
+      End Do
+      If (iPrint.ge.10.or.idbg.gt.0) Then
+         write(idbg,*) ' Help vector'
+         ia=0
+         Do iCnttp=1,nCnttp
+            Do icnt = 1, nCntr(iCnttp)
+               ia=ia+1
+               write(idbg,'(10i5)') (ihelp(ia,j),j=1,nAngr(ia)+1)
+           End Do
+         End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Loop over irreps
+*
+      k=0
+      Do iSym = 1, nSym
+         numck=1
+         numcl=0
+         kbias=0
+*
+*        Loop over basis functions in irrep
+*
+         Do iCont = 1, nBas_Cont(iSym)
+            k=k+1
+            If (iCont.gt.1) Then
+               New_Center=icent(k).ne.icent(k-1)
+               New_l=lnang(k).ne.lnang(k-1)
+               New_m=lmag(k).ne.lmag(k-1)
+               If (New_m)  kbias=kbias-numc(k-1)
+               If (New_Center.or.New_l)  kbias=0
+            Else
+               New_Center=.True.
+               New_l=.True.
+            End If
+            kbias = kbias + 1
+            ka=0
+            ia=0
+            Do iCnttp = 1, nCnttp
+               Do iCnt = 1, nCntr(iCnttp)
+                  ia=ia+1
+                  Do la = 1, nAngr(ia)+1
+                     ka=ka+1
+                     Old_Center=icent(k).eq.ia
+                     Old_l=lnang(k).eq.(la-1)
+                     If (idbg.gt.0) write(idbg,*) ' at numck', k,ia,
+     &                   icent(k),la-1,lnang(k),ia,New_Center,New_l
+                     If (Old_Center.and.Old_l) Then
+                        numc(k)=nBasisr(ka)
+                        numb(k)=nPrimr(ka)
+                        icaddr(k)=ihelp(ia,la)+(kbias-1)*nPrimr(ka)
+                        If (k.gt.1.and.kbias.eq.1) numck=numcl+numck
+                        mcaddr(k)=numck
+                        numcl=nPrimr(ka)
+                     End If
+                  End Do  ! la
+               End Do     ! iCnt
+            End Do        ! iCnttp
+         End Do           ! iCont
+      End Do              ! iSym
+      k=0
+      If (iPrint.ge.10.or.idbg.gt.0) then
+         ic=0
+         ip=0
+         Do iSym = 1, nSym
+            Write (idbg,*)        ' symmetry',iSym
+            Write (idbg,*)        ' numb'
+            Write (idbg,'(20i4)') (numb(i+ic),  i=1,nBas_Cont(iSym))
+            Write (idbg,*)        ' numc'
+            Write (idbg,'(20i4)') (numc(i+ic),  i=1,nBas_Cont(iSym))
+            Write (idbg,*)        ' Pointer to contraction vector'
+            Write (idbg,'(20i4)') (icaddr(i+ic),i=1,nBas_Cont(iSym))
+            Write (idbg,*)        ' mcaddr'
+            Write (idbg,'(20i4)') (mcaddr(i+ic),i=1,nBas_Cont(iSym))
+            ic=ic+nBas_Cont(iSym)
+            ip=ip+nBas_Prim(iSym-1)
+         End Do
+      End If
+*                                                                      *
+************************************************************************
+*                                                                      *
+      nSize=0
+      Do iSym = 1, nSym
+         nSize=nSize+nBas_Cont(iSym)*nBas_Prim(iSym-1)
+      End Do
+      Call mma_allocate(Tr,nSize,label='Tr')
+      Call DCopy_(nSize,Zero,0,Tr,1)
+*                                                                      *
+************************************************************************
+*                                                                      *
+*     Generate the transformation matrix.
+*
+      ibasL=0
+      iOff = 0
+*
+*---- Loop over irreps
+*
+      Do iSym = 1, nSym
+*
+*        loop over contracted
+*
+         Do iBas = 1, nBas_Cont(iSym)
+            ibasL=ibasL+1
+            ipbasL=mcaddr(ibasL) -1
+*
+*           loop over uncontracted
+*
+            Do iPrim=1,numb(ibasL)
+               ipbasL = ipbasL+1
+               index=iOff + (iBas-1)*nBas_Prim(iSym-1) + ipbasL
+c              Write (*,*) iBas,ipbasL
+               Tr(index)=rCof(icaddr(ibasL)+iPrim)
+*
+            End Do     ! iprim
+         End Do
+         iOff = iOff + nBas_Cont(iSym)*nBas_Prim(iSym-1)
+      End Do
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call Put_dArray('NEMO TPC',Tr,nSize)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Call mma_deallocate(Tr)
+*                                                                      *
+************************************************************************
+*                                                                      *
+      Return
+      End
