************************************************************************
* This file is part of OpenMolcas.                                     *
*                                                                      *
* OpenMolcas is free software; you can redistribute it and/or modify   *
* it under the terms of the GNU Lesser General Public License, v. 2.1. *
* OpenMolcas is distributed in the hope that it will be useful, but it *
* is provided "as is" and without any express or implied warranties.   *
* For more details see the full text of the license in the file        *
* LICENSE or in <http://www.gnu.org/licenses/>.                        *
************************************************************************
#ifdef _NECI_
      SUBROUTINE neci2molcas_dens(DMAT,DSPN,PSMAT,PAMAT,
     &                            NACPAR,nactel)
*     <Arguments>
*       \Argument{MAT}{Average 1-dens matrix}{Real*8 array (NACPAR)}...............{out}
*       \Argument{SPN}{Average spin 1-dens matrix}{Real*8 array (NACPAR)}..........{out}
*       \Argument{PSMAT}{Average symm. 2-dens matrix}{Real*8 array (NACPR2)}........{out}
*       \Argument{PAMAT}{Average antisymm. 2-dens matrix}{Real*8 array (NACPR2)}....{out}
*     </Arguments>
*
*     <Description>
*
*       Read OneRDM and TwoRDM files written by NECI and transfer them to Molcas.
*
*       TwoRDM convention:
*          TwoRDM_aaaa = TwoRDM1
*          TwoRDM_abab = TwoRDM2
*          TwoRDM_abba = TwoRDM3
*     </Description>
      Implicit Real*8 (A-H,O-Z)
#include "para_info.fh"
#include "output_ras.fh"
c#include "mpif.h"
      integer iUnit, isfreeunit, p,q,r,s, pq,rs, ps,rq, psrq,pqrs, iread
      integer iSpin, Nalpha, nactel, nacpar
      logical tExist
      Real*8    fac, RDMval, fcSp, facval
      Real*8 DMAT(*),DSPN(*),PSMAT(*),PAMAT(*)
*      Real*8 DTST(*)


      Call qEnter('neci2molcas')

      IPRLEV=IPRLOC(1)
      IF(IPRLEV.ge.DEBUG) THEN
        Write(6,*)
        Write(6,*) ' ===================='
        WRITE(6,*) ' Entering neci2molcas'
        Write(6,*) ' ===================='
        Write(6,*)
        write(6,*) 'Rank of process: ', MyRank
      END IF
******** Initialize DSPN to zero
      call dcopy_(NACPAR,0.0d0,0,DSPN,1)
      Call get_iscalar('iSpin',iSpin)
      Nalpha = (nactel+ISPIN-1)/2
      fcSp = 1.0d0
      If(ISPIN.ne.1) fcSp = 2.0d0
***************************
* Broadcasting TwoRDM generated by QMC code in master node into all processors.
***************************
      if(myRank.ne.0) then
        call bcast_2RDM("TWORDM1")
        call bcast_2RDM("TWORDM2")
        call bcast_2RDM("TWORDM3")
        call bcast_2RDM("ONERDM")
      end if
*******************************************************************************************
******************************** existency check ******************************************
*******************************************************************************************
        call f_Inquire('TWORDM1',tExist)
        if(.not.tExist) goto 123
        call f_Inquire('TWORDM2',tExist)
        if(.not.tExist) goto 123
        call f_Inquire('TWORDM3',tExist)
        if(.not.tExist) goto 123
        call f_Inquire('ONERDM',tExist)
        if(.not.tExist) goto 123
*******************************************************************************************
*************************** Processing TwoRDM-AAAA ****************************************
*******************************************************************************************
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM1')
        Rewind(iUnit)

      IF(IPRLEV.ge.DEBUG) THEN
       write(6,*) '    p     q     r     s    pq    rs   pqrs        ',
     & 'RDMval                PSMAT                   PAMAT'

       write(6,*) ' ********************** AAAA ****************** '
      end if

        do
******************* processing as PQRS ***********************
**************************************************************
          fac = 1.0d0
          read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
          if(iread.ne.0) exit

          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r
******* Contribution to PSMAT and PAMAT:
          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq

          PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(p.gt.q.and.r.gt.s) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          if(p.gt.q.and.r.lt.s) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &         p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
          END IF
******* Contribution to DSPN (not final):
          if(p.eq.q) DSPN(rs)=DSPN(rs)+RDMval
          if(r.eq.s) DSPN(pq)=DSPN(pq)+RDMval
******* Contribution to DTST (not final):
*          if(p.eq.q) DTST(rs)=DTST(rs)+RDMval*2.0d0/real(nactel-1)
*          if(r.eq.s) DTST(pq)=DTST(pq)+RDMval*2.0d0/real(Nactel-1)
******************* processing as PSRQ ***********************
**************************************************************
          fac = -1.0d0
          if(p.ge.s) ps = p*(p-1)/2 + s
          if(p.lt.s) ps = s*(s-1)/2 + p
          if(r.ge.q) rq = r*(r-1)/2 + q
          if(r.lt.q) rq = q*(q-1)/2 + r

******* Contribution to PSMAT and PAMAT:
          if(ps.ge.rq) psrq = ps*(ps-1)/2 + rq
          if(ps.lt.rq) psrq = rq*(rq-1)/2 + ps

          if(r.le.q) then
            PSMAT(psrq) = PSMAT(psrq) + fac*RDMval
            if(r.ne.q) PAMAT(psrq) = PAMAT(psrq) - fac*RDMval
          end if

          if(r.gt.q) then
            PSMAT(psrq) = PSMAT(psrq) + fac*RDMval
            PAMAT(psrq) = PAMAT(psrq) + fac*RDMval
          end if
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &        p,s,r,q,ps,rq,psrq, RDMval,PSMAT(psrq),PAMAT(psrq)
          END IF
******* Contribution to DSPN (not final):
* The minus sign comes from the fact that in NECI these elements have opposite sign
* compared to the element in normal order, that is d_pqrs = -d_psrq.
          if(p.eq.s) DSPN(rq)=DSPN(rq)-RDMval
          if(r.eq.q) DSPN(ps)=DSPN(ps)-RDMval
******* Contribution to DTST (not final):
*          if(p.eq.s) DTST(rq)=DTST(rq)-RDMval*2.0d0/real(nactel-1)
*          if(r.eq.q) DTST(ps)=DTST(ps)-RDMval*2.0d0/real(Nactel-1)
        end do
        close(iunit)
*******************************************************************************************
*************************** Processing TwoRDM-ABAB ****************************************
*******************************************************************************************
c       write(6,*) 'FCIQMC TwoRDM_abab: Got it!'
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM2')
        Rewind(iUnit)

      IF(IPRLEV.ge.DEBUG) THEN
       write(6,*) ' ********************** ABAB ****************** '
      END IF
        do
          fac = 1.0d0
          read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
          if(iread.ne.0) exit

          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r

          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq

          PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(r.gt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          if(r.lt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval

      IF(IPRLEV.ge.DEBUG) THEN
          write(6,'(7I6,3G25.17)')
     &        p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
      END IF
******* Contribution to DTST (not final):
*          if(p.eq.q) DTST(rs)=DTST(rs)+RDMval*2.0d0/real(nactel-1)
*          if(r.eq.s.and.p.ne.r) DTST(pq) =
*     &                              DTST(pq)+RDMval*2.0d0/real(Nactel-1)
        end do
        close(iunit)

*******************************************************************************************
*************************** Processing TwoRDM-ABBA ****************************************
*******************************************************************************************
c       write(6,*) 'FCIQMC TwoRDM_abba: Got it!'
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM3')
        Rewind(iUnit)

      IF(IPRLEV.ge.DEBUG) THEN
        write(6,*) ' ********************** ABBA ****************** '
      END IF

        do
          fac = -1.0d0
          read(iUnit,"(4I6,G25.17)",iostat=iread) q,s,r,p,RDMval
          if(iread.ne.0) exit

          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r

          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq

            PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(r.lt.s) then
            PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          end if
          if(r.gt.s) then
            PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          end if

      IF(IPRLEV.ge.DEBUG) THEN
          write(6,'(7I6,3G25.17)')
     &        p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
      END IF
******* Contribution to DTST (not final):
*          if(p.eq.q) DTST(rs)=DTST(rs)-RDMval*2.0d0/real(nactel-1)
*          if(r.eq.s) DTST(pq)=DTST(pq)-RDMval*2.0d0/real(Nactel-1)
        end do
        close(iunit)

*******************************************************************************************
***************************   Processing OneRDM    ****************************************
*******************************************************************************************
c       write(6,*) 'FCIQMC OneRDM: Got it!'
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'ONERDM')
        Rewind(iUnit)

c       write(6,*) 'p,q, pq, DMAT(pq)'
        do
          fac = 1.0d0
          read(iUnit,"(2I6,G25.17)",iostat=iread) p,q, RDMval
          if(iread.ne.0) exit
          if(mod(p,2).ne.0) then
           p = ceiling(real(p)/2.0d0)
           q = ceiling(real(q)/2.0d0)
           pq = q*(q-1)/2 + p
ctest      if(p.ne.q) fac = -1.0d0
           DMAT(pq)= 2.0d0*RDMval*fac
c           write(6,*) p,q, pq, DMAT(pq)
          end if
        end do
        IF(IPRLEV.ge.DEBUG) THEN
         call triprt('DMAT in neci2molcas',' ',DMAT,4)
        END IF
*****************************************************************
*        call triprt('DTST in neci2molcas 1',' ',DTST,3)
c Clean evil non-positive semi-definite matrices....
c DMAT is input and output.
        call cleanMat(DMAT)
        IF(IPRLEV.ge.DEBUG) THEN
          call triprt('DMAT in neci2molcas after rm NPSD',' ',DMAT,4)
        END IF
*******************************************************************************************
***************************   Final Update to DSPN   **************************************
*******************************************************************************************
        facval=fcSp*2.0d0/real(Nalpha-1)
        call ScalVe(DSPN,-facval,NACPAR)
        call daxpy_(NACPAR,1.0d0,DMAT,1,DSPN,1)
        call ScalVe(DSPN,-1.0D0,NACPAR)
        IF(IPRLEV.ge.DEBUG) THEN
         call triprt('DMAT in neci2molcas',' ',DMAT,3)
         call triprt('DSPN in neci2molcas',' ',DSPN,3)
        END IF
        close(iunit)
      Call qExit('neci2molcas')
      Return

123    continue
          write(6,*) 'Error in Reading RDM files needed by Molcas!'
          write(6,*) 'Probably file not generated by NECI?'
          Call QTrace()
          Call Abend()
      End Subroutine
#elif defined (NAGFOR)
c Some compilers do not like empty files
      Subroutine empty_neci2molcas_dens()
      End
#endif
