************************************************************************
* This file is part of OpenMolcas.                                     *
*                                                                      *
* OpenMolcas is free software; you can redistribute it and/or modify   *
* it under the terms of the GNU Lesser General Public License, v. 2.1. *
* OpenMolcas is distributed in the hope that it will be useful, but it *
* is provided "as is" and without any express or implied warranties.   *
* For more details see the full text of the license in the file        *
* LICENSE or in <http://www.gnu.org/licenses/>.                        *
*                                                                      *
* Copyright (C) 2017, Giovanni Li Manni                                *
************************************************************************
#ifdef _NECI_
      SUBROUTINE neci2molcas_dens(DMAT,DSPN,PSMAT,PAMAT,
     &                            NACPAR,NACPR2,nactel)
* <Arguments>
*   \Argument{DMAT}{Average 1-dens matrix}{Real*8 array (NACPAR)}...............{out}
*   \Argument{DSPN}{Average spin 1-dens matrix}{Real*8 array (NACPAR)}..........{out}
*   \Argument{PSMAT}{Average symm. 2-dens matrix}{Real*8 array (NACPR2)}........{out}
*   \Argument{PAMAT}{Average antisymm. 2-dens matrix}{Real*8 array (NACPR2)}....{out}
* </Arguments>
*
* <Description>
*   Read TwoRDM files written by NECI and transfer them to Molcas.
*   TwoRDM convention:
*      TwoRDM_aaaa = TwoRDM1
*      TwoRDM_abab = TwoRDM2
*      TwoRDM_abba = TwoRDM3
*   The following are needed for spin-resolved properties...
*      TwoRDM_bbbb = TwoRDM4
*      TwoRDM_baba = TwoRDM5
*      TwoRDM_baab = TwoRDM6
*   Neci can have some intermediate spin-resolved/spin-free RDMs where basically aaaa contains
*   average of aaaa and bbbb, abab contains average of abab and baba...
*   This is ok for CASSCF but not ok for spin-resolved properties, in which case the completely
*   spin-resolved RDMs need to be read-in.
*   In principle, NECI could also evaluate and store completely spin-free matrices.
*   In that case only a reordering following Molcas convention is necessary.
* </Description>

      Implicit Real*8 (A-H,O-Z)
#include "para_info.fh"
#include "output_ras.fh"
      integer iUnit, isfreeunit, p,q,r,s, pq,rs, ps,rq, psrq,pqrs, iread
      integer iSpin, Nalpha, nactel, nacpar, nacpr2,norb
      logical tExist, switch
      Real*8  fac, RDMval, fcalpha, fcbeta, fcnacte
      Real*8  DMAT(nacpar),DSPN(nacpar),PSMAT(nacpr2),PAMAT(nacpr2)
      Real*8  D_alpha(nacpar),D_beta(nacpar)
      Parameter (routine = 'neci2molcas_dens')

      Call qEnter(routine)

      IPRLEV=IPRLOC(1)
      IF(IPRLEV.ge.DEBUG) THEN
        write(6,*) 'Rank of process: ', MyRank
      END IF
      switch = .true.
*     ^  This variable must become a keyword for discriminating spin-resolved from spin-free input RDMs.
*     ^  For now when .false. it is assumed that 3 files (only   aaaa, abab and abba) are fed.
*     ^  ....... when .true.  it is assumed that 6 files (adding bbbb, baba and baab) are fed.
*********************************************************************************
* Broadcasting TwoRDM generated by QMC code in master node into all processors. *
*********************************************************************************
      if(myRank.ne.0) then
        call bcast_2RDM("TWORDM1")
        call bcast_2RDM("TWORDM2")
        call bcast_2RDM("TWORDM3")
        call bcast_2RDM("TWORDM4")
        call bcast_2RDM("TWORDM5")
        call bcast_2RDM("TWORDM6")
      end if
**********************************************************************************
******************************** existency check *********************************
**********************************************************************************
      call f_Inquire('TWORDM1',tExist)
      if(.not.tExist) goto 123
      call f_Inquire('TWORDM2',tExist)
      if(.not.tExist) goto 123
      call f_Inquire('TWORDM3',tExist)
      if(.not.tExist) goto 123
      if(switch) then
        call f_Inquire('TWORDM4',tExist)
        if(.not.tExist) goto 123
        call f_Inquire('TWORDM5',tExist)
        if(.not.tExist) goto 123
        call f_Inquire('TWORDM6',tExist)
        if(.not.tExist) goto 123
      end if
******** Initialize matrices to zero:
      call dcopy_(NACPAR,0.0d0,0,D_alpha,1)
      call dcopy_(NACPAR,0.0d0,0,D_beta,1)
      call dcopy_(NACPAR,0.0d0,0,DMAT,1)
      call dcopy_(NACPAR,0.0d0,0,DSPN,1)
      call dcopy_(NACPR2,0.0d0,0,PSMAT,1)
      call dcopy_(NACPR2,0.0d0,0,PAMAT,1)

******** Evaluate some constants:
      Call get_iscalar('iSpin',iSpin)
      Nalpha = (nactel+ISPIN-1)/2
      fac = 1.0d0
      if(switch) fac = 0.5d0
      fcalpha=1.0d0/real(nalpha-1)
      fcbeta =1.0d0/real(nactel-nalpha-1)
      fcnacte=1.0d0/real(nactel-1)

*******************************************************************************************
*************************** Processing TwoRDM-AAAA ****************************************
*******************************************************************************************
      iUnit=IsFreeUnit(11)
      Call Molcas_Open(iUnit,'TWORDM1')
      Rewind(iUnit)
      IF(IPRLEV.ge.DEBUG) THEN
        write(6,*) '    p     q     r     s    pq    rs   pqrs        ',
     &  'RDMval                PSMAT                   PAMAT'
        write(6,*) ' ********************** AAAA ****************** '
      end if
      do
******************* processing as PQRS ***********************
**************************************************************
        read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
        if(iread.ne.0) exit
******* indexing:
        if(p.ge.q) pq = p*(p-1)/2 + q
        if(p.lt.q) pq = q*(q-1)/2 + p
        if(r.ge.s) rs = r*(r-1)/2 + s
        if(r.lt.s) rs = s*(s-1)/2 + r
        if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
        if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
        PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
        if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
        if(p.gt.q.and.r.gt.s) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
        if(p.gt.q.and.r.lt.s) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
        IF(IPRLEV.ge.DEBUG) THEN
           write(6,'(7I6,3G25.17)')
     &     p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
        END IF
******* Contribution to D_alpha (not final):
        if(p.eq.q) D_alpha(rs)=D_alpha(rs)+RDMval
        if(r.eq.s) D_alpha(pq)=D_alpha(pq)+RDMval
******************* processing as PSRQ ***********************
**************************************************************
******* indexing:
        if(p.ge.s) ps = p*(p-1)/2 + s
        if(p.lt.s) ps = s*(s-1)/2 + p
        if(r.ge.q) rq = r*(r-1)/2 + q
        if(r.lt.q) rq = q*(q-1)/2 + r
        if(ps.ge.rq) psrq = ps*(ps-1)/2 + rq
        if(ps.lt.rq) psrq = rq*(rq-1)/2 + ps
******* Contribution to PSMAT and PAMAT:
        if(r.le.q) then
          PSMAT(psrq) = PSMAT(psrq) - fac*RDMval
          if(r.ne.q) PAMAT(psrq) = PAMAT(psrq) + fac*RDMval
        end if
        if(r.gt.q) then
          PSMAT(psrq) = PSMAT(psrq) - fac*RDMval
          PAMAT(psrq) = PAMAT(psrq) - fac*RDMval
        end if
        IF(IPRLEV.ge.DEBUG) THEN
          write(6,'(7I6,3G25.17)')
     &      p,s,r,q,ps,rq,psrq, RDMval,PSMAT(psrq),PAMAT(psrq)
        END IF
******* Contribution to D_alpha (not final):
* The minus sign comes from the fact that in NECI these elements have opposite sign
* compared to the element in normal order, that is d_pqrs = -d_psrq.
        if(p.eq.s) D_alpha(rq)=D_alpha(rq)-RDMval
        if(r.eq.q) D_alpha(ps)=D_alpha(ps)-RDMval
      end do
      close(iunit)
*******************************************************************************************
*************************** Processing TwoRDM-BBBB ****************************************
*******************************************************************************************
      if(switch) then
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM4')
        Rewind(iUnit)
        IF(IPRLEV.ge.DEBUG) THEN
         write(6,*) '    p     q     r     s    pq    rs   pqrs       ',
     &   'RDMval                PSMAT                   PAMAT'
         write(6,*) ' ********************** BBBB ****************** '
        END IF
        do
******************* processing as PQRS ***********************
**************************************************************
          read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
          if(iread.ne.0) exit
******* indexing:
          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r
          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
          PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(p.gt.q.and.r.gt.s) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          if(p.gt.q.and.r.lt.s) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &         p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
          END IF
******* Contribution to D_beta (not final):
          if(p.eq.q) D_beta(rs)=D_beta(rs)+RDMval
          if(r.eq.s) D_beta(pq)=D_beta(pq)+RDMval
******************* processing as PSRQ ***********************
**************************************************************
******* indexing:
          if(p.ge.s) ps = p*(p-1)/2 + s
          if(p.lt.s) ps = s*(s-1)/2 + p
          if(r.ge.q) rq = r*(r-1)/2 + q
          if(r.lt.q) rq = q*(q-1)/2 + r
          if(ps.ge.rq) psrq = ps*(ps-1)/2 + rq
          if(ps.lt.rq) psrq = rq*(rq-1)/2 + ps
******* Contribution to PSMAT and PAMAT:
          if(r.le.q) then
            PSMAT(psrq) = PSMAT(psrq) - fac*RDMval
            if(r.ne.q) PAMAT(psrq) = PAMAT(psrq) + fac*RDMval
          end if
          if(r.gt.q) then
            PSMAT(psrq) = PSMAT(psrq) - fac*RDMval
            PAMAT(psrq) = PAMAT(psrq) - fac*RDMval
          end if
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &        p,s,r,q,ps,rq,psrq, RDMval,PSMAT(psrq),PAMAT(psrq)
          END IF
******* Contribution to D_beta (not final):
* The minus sign comes from the fact that in NECI these elements have opposite sign
* compared to the element in normal order, that is d_pqrs = -d_psrq.
          if(p.eq.s) D_beta(rq)=D_beta(rq)-RDMval
          if(r.eq.q) D_beta(ps)=D_beta(ps)-RDMval
        end do
        close(iunit)
      end if ! End statement for spin-resolved RDMs.
*******************************************************************************************
*************************** Processing TwoRDM-ABAB ****************************************
*******************************************************************************************
      iUnit=IsFreeUnit(11)
      Call Molcas_Open(iUnit,'TWORDM2')
      Rewind(iUnit)
      IF(IPRLEV.ge.DEBUG) THEN
       write(6,*) ' ********************** ABAB ****************** '
      END IF
      do
        read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
        if(iread.ne.0) exit
******* indexing:
        if(p.ge.q) pq = p*(p-1)/2 + q
        if(p.lt.q) pq = q*(q-1)/2 + p
        if(r.ge.s) rs = r*(r-1)/2 + s
        if(r.lt.s) rs = s*(s-1)/2 + r
        if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
        if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
        PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
        if(r.gt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
        if(r.lt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
        if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
        IF(IPRLEV.ge.DEBUG) THEN
          write(6,'(7I6,3G25.17)')
     &        p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
        END IF
******* Contribution to D_alpha and D_beta (not final):
        if(p.eq.q)            D_alpha(rs)=D_alpha(rs)+RDMval
        if(r.eq.s.and.p.ne.r) D_beta(pq) =D_beta(pq)+RDMval
      end do
******* Copy D_beta to D_alpha and clean D_beta again for further use:
      If(.not.switch) then
        call daxpy_(NACPAR,1.0d0,D_beta,1,D_alpha,1)
        call dcopy_(NACPAR,0.0d0,0,D_beta,1)
      end if
      close(iunit)
*******************************************************************************************
*************************** Processing TwoRDM-BABA ****************************************
*******************************************************************************************
      if(switch) then
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM5')
        Rewind(iUnit)
        IF(IPRLEV.ge.DEBUG) THEN
           write(6,*) ' ********************** BABA ****************** '
        END IF
        do
          read(iUnit,"(4I6,G25.17)",iostat=iread) s,q,r,p,RDMval
          if(iread.ne.0) exit
******* indexing:
          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r
          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
          PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          if(r.gt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          if(r.lt.s.and.p.ne.q) PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          if(r.ne.s.and.p.eq.q) PSMAT(pqrs) = PSMAT(pqrs) + fac*RDMval
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &          p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
          END IF
******* Contribution to D_alpha (not final):
          if(p.eq.q)            D_beta(rs)= D_beta(rs)+RDMval
          if(r.eq.s.and.p.ne.r) D_alpha(pq)=D_alpha(pq)+RDMval
        end do
        close(iunit)
      end if ! End statement for spin-resolved RDMs.
*******************************************************************************************
*************************** Processing TwoRDM-ABBA ****************************************
*******************************************************************************************
      iUnit=IsFreeUnit(11)
      Call Molcas_Open(iUnit,'TWORDM3')
      Rewind(iUnit)
      IF(IPRLEV.ge.DEBUG) THEN
        write(6,*) ' ********************** ABBA ****************** '
      END IF
      do
        read(iUnit,"(4I6,G25.17)",iostat=iread) q,s,r,p,RDMval
        if(iread.ne.0) exit
******* indexing:
        if(p.ge.q) pq = p*(p-1)/2 + q
        if(p.lt.q) pq = q*(q-1)/2 + p
        if(r.ge.s) rs = r*(r-1)/2 + s
        if(r.lt.s) rs = s*(s-1)/2 + r
        if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
        if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
        PSMAT(pqrs) = PSMAT(pqrs) - fac*RDMval
        if(r.lt.s) then
          PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
        end if
        if(r.gt.s) then
          PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
        end if
        IF(IPRLEV.ge.DEBUG) THEN
          write(6,'(7I6,3G25.17)')
     &        p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
        END IF
******* Contribution to D_alpha (not final):
          if(r.eq.s) D_alpha(pq)=D_alpha(pq)-RDMval
          if(p.eq.q) D_beta(rs)=D_beta(rs)-RDMval
      end do
******* Copy D_beta to D_alpha and clean D_beta again for further use:
      If(.not.switch) then
        call daxpy_(NACPAR,1.0d0,D_beta,1,D_alpha,1)
        call dcopy_(NACPAR,0.0d0,0,D_beta,1)
      end if
      close(iunit)
*******************************************************************************************
*************************** Processing TwoRDM-BAAB ****************************************
*******************************************************************************************
      if(switch) then
        iUnit=IsFreeUnit(11)
        Call Molcas_Open(iUnit,'TWORDM6')
        Rewind(iUnit)
        IF(IPRLEV.ge.DEBUG) THEN
          write(6,*) ' ********************** BAAB ****************** '
        END IF
        do
          read(iUnit,"(4I6,G25.17)",iostat=iread) q,s,r,p,RDMval
          if(iread.ne.0) exit
******* indexing:
          if(p.ge.q) pq = p*(p-1)/2 + q
          if(p.lt.q) pq = q*(q-1)/2 + p
          if(r.ge.s) rs = r*(r-1)/2 + s
          if(r.lt.s) rs = s*(s-1)/2 + r
          if(pq.ge.rs) pqrs = pq*(pq-1)/2 + rs
          if(pq.lt.rs) pqrs = rs*(rs-1)/2 + pq
******* Contribution to PSMAT and PAMAT:
          PSMAT(pqrs) = PSMAT(pqrs) - fac*RDMval
          if(r.lt.s) then
            PAMAT(pqrs) = PAMAT(pqrs) + fac*RDMval
          end if
          if(r.gt.s) then
            PAMAT(pqrs) = PAMAT(pqrs) - fac*RDMval
          end if
          IF(IPRLEV.ge.DEBUG) THEN
            write(6,'(7I6,3G25.17)')
     &          p,q,r,s,pq,rs,pqrs, RDMval,PSMAT(pqrs),PAMAT(pqrs)
          END IF
******* Contribution to D_alpha (not final):
          if(p.eq.q) D_alpha(rs)=D_alpha(rs)-RDMval
          if(r.eq.s) D_beta(pq)=D_beta(pq)-RDMval
        end do
        close(iunit)
      end if ! End statement for spin-resolved RDMs.
*******************************************************************************************
***************************   Final Updates to RDMs  **************************************
*******************************************************************************************
      if(.not.switch) call dcopy_(NACPAR,D_alpha,1,D_beta,1)
******* Scale D_alpha and D_beta:
      call ScalVe(D_alpha,fcnacte,NACPAR)
      call ScalVe(D_beta ,fcnacte,NACPAR)
******* Build DSPN as (D_beta - D_alpha):
      call daxpy_(NACPAR,-1.0d0,D_alpha,1,DSPN,1)
      call daxpy_(NACPAR,1.0d0,D_beta,1,DSPN,1)
******* Build DMAT as (D_beta + D_alpha):
      call daxpy_(NACPAR,1.0d0,D_alpha,1,DMAT,1)
      call daxpy_(NACPAR,1.0d0,D_beta,1,DMAT,1)
******* Clean evil non-positive semi-definite matrices. DMAT is input and output.
      call cleanMat(DMAT)
      IF(IPRLEV.ge.DEBUG) THEN
       norb  = (int(sqrt(real(1+8*nacpar)))-1)/2
       call triprt('D_alpha in neci2molcas',' ',D_alpha,norb)
       call triprt('D_beta  in neci2molcas',' ',D_beta ,norb)
       call triprt('DMAT in neci2molcas',' ',DMAT,norb)
       call triprt('DSPN in neci2molcas',' ',DSPN,norb)
      END IF
      Call qExit('neci2molcas')
      Return

123   continue
          write(6,*) 'Error in Reading RDM files needed by Molcas!'
          write(6,*) 'Probably file not generated by NECI?'
          Call QTrace()
          Call Abend()
      End Subroutine
#elif defined (NAGFOR)
c Some compilers do not like empty files
      Subroutine empty_neci2molcas_dens()
      End
#endif
