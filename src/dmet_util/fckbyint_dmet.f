************************************************************************
* This file is part of OpenMolcas.                                     *
*                                                                      *
* OpenMolcas is free software; you can redistribute it and/or modify   *
* it under the terms of the GNU Lesser General Public License, v. 2.1. *
* OpenMolcas is distributed in the hope that it will be useful, but it *
* is provided "as is" and without any express or implied warranties.   *
* For more details see the full text of the license in the file        *
* LICENSE or in <http://www.gnu.org/licenses/>.                        *
*                                                                      *
* Copyright (C) 2004, Per-Olof Widmark                                 *
************************************************************************
************************************************************************
*                                                                      *
* This routine creates start orbitals from model fock matrix elements  *
* generated by SEWARD.                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
* Author:  Per-Olof Widmark                                            *
*          Lund University                                             *
*          Sweden                                                      *
* Written: Oct 2004                                                    *
*                                                                      *
************************************************************************
      Subroutine FckByInt_DMET(iReturn,DMET_f,nBfn,StandAlone)
      Implicit Real*8 (a-h,o-z)
#include "stdalloc.fh"
#include "Molcas.fh"
#include "commgo.fh"
#include "gsswfn.fh"
      Real*8, Dimension(:), Allocatable ::  CMO_DMET, Ovl_DMET,
     &                                      T1, T2, T3, Eps_DMET,
     &                                      Array
      Real*8 Dmet_f(*)
*----------------------------------------------------------------------*
* Dummy arguments                                                      *
*----------------------------------------------------------------------*
      Integer iReturn, nOrb(8)
*----------------------------------------------------------------------*
* Local variables                                                      *
*----------------------------------------------------------------------*
      Character*180 Line
      Logical Debug
      Logical Trace
      Character*80 Title
      Logical Verify, StandAlone
*----------------------------------------------------------------------*
      Integer IndType(7,8)
      Integer nTmp(8)
      Integer nBfnTot
      Integer nBfnMax
      Integer nTriTot
      Integer nSqrTot
      Integer iSym
      Integer iBas
      Integer jBas
      Integer kBas
      Integer iBfn, jBfn, ijBfn
*----------------------------------------------------------------------*
      Integer  inDMET_f
      Integer inCMO_DMET
      Integer inOvl_DMET
      Integer inEps_DMET
      Integer inT1
      Integer inT2
      Integer inT3
*----------------------------------------------------------------------*
      Integer Lu
      Integer irc
      Integer iSymlb
      Integer ij,ijS,ijT,ijL
      Integer nB
      Integer nC
      Integer nS
      Integer nD
      Integer nActEl
      Real*8  dActEl
      Integer nIsh(8)
      Integer nAsh(8)
      Integer nDel(MxSym), nBfn
*      Logical PrintPop, PrintMOs
*----------------------------------------------------------------------*
*  Some setup
*----------------------------------------------------------------------*
       If(StandAlone) Then
           Debug=.false.
           Trace=.false.
       Else
           Debug=.false.
           Trace=.false.
       End If
       If(Trace) Then
         Write(6,*) '>>> Entering fckbyint'
         Call xflush(6)
       End If
      iReturn=0
      Call getenvf('MOLCAS_TEST',Line)
      Verify = LINE(1:5).EQ.'CHECK' .or. LINE(1:4).EQ.'GENE'
      Verify = .True.
*----------------------------------------------------------------------*
* Do some counting                                                     *
*----------------------------------------------------------------------*
      nBfnTot=0
      nBfnMax=0
      nTriTot=0
      nSqrTot=0
      Do iSym=1,nSym
         nBfnTot=nBfnTot+nBfn(iSym)
         nBfnMax=Max(nBfnmax,nBfn(iSym))
         nTriTot=nTriTot+nBfn(iSym)*(nBfn(iSym)+1)/2
         nSqrTot=nSqrTot+nBfn(iSym)*nBfn(iSym)
      End Do
*----------------------------------------------------------------------*
* Get model Fock matrix.                                               *
*----------------------------------------------------------------------*
*      inDMET_f=nTriTot+6
      inDMET_f=nTriTpt+6
*      call mma_allocate(Varinia, inDMET_f)
*      Write(6,*) 'allocate after VB'
*      Call mma_allocate(DMET_f,inDMET_f)
      iRc=-1
      iSymlb=1
      Call WrOne(iRC,6,'FckInt  ',1,DMET_f,iSmLbl)
      Call RdOne(irc,6,'FckInt  ',1,DMET_f,iSymlb)
      Write(6,*) 'rdone'
*      Call TriPrt('FckInt','(12f12.6)',DMET_f(ij),nBfn(iSym))

************************************************************************
*     Compute all SO integrals for all components of the operator.
************************************************************************
*      Do iBfn = 1, nBfn
*         Do jBfn = 1, iBfn
*            ijBfn = iBfn*(iBfn-1)/2 + jBfn - 1 + ip(1)
*            Array(ijBfn)=DMET_h(iBfn,jBfn)
*         End Do
*      End Do
*************************************************************************
*
*      Call PrMtrx(Label,lOper,nComp,ip,Array)

      If (iRc.ne.0) Then
         iReturn=1
*         Call mma_deallocate(DMET_f)
         Write(6,*) '***'
         Write(6,*) '*** WARNING:'
         Write(6,*) '*** Guessorb did not produce start orbitals!!!'
         Write(6,*) '***'
         Return
      End If
      If(Debug) Then
         ij=1
         Do iSym=1,nSym
           Call TriPrt('FckInt','(12f12.6)',DMET_f(ij),nBfn(iSym))
           Call NrmClc(DMET_f(ij),nBfn(iSym)*(nBfn(iSym)+1)/2,
     &                  'FckbyInt',
     &                  'Fck(ij)')
            ij=ij+nBfn(iSym)*(nBfn(iSym)+1)/2
         End Do
*       Call PrMtrx("DMET_f",lOper,nComp,ip,DMET_f(ij))
      End If
*----------------------------------------------------------------------*
* Make symmetric orthonormal orbital basis.                            *
*----------------------------------------------------------------------*
      inCMO_DMET=nSqrTot
      Write(6,*) 'CMO'
      Call mma_allocate(CMO_DMET,inCMO_DMET)
      Write(6,*) 'CMO allocate'
      Call goLowdin(CMO_DMET)
      Write(6,*) 'go lowdin'
      If (Debug) Then
         ij=1
         Do iSym=1,nSym
            nB=nBfn(iSym)
*           Call RecPrt('CMO_DMET','(12f12.6)',CMO_DMET(ij),nB,nB)
            Call NrmClC(CMO_DMET(ij),nB**2,'FckbyInt_DMET',
     &                  'CMO_DMET(ij)')
            ij=ij+nB*nB
         End Do
      End If
*----------------------------------------------------------------------*
* Get overlap matrix                                                   *
*----------------------------------------------------------------------*
      inOvl_DMET=nTriTot+6
      Call mma_allocate(Ovl_DMET,inOvl_DMET)
      iSymlb=1
      Call RdOne(irc,6,'Mltpl  0',1,Ovl_DMET,iSymlb)
      If(Debug) Then
         ipT1=1
         Do iSym=1,nSym
*           Call TriPrt('Ovl_DMETp','(12f12.6)',Ovl_DMET(ipT1),nBfn(iSym))
            Call NrmClc(Ovl_DMET(ipT1),nBfn(iSym)*(nBfn(iSym)+1)/2,
     &                  'FckbyInt','Ovl_DMET(ipT1)')
            ipT1=ipT1+nBfn(iSym)*(nBfn(iSym)+1)/2
         End Do
      End If
*----------------------------------------------------------------------*
* Transform: F = S Eps_DMET S                                               *
*----------------------------------------------------------------------*
      inT1=nBfnMax*nBfnMax
      inT2=nBfnMax*nBfnMax
      inT3=nBfnMax*nBfnMax
      Call mma_allocate(T1,inT1)
      Call mma_allocate(T2,inT2)
      Call mma_allocate(T3,inT3)
      ijT=1
      ijS=1
      ijL=1
      Do iSym=1,nSym
         nB=nBfn(iSym)
         If(nB.gt.0) Then
            Call Square(DMET_f(ijT),T1,1,nB,nB)
            Call Square(Ovl_DMET(ijT),T2,1,nB,nB)
            Call DGEMM_('N','N',
     &                  nB,nB,nB,
     &                  1.0d0,T1,nB,
     &                        T2,nB,
     &                  0.0d0,T3,nB)
            Call MxMt(T2,nB,1,
     &                T3,1,nB,
     &                DMET_f(ijT), nB,nB)
            If(Debug) Then
*              Call TriPrt('Fock matrix with metric','(12f12.6)',
*    &                     DMET_f(ijT),nB)
               Call NrmClc(DMET_f(ijT),nB*(nB+1)/2,'FckbyInt_DMET',
     &                  'DMET_f(ijT)')
            End If
         End If
         ijT=ijT+nB*(nB+1)/2
         ijS=ijS+nB*nB
         ijL=ijL+nB
      End Do
      Call mma_deallocate(T3)
      Call mma_deallocate(T2)
      Call mma_deallocate(T1)
*----------------------------------------------------------------------*
* Diagonalize the model Fock matrix                                    *
*----------------------------------------------------------------------*
      inEps_DMET=nBfnTot
      Call mma_allocate(Eps_DMET,inEps_DMET)
      inT1=nBfnMax*nBfnMax
      inT2=nBfnMax*nBfnMax
      inT3=nBfnMax*nBfnMax
      Call mma_allocate(T1,inT1)
      Call mma_allocate(T2,inT2)
      Call mma_allocate(T3,inT3)
      ijT=1
      ijS=1
      ijL=1
      Do iSym=1,nSym
         nB=nBfn(iSym)
         nS=nBfn(iSym)-nDel(iSym)
         If(nB.gt.0) Then
            Call Square(DMET_f(ijT),T1,1,nB,nB)
            Call DGEMM_('N','N',
     &                  nB,nS,nB,
     &                  1.0d0,T1,nB,
     &                        CMO_DMET(ijS),nB,
     &             0.0d0,T2,nB)
            Call MxMt(CMO_DMET(ijS),nB,1,
     &                T2,1,nB,
     &                T3, nS,nB)
            If(Debug) Then
*              Call TriPrt('Transformed Fock matrix','(12f12.6)',T3,nB)
               Call NrmClc(T3,nB*(nB+1)/2,'FckbyInt_DMET',
     &                'Transformed Fck')
            End If
            Call NIdiag(T3,CMO_DMET(ijS),nS,nB,0)
            Call goPickup(T3,Eps_DMET(ijL),nS)
            Call goSort(Eps_DMET(ijL),CMO_DMET(ijS),nS,nB)
*
            Do i = 1, nS
               tmp = OrbPhase(CMO_DMET(ijS+(i-1)*nB),nB)
            End Do
         End If
         ijT=ijT+nB*(nB+1)/2
         ijS=ijS+nB*nB
         ijL=ijL+nB
      End Do
      If (Debug) Then
         ij=1
         Do iSym=1,nSym
            nB=nBfn(iSym)
*           Call RecPrt('CMO_DMET','(12f12.6)',CMO_DMET(ij),nB,nB)
            Call NrmClC(CMO_DMET(ij),nB**2,'FckbyInt','CMO_DMET(ij)')
            ij=ij+nB*nB
         End Do
      End If
      Call mma_deallocate(T3)
      Call mma_deallocate(T2)
      Call mma_deallocate(T1)
*----------------------------------------------------------------------*
* Diagonalize T in virtual space.                                      *
*----------------------------------------------------------------------*
      If(.false.) Goto 900
      iRc=-1
      iSymlb=1
      Call RdOne(irc,6,'Kinetic ',1,DMET_f,iSymlb)
      If (iRc.ne.0) Goto 900
      inT1=nBfnMax*nBfnMax
      inT2=nBfnMax*nBfnMax
      inT3=nBfnMax*nBfnMax
      Call mma_allocate(T1,inT1)
      Call mma_allocate(T2,inT2)
      Call mma_allocate(T3,inT3)
      ijT=1
      ijS=1
      ijL=1
      Do iSym=1,nSym
         nB=nBfn(iSym)
         nD=nDel(iSym)
         nC=0
         Do iBas=1,nB-nD
            If(Eps_DMET(ijL+iBas-1).lt.-1.0d-3) nC=nC+1
         End Do
         nS=nB-nC-nD
         If(nS.gt.0) Then
*
*           Generate standardized virtual orbitals before we proceed.
*           The virtual orbitals generated previously are not well
*           defined and might differ substantially with different
*           hardware/software and compiler options. To be able to
*           compare we will need these standardized virtual orbitals.
*           In real production calculations this step could for all
*           practical purposes be skipped.
*
            If (Verify)
     &      Call Virt_Space(CMO_DMET(ijS),CMO_DMET(ijS+nB*nC),
     &                      Ovl_DMET(ijT),nB,nC,nS)
*
            Call Square(DMET_f(ijT),T1,1,nB,nB)
            Call DGEMM_('N','N',
     &                  nB,nS,nB,
     &                  1.0d0,T1,nB,
     &                        CMO_DMET(ijS+nB*nC),nB,
     &                  0.0d0,T2,nB)

            Call MxMt(CMO_DMET(ijS+nB*nC),nB,1,
     &                T2,1,nB,
     &                T3, nS,nB)
            If(Debug) Then
               Call TriPrt('Virtual space','(12f12.6)',T3,nS)
            End If
            Call NIdiag(T3,CMO_DMET(ijS+nB*nC),nS,nB,0)
            Call goPickup(T3,Eps_DMET(ijL+nC),nS)
            Call goSort(Eps_DMET(ijL+nC),CMO_DMET(ijS+nB*nC),nS,nB)
            If(Debug) Then
               Call RecPrt('Eps_DMET',' ',Eps_DMET(ijL+nC),nS,1)
               Call RecPrt('Virtual Orbitals',' ',
     &                     CMO_DMET(ijS+nB*nC),nB,nS)
            End If
*
*           Now order degenerate orbitals. This is only important for
*           verification runs.
*
            Do iBas = nC+1, nB-nD-1
               ei = Eps_DMET(ijL+iBas-1)
               tmp1 = 0.0d0
               Do kBas = 1, nB
                  ik = ijS+ (iBas-1)*nB + kBas -1
                  tmp1 = tmp1 + Abs(CMO_DMET(ik)*DBLE(kBas))
               End Do
               Do jBas = iBas+1, nB-nD
                  ej = Eps_DMET(ijL+jBas-1)
                  If (Abs(ei-ej).lt.1.0D-12) Then
                     tmp2 = 0.0d0
                     Do kBas = 1, nB
                        jk = ijS+ (jBas-1)*nB + kBas -1
                        tmp2 = tmp2 + Abs(CMO_DMET(jk)*DBLE(kBas))
                     End Do
                     If (tmp2.gt.tmp1) Then
                        tmp=tmp2
                        tmp2=tmp1
                        tmp1=tmp
                        Eps_DMET(ijL+iBas-1) = ej
                        Eps_DMET(ijL+jBas-1) = ei
                        ei = ej
                        i1 = ijS+ (iBas-1)*nB
                        j1 = ijS+ (jBas-1)*nB
                        Call DSwap_(nB,CMO_DMET(i1),1,CMO_DMET(j1),1)
                     End If
                  End If

               End Do
            End Do
*
*           Introduce "standard" phase.
*
            Do iBas = 1, nB
               tmp = OrbPhase(CMO_DMET(ijS+(iBas-1)*nB),nB)
            End Do
*
            If(Debug) Then
               Call RecPrt('Eps_DMET',' ',Eps_DMET(ijL+nC),nS,1)
               Call RecPrt('Virtual Orbitals',' ',
     &                     CMO_DMET(ijS+nB*nC),nB,nS)
            End If
            Do iBas=nC+1,nB-nD
               Eps_DMET(ijL+iBas-1)=Eps_DMET(ijL+iBas-1)+3.0d0
            End Do
            Do iBas=nB-nD+1,nB
               Eps_DMET(ijL+iBas-1)=999.0d0
            End Do
            Do iBas=1,nB-nD
               If(Eps_DMET(ijL+iBas-1).gt.TThr)
     &           nDel(iSym) = nDel(iSym)+1
            End Do
         End If
         ijT=ijT+nB*(nB+1)/2
         ijS=ijS+nB*nB
         ijL=ijL+nB
      End Do
      Call mma_deallocate(T3)
      Call mma_deallocate(T2)
      Call mma_deallocate(T1)
*----------------------------------------------------------------------*
* Present data.                                                        *
*----------------------------------------------------------------------*
900   Continue
      inT1=nBfnTot
      inT2=nBfnTot
      Call mma_allocate(T1,inT1)
      Call mma_allocate(T2,inT2)
      Do iBas=1,nBfnTot
         T1(iBas)=0.0d0
      End Do
      Call GoPop(Eps_DMET,T1,T2,nBfnTot,PrintEor,PrThr,GapThr)
      iBas=0
      dActEl=0.0d0
      Do iSym=1,nSym
         IndType(1,iSym)=0
         IndType(2,iSym)=0
         IndType(3,iSym)=0
         IndType(4,iSym)=0
         IndType(5,iSym)=0
         IndType(6,iSym)=nBfn(iSym)-nDel(iSym)
         IndType(7,iSym)=nDel(iSym)
         Do kBas=1,nBfn(iSym)-nDel(iSym)
            iBas=iBas+1
            If(T1(iBas).gt.1.99d0) Then
               IndType(2,iSym)=IndType(2,iSym)+1
               IndType(6,iSym)=IndType(6,iSym)-1
            Else If(T1(iBas).gt.0.01d0) Then
               IndType(4,iSym)=IndType(4,iSym)+1
               IndType(6,iSym)=IndType(6,iSym)-1
               dActEl=dActEl+T1(iBas)
            End If
         End Do
      End Do
      nActEl=Int(dActEl+0.5d0)
      If(PrintMOs) then
         Call PriMO('Start orbitals (virtuals shifted)',
     &              .true.,.true.,0.0d0,PrThr,
     &              nSym,nBfn,nBfn,Label,Eps_DMET,T1,
     &              CMO_DMET,iPrFmt)
         Call xflush(6)
      End If
      If(PrintPop) Then
         Call Charge(nSym,nBfn,Label,CMO_DMET,T1,
     &               Ovl_DMET,2,.true.,.true.)
      End If
      Call put_darray('Guessorb',CMO_DMET,nSqrTot)
      Call put_darray('Guessorb energies',Eps_DMET,nBfnTot)
      Do iSym=1,nSym
         nOrb(iSym)=nBfn(iSym)-nDel(iSym)
      End Do
      Call Put_iArray('nOrb',nOrb,nSym)
      Call Put_iArray('nDel_go',nDel,nSym)
      Call Put_iArray('nDel',nDel,nSym)
      Do iSym=1,nSym
         nTmp(iSym)=IndType(2,iSym)
         nIsh(iSym)=nTmp(iSym)
      End Do
      Call Put_iArray('nIsh',nTmp,nSym)
      Do iSym=1,nSym
         nTmp(iSym)=IndType(4,iSym)
         nAsh(iSym)=nTmp(iSym)
      End Do
      Call Put_iArray('nAsh',nTmp,nSym)
      Call Put_iScalar('nActel',nActEl)
      kSpin=1 ! always same alpha and beta orbs
      Call Put_iScalar('Multiplicity',kSpin)
      Enr_go=0.0d0
      ipEE0=1
      ipOk0=1
      Do iSym=1,nSym
         Do i=0,nIsh(iSym)+nAsh(iSym)-1
            ipEE=ipEE0+i
            ipOk=ipOk0+i
            Enr_go=Enr_go+T1(ipOk)*Eps_DMET(ipEE)
         End Do
         ipEE0=ipEE0+nBfn(iSym)
         ipOk0=ipOk0+nBfn(iSym)
      End Do
      Call Put_dScalar('Last energy',Enr_go)
#ifdef _HDF5_
      call mh5_put_dset(wfn_energy,Enr_go)
#endif
      Lu=20
      Title='Guess orbitals'
      Call WrVec('GSSORB',Lu,'COEI',nSym,nBfn,nBfn,CMO_DMET,
     &           T1,Eps_DMET,IndType,Title)
#ifdef _HDF5_
      call mh5_put_dset(wfn_mocoef,CMO_DMET)
      call mh5_put_dset(wfn_occnum,T1)
      call mh5_put_dset(wfn_orbene,Eps_DMET)
#endif
*
* Compute density matrix (re-use memory allocated in Ovl_DMET)
      iOff=1
      jOff=1
      kOff=1
      Do iSym=1,nSym
         ipOkk=iOff
         nOkk=nIsh(iSym)+nAsh(iSym)
         ipCOk=jOff
         Do k=0,nOkk-1
            xocc=sqrt(T1(k+ipOkk))
            call dscal_(nBfn(iSym),xocc,CMO_DMET(ipCOk),1)
            ipCOk=ipCOk+nBfn(iSym)
         End Do
         Call DGEMM_Tri('N','T',nBfn(iSym),nBfn(iSym),nOkk,
     &                    1.0d0,CMO_DMET(jOff),Max(1,nBfn(iSym)),
     &                          CMO_DMET(jOff),Max(1,nBfn(iSym)),
     &                    0.0d0,Ovl_DMET(kOff),Max(1,nBfn(iSym)))
         iOff=iOff+nBfn(iSym)
         jOff=jOff+nBfn(iSym)**2
         kOff=kOff+nBfn(iSym)*(nBfn(iSym)+1)/2
      End Do
      Call Fold_tMat(nSym,nBfn,Ovl_DMET,Ovl_DMET)
      Call Put_D1ao(Ovl_DMET,nTriTot)
*
      Call mma_deallocate(T2)
      Call mma_deallocate(T1)
*----------------------------------------------------------------------*
* Done, deallocate the rest.                                           *
*----------------------------------------------------------------------*
      Call mma_deallocate(Eps_DMET)
      Call mma_deallocate(Ovl_DMET)
      Call mma_deallocate(CMO_DMET)
*      Call mma_deallocate(DMET_f)
      If(Trace) Then
         Write(6,*) '<<< Exiting fckbyint_DMET'
         Call xflush(6)
      End If
      Return
      End
