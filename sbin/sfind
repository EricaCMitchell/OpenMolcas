#!/bin/bash

#***********************************************************************
# This file is part of OpenMolcas.                                     *
#                                                                      *
# OpenMolcas is free software; you can redistribute it and/or modify   *
# it under the terms of the GNU Lesser General Public License, v. 2.1. *
# OpenMolcas is distributed in the hope that it will be useful, but it *
# is provided "as is" and without any express or implied warranties.   *
# For more details see the full text of the license in the file        *
# LICENSE or in <http://www.gnu.org/licenses/>.                        *
#                                                                      *
# Copyright (C) 2016, Ignacio Fdez. Galv√°n                             *
#***********************************************************************

shopt -s extglob

function usage {
  bn=$(basename $0)
  cat << EOF

Script to locate a subroutine or function in molcas

Usage:
  $bn name

where: name is a routine name (or a part of routine name)
       or a filename (if it contains a ".")

  $bn -conf[licts] : finds name collisions with libraries
  $bn -Conf[licts] : same as above, but for everything

EOF
}

function search {
  IFS=$'\r\n'
  results=$(git grep --untracked -E -i -n -e "^[^!*c'\"].*(function|subroutine)  *\w*$1" --and --not -e "end " -- $rootdir/src*)
  maxfile=0
  maxnum=0
  for match in $results; do
    IFS=$':' read -ra split <<< "$match"
    thisfile=${split[0]}
    thisnum=${split[1]}
    thistext=${split[@]:2}
    maxfile=$((${#thisfile} > $maxfile ? ${#thisfile} : $maxfile))
    maxnum=$((${#thisnum} > $maxnum ? ${#thisnum} : $maxnum))
    file+=($thisfile)
    num+=($thisnum)
    text+=($thistext)
  done

  if (( ${#file[@]} > 0 )); then
    for i in $(seq 0 $((${#file[@]}-1)) ); do
      printf "%-${maxfile}s : %${maxnum}d : %s\n" ${file[$i]} ${num[$i]} ${text[$i]}
    done
  else
    echo "No match found for \"$1\""
  fi
}

function conflicts {
  all=$1
  if [[ $(ctags --version 2>&1) =~ ^Exuberant ]]; then
    havectags=1
  fi
  if [ "$havectags" != 1 ]; then
    echo "Exuberant ctags is needed to find conflicts"
    return
  fi
  IFS=$'\r\n'
  funcs=( $(ctags -x --c-kinds=f --fortran-kinds=fs -h .h.fh --langmap=c:.c.h,fortran:.f.f90.fh --languages=c,fortran -R $rootdir/src*) )
  declare -A unique
  for func in ${funcs[@]}; do
    IFS=$' ' read -ra split <<< "$func"
    key=${split[0],,}
    val=${split[3]#$rootdir/src*([^\/])/}
    if [ ! -z ${unique[$key]} ]; then
      skip=0
      dir1=$(basename $(dirname ${unique[$key]}))
      dir2=$(basename $(dirname $val))
      if [[ ! $all ]]; then
        if [[ ! ( $dir1 =~ util$ || $dir2 =~ util$ ) ]]; then
          skip=1
        fi
      fi
      if [[ $dir1 =~ ^clones  || $dir2 =~ ^clones  ||
            $dir1 =~ ^delayed || $dir2 =~ ^delayed ||
            $dir1 =~ ^ma_     || $dir2 =~ ^ma_     ||
            $dir1 =~ ^ga_     || $dir2 =~ ^ga_     ]]; then
        skip=1
      fi
      if [ ${unique[$key]} == $val ]; then
        skip=1
      fi
      if [ $skip != 1 ]; then
        echo Conflict: $key found in ${unique[$key]} and $val
      fi
    else
      unique[$key]=$val
    fi
  done
}

function findfile {
  results=$(find $rootdir/src* -name "$1")
  for match in $results; do
    echo ${match/$rootdir\//}
  done
}

query=$1
rootdir=$(git rev-parse --show-toplevel)

if [ -z "$query" ]; then
  usage
elif [[ "$query" =~ ^-conf ]]; then
  conflicts
elif [[ "$query" =~ ^-Conf ]]; then
  conflicts 1
elif [[ "$query" =~ \. ]]; then
  findfile $query
else
  search $query
fi
